"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api/api-client.ts":
/*!***********************************!*\
  !*** ./src/lib/api/api-client.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\n// Base URL configuration from environment variable or default\nconst API_URL = \"http://localhost:3001/api\" || 0;\n// Create axios instance with base configuration\nconst instance = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    timeout: 15000 // 15 seconds timeout\n});\n// Request interceptor to add auth token\ninstance.interceptors.request.use((config)=>{\n    // Get token from localStorage if available\n    const token =  true ? localStorage.getItem(\"token\") : 0;\n    // Add token to headers if available\n    if (token) {\n        config.headers.Authorization = \"Bearer \".concat(token);\n    }\n    // Special handling for requests with file uploads\n    if (config.data && config.data instanceof FormData) {\n        config.headers[\"Content-Type\"] = \"multipart/form-data\";\n    } else if (config.data && typeof config.data !== \"string\") {\n        try {\n            // Test if data can be stringified (avoid errors with File objects)\n            JSON.stringify(config.data);\n        } catch (error) {\n            console.error(\"Invalid JSON data in request:\", error);\n            throw new Error(\"Invalid JSON data in request\");\n        }\n    }\n    return config;\n}, (error)=>{\n    return Promise.reject(error);\n});\n// Response interceptor for handling common errors\ninstance.interceptors.response.use((response)=>{\n    // If the response has data property, return it directly\n    return response.data;\n}, (error)=>{\n    // Handle errors based on status codes\n    if (error.response) {\n        const status = error.response.status;\n        // Handle authentication errors\n        if (status === 401) {\n            // Only clear token on server auth errors, not client validation errors\n            if (error.response.config.url !== \"/auth/login\" && error.response.config.url !== \"/auth/register\" && error.response.config.method !== \"post\") {\n                // Check if we're already on the login page or if we have a pending auth request\n                const isAuthRelatedPath = window.location.pathname.includes(\"/auth/\");\n                const isCheckingAuth = error.response.config.url === \"/auth/me\" || error.response.config.url === \"/auth/current-user\";\n                // Only clear token and redirect if not already on auth page and not checking auth\n                if ( true && !isAuthRelatedPath && !isCheckingAuth) {\n                    localStorage.removeItem(\"token\");\n                    localStorage.removeItem(\"user\");\n                    // Store the current location for redirecting back after login\n                    localStorage.setItem(\"redirectAfterLogin\", window.location.pathname);\n                    // Use router for navigation instead of direct location change\n                    // This is smoother and maintains React state\n                    window.location.href = \"/auth/login\";\n                }\n            }\n        }\n        // Format error message with more context\n        let errorMessage;\n        if (error.response.data && typeof error.response.data === \"object\") {\n            if (\"message\" in error.response.data) {\n                errorMessage = error.response.data.message;\n            } else {\n                errorMessage = JSON.stringify(error.response.data);\n            }\n        } else {\n            errorMessage = error.message || \"Unknown error\";\n        }\n        // Enhance error object with formatted message\n        const enhancedError = new Error(errorMessage);\n        enhancedError.status = status;\n        enhancedError.data = error.response.data;\n        enhancedError.originalError = error;\n        return Promise.reject(enhancedError);\n    }\n    // Network errors, server not responding, etc.\n    if (error.request) {\n        const networkError = new Error(\"Network error. Please check your connection or try again later.\");\n        return Promise.reject(networkError);\n    }\n    // Something else caused the error\n    return Promise.reject(error);\n});\n// API client methods with types\nconst apiClient = {\n    get: async function(url) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            return await instance.get(url, config);\n        } catch (error) {\n            console.error(\"GET \".concat(url, \" failed:\"), error);\n            throw error;\n        }\n    },\n    post: async function(url) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        try {\n            return await instance.post(url, data, config);\n        } catch (error) {\n            console.error(\"POST \".concat(url, \" failed:\"), error);\n            throw error;\n        }\n    },\n    put: async function(url) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        try {\n            return await instance.put(url, data, config);\n        } catch (error) {\n            console.error(\"PUT \".concat(url, \" failed:\"), error);\n            throw error;\n        }\n    },\n    delete: async function(url) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            return await instance.delete(url, config);\n        } catch (error) {\n            console.error(\"DELETE \".concat(url, \" failed:\"), error);\n            throw error;\n        }\n    },\n    patch: async function(url) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        try {\n            return await instance.patch(url, data, config);\n        } catch (error) {\n            console.error(\"PATCH \".concat(url, \" failed:\"), error);\n            throw error;\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (apiClient);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL2FwaS1jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7QUFBeUQ7QUFFekQsOERBQThEO0FBQzlELE1BQU1DLFVBQVVDLDJCQUErQixJQUFJO0FBRW5ELGdEQUFnRDtBQUNoRCxNQUFNRyxXQUEwQkwsNkNBQUtBLENBQUNNLE1BQU0sQ0FBQztJQUMzQ0MsU0FBU047SUFDVE8sU0FBUztRQUNQLGdCQUFnQjtJQUNsQjtJQUNBQyxTQUFTLE1BQU0scUJBQXFCO0FBQ3RDO0FBRUEsd0NBQXdDO0FBQ3hDSixTQUFTSyxZQUFZLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUMvQixDQUFDQztJQUNDLDJDQUEyQztJQUMzQyxNQUFNQyxRQUFRLEtBQWtCLEdBQWNDLGFBQWFDLE9BQU8sQ0FBQyxXQUFXLENBQUk7SUFFbEYsb0NBQW9DO0lBQ3BDLElBQUlGLE9BQU87UUFDVEQsT0FBT0wsT0FBTyxDQUFDUyxhQUFhLEdBQUcsVUFBZ0IsT0FBTkg7SUFDM0M7SUFFQSxrREFBa0Q7SUFDbEQsSUFBSUQsT0FBT0ssSUFBSSxJQUFJTCxPQUFPSyxJQUFJLFlBQVlDLFVBQVU7UUFDbEROLE9BQU9MLE9BQU8sQ0FBQyxlQUFlLEdBQUc7SUFDbkMsT0FBTyxJQUFJSyxPQUFPSyxJQUFJLElBQUksT0FBT0wsT0FBT0ssSUFBSSxLQUFLLFVBQVU7UUFDekQsSUFBSTtZQUNGLG1FQUFtRTtZQUNuRUUsS0FBS0MsU0FBUyxDQUFDUixPQUFPSyxJQUFJO1FBQzVCLEVBQUUsT0FBT0ksT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxNQUFNLElBQUlFLE1BQU07UUFDbEI7SUFDRjtJQUVBLE9BQU9YO0FBQ1QsR0FDQSxDQUFDUztJQUNDLE9BQU9HLFFBQVFDLE1BQU0sQ0FBQ0o7QUFDeEI7QUFHRixrREFBa0Q7QUFDbERqQixTQUFTSyxZQUFZLENBQUNpQixRQUFRLENBQUNmLEdBQUcsQ0FDaEMsQ0FBQ2U7SUFD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O1lBQ3JDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBMEIsS0FBSyxlQUFVbkI7WUFBYVgsd0VBQU8sQ0FBQyxHQUFHTCwwRUFBUyxDQUFDO1FBQy9DLElBQUk7WUFDRixPQUFPLE1BQU1SLFNBQVMyQyxHQUFHLENBQVNuQixLQUFLWCxNQUFNTDtRQUMvQyxFQUFFLE9BQU9TLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLE9BQVcsT0FBSk8sS0FBSSxhQUFXUDtZQUNwQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQTJCLFFBQVEsZUFBVXBCO1lBQWFoQiwwRUFBUyxDQUFDO1FBQ3ZDLElBQUk7WUFDRixPQUFPLE1BQU1SLFNBQVM0QyxNQUFNLENBQVNwQixLQUFLaEI7UUFDNUMsRUFBRSxPQUFPUyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxVQUFjLE9BQUpPLEtBQUksYUFBV1A7WUFDdkMsTUFBTUE7UUFDUjtJQUNGO0lBRUE0QixPQUFPLGVBQVVyQjtZQUFhWCx3RUFBTyxDQUFDLEdBQUdMLDBFQUFTLENBQUM7UUFDakQsSUFBSTtZQUNGLE9BQU8sTUFBTVIsU0FBUzZDLEtBQUssQ0FBU3JCLEtBQUtYLE1BQU1MO1FBQ2pELEVBQUUsT0FBT1MsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsU0FBYSxPQUFKTyxLQUFJLGFBQVdQO1lBQ3RDLE1BQU1BO1FBQ1I7SUFDRjtBQUNGO0FBRUEsK0RBQWV1QixTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpL2FwaS1jbGllbnQudHM/OGQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MsIHsgQXhpb3NFcnJvciwgQXhpb3NJbnN0YW5jZSB9IGZyb20gJ2F4aW9zJztcblxuLy8gQmFzZSBVUkwgY29uZmlndXJhdGlvbiBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIGRlZmF1bHRcbmNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpJztcblxuLy8gQ3JlYXRlIGF4aW9zIGluc3RhbmNlIHdpdGggYmFzZSBjb25maWd1cmF0aW9uXG5jb25zdCBpbnN0YW5jZTogQXhpb3NJbnN0YW5jZSA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IEFQSV9VUkwsXG4gIGhlYWRlcnM6IHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH0sXG4gIHRpbWVvdXQ6IDE1MDAwIC8vIDE1IHNlY29uZHMgdGltZW91dFxufSk7XG5cbi8vIFJlcXVlc3QgaW50ZXJjZXB0b3IgdG8gYWRkIGF1dGggdG9rZW5cbmluc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcbiAgKGNvbmZpZykgPT4ge1xuICAgIC8vIEdldCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJykgOiBudWxsO1xuICAgIFxuICAgIC8vIEFkZCB0b2tlbiB0byBoZWFkZXJzIGlmIGF2YWlsYWJsZVxuICAgIGlmICh0b2tlbikge1xuICAgICAgY29uZmlnLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgICBcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIGZpbGUgdXBsb2Fkc1xuICAgIGlmIChjb25maWcuZGF0YSAmJiBjb25maWcuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICBjb25maWcuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XG4gICAgfSBlbHNlIGlmIChjb25maWcuZGF0YSAmJiB0eXBlb2YgY29uZmlnLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUZXN0IGlmIGRhdGEgY2FuIGJlIHN0cmluZ2lmaWVkIChhdm9pZCBlcnJvcnMgd2l0aCBGaWxlIG9iamVjdHMpXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGNvbmZpZy5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgSlNPTiBkYXRhIGluIHJlcXVlc3Q6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBkYXRhIGluIHJlcXVlc3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSxcbiAgKGVycm9yKSA9PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuKTtcblxuLy8gUmVzcG9uc2UgaW50ZXJjZXB0b3IgZm9yIGhhbmRsaW5nIGNvbW1vbiBlcnJvcnNcbmluc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4ge1xuICAgIC8vIElmIHRoZSByZXNwb25zZSBoYXMgZGF0YSBwcm9wZXJ0eSwgcmV0dXJuIGl0IGRpcmVjdGx5XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIChlcnJvcjogQXhpb3NFcnJvcikgPT4ge1xuICAgIC8vIEhhbmRsZSBlcnJvcnMgYmFzZWQgb24gc3RhdHVzIGNvZGVzXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSBlcnJvci5yZXNwb25zZS5zdGF0dXM7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBhdXRoZW50aWNhdGlvbiBlcnJvcnNcbiAgICAgIGlmIChzdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAvLyBPbmx5IGNsZWFyIHRva2VuIG9uIHNlcnZlciBhdXRoIGVycm9ycywgbm90IGNsaWVudCB2YWxpZGF0aW9uIGVycm9yc1xuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UuY29uZmlnLnVybCAhPT0gJy9hdXRoL2xvZ2luJyAmJiBcbiAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlLmNvbmZpZy51cmwgIT09ICcvYXV0aC9yZWdpc3RlcicgJiYgXG4gICAgICAgICAgICBlcnJvci5yZXNwb25zZS5jb25maWcubWV0aG9kICE9PSAncG9zdCcpIHtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhbHJlYWR5IG9uIHRoZSBsb2dpbiBwYWdlIG9yIGlmIHdlIGhhdmUgYSBwZW5kaW5nIGF1dGggcmVxdWVzdFxuICAgICAgICAgIGNvbnN0IGlzQXV0aFJlbGF0ZWRQYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmluY2x1ZGVzKCcvYXV0aC8nKTtcbiAgICAgICAgICBjb25zdCBpc0NoZWNraW5nQXV0aCA9IGVycm9yLnJlc3BvbnNlLmNvbmZpZy51cmwgPT09ICcvYXV0aC9tZScgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlLmNvbmZpZy51cmwgPT09ICcvYXV0aC9jdXJyZW50LXVzZXInO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE9ubHkgY2xlYXIgdG9rZW4gYW5kIHJlZGlyZWN0IGlmIG5vdCBhbHJlYWR5IG9uIGF1dGggcGFnZSBhbmQgbm90IGNoZWNraW5nIGF1dGhcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzQXV0aFJlbGF0ZWRQYXRoICYmICFpc0NoZWNraW5nQXV0aCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBsb2NhdGlvbiBmb3IgcmVkaXJlY3RpbmcgYmFjayBhZnRlciBsb2dpblxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlZGlyZWN0QWZ0ZXJMb2dpbicsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVzZSByb3V0ZXIgZm9yIG5hdmlnYXRpb24gaW5zdGVhZCBvZiBkaXJlY3QgbG9jYXRpb24gY2hhbmdlXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNtb290aGVyIGFuZCBtYWludGFpbnMgUmVhY3Qgc3RhdGVcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9hdXRoL2xvZ2luJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9ybWF0IGVycm9yIG1lc3NhZ2Ugd2l0aCBtb3JlIGNvbnRleHRcbiAgICAgIGxldCBlcnJvck1lc3NhZ2U6IHN0cmluZztcbiAgICAgIFxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlLmRhdGEgJiYgdHlwZW9mIGVycm9yLnJlc3BvbnNlLmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gZXJyb3IucmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlLmRhdGEubWVzc2FnZSBhcyBzdHJpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbmhhbmNlIGVycm9yIG9iamVjdCB3aXRoIGZvcm1hdHRlZCBtZXNzYWdlXG4gICAgICBjb25zdCBlbmhhbmNlZEVycm9yOiBhbnkgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIGVuaGFuY2VkRXJyb3Iuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgZW5oYW5jZWRFcnJvci5kYXRhID0gZXJyb3IucmVzcG9uc2UuZGF0YTtcbiAgICAgIGVuaGFuY2VkRXJyb3Iub3JpZ2luYWxFcnJvciA9IGVycm9yO1xuICAgICAgXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZW5oYW5jZWRFcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIE5ldHdvcmsgZXJyb3JzLCBzZXJ2ZXIgbm90IHJlc3BvbmRpbmcsIGV0Yy5cbiAgICBpZiAoZXJyb3IucmVxdWVzdCkge1xuICAgICAgY29uc3QgbmV0d29ya0Vycm9yID0gbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uIG9yIHRyeSBhZ2FpbiBsYXRlci4nKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXR3b3JrRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTb21ldGhpbmcgZWxzZSBjYXVzZWQgdGhlIGVycm9yXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuKTtcblxuLy8gQVBJIGNsaWVudCBtZXRob2RzIHdpdGggdHlwZXNcbmNvbnN0IGFwaUNsaWVudCA9IHtcbiAgZ2V0OiBhc3luYyA8VD4odXJsOiBzdHJpbmcsIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBpbnN0YW5jZS5nZXQ8YW55LCBUPih1cmwsIGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEdFVCAke3VybH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcbiAgXG4gIHBvc3Q6IGFzeW5jIDxUPih1cmw6IHN0cmluZywgZGF0YSA9IHt9LCBjb25maWcgPSB7fSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaW5zdGFuY2UucG9zdDxhbnksIFQ+KHVybCwgZGF0YSwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgUE9TVCAke3VybH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcbiAgXG4gIHB1dDogYXN5bmMgPFQ+KHVybDogc3RyaW5nLCBkYXRhID0ge30sIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBpbnN0YW5jZS5wdXQ8YW55LCBUPih1cmwsIGRhdGEsIGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFBVVCAke3VybH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcbiAgXG4gIGRlbGV0ZTogYXN5bmMgPFQ+KHVybDogc3RyaW5nLCBjb25maWcgPSB7fSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaW5zdGFuY2UuZGVsZXRlPGFueSwgVD4odXJsLCBjb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBERUxFVEUgJHt1cmx9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG4gIFxuICBwYXRjaDogYXN5bmMgPFQ+KHVybDogc3RyaW5nLCBkYXRhID0ge30sIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBpbnN0YW5jZS5wYXRjaDxhbnksIFQ+KHVybCwgZGF0YSwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgUEFUQ0ggJHt1cmx9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFwaUNsaWVudDsiXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJpbnN0YW5jZSIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwidGltZW91dCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJBdXRob3JpemF0aW9uIiwiZGF0YSIsIkZvcm1EYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwic3RhdHVzIiwidXJsIiwibWV0aG9kIiwiaXNBdXRoUmVsYXRlZFBhdGgiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiaW5jbHVkZXMiLCJpc0NoZWNraW5nQXV0aCIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwiaHJlZiIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJlbmhhbmNlZEVycm9yIiwib3JpZ2luYWxFcnJvciIsIm5ldHdvcmtFcnJvciIsImFwaUNsaWVudCIsImdldCIsInBvc3QiLCJwdXQiLCJkZWxldGUiLCJwYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/api-client.ts\n"));

/***/ })

});