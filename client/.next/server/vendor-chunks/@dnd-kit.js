"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dnd-kit";
exports.ids = ["vendor-chunks/@dnd-kit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HiddenText: () => (/* binding */ HiddenText),\n/* harmony export */   LiveRegion: () => (/* binding */ LiveRegion),\n/* harmony export */   useAnnouncement: () => (/* binding */ useAnnouncement)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst hiddenStyles = {\n    display: \"none\"\n};\nfunction HiddenText(_ref) {\n    let { id, value } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: hiddenStyles\n    }, value);\n}\nfunction LiveRegion(_ref) {\n    let { id, announcement, ariaLiveType = \"assertive\" } = _ref;\n    // Hide element visually but keep it readable by screen readers\n    const visuallyHidden = {\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        width: 1,\n        height: 1,\n        margin: -1,\n        border: 0,\n        padding: 0,\n        overflow: \"hidden\",\n        clip: \"rect(0 0 0 0)\",\n        clipPath: \"inset(100%)\",\n        whiteSpace: \"nowrap\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: visuallyHidden,\n        role: \"status\",\n        \"aria-live\": ariaLiveType,\n        \"aria-atomic\": true\n    }, announcement);\n}\nfunction useAnnouncement() {\n    const [announcement, setAnnouncement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const announce = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        if (value != null) {\n            setAnnouncement(value);\n        }\n    }, []);\n    return {\n        announce,\n        announcement\n    };\n}\n //# sourceMappingURL=accessibility.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvYWNjZXNzaWJpbGl0eS9kaXN0L2FjY2Vzc2liaWxpdHkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFEO0FBRXJELE1BQU1HLGVBQWU7SUFDbkJDLFNBQVM7QUFDWDtBQUNBLFNBQVNDLFdBQVdDLElBQUk7SUFDdEIsSUFBSSxFQUNGQyxFQUFFLEVBQ0ZDLEtBQUssRUFDTixHQUFHRjtJQUNKLHFCQUFPTiwwREFBbUIsQ0FBQyxPQUFPO1FBQ2hDTyxJQUFJQTtRQUNKRyxPQUFPUDtJQUNULEdBQUdLO0FBQ0w7QUFFQSxTQUFTRyxXQUFXTCxJQUFJO0lBQ3RCLElBQUksRUFDRkMsRUFBRSxFQUNGSyxZQUFZLEVBQ1pDLGVBQWUsV0FBVyxFQUMzQixHQUFHUDtJQUNKLCtEQUErRDtJQUMvRCxNQUFNUSxpQkFBaUI7UUFDckJDLFVBQVU7UUFDVkMsS0FBSztRQUNMQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxRQUFRLENBQUM7UUFDVEMsUUFBUTtRQUNSQyxTQUFTO1FBQ1RDLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLFlBQVk7SUFDZDtJQUNBLHFCQUFPMUIsMERBQW1CLENBQUMsT0FBTztRQUNoQ08sSUFBSUE7UUFDSkcsT0FBT0k7UUFDUGEsTUFBTTtRQUNOLGFBQWFkO1FBQ2IsZUFBZTtJQUNqQixHQUFHRDtBQUNMO0FBRUEsU0FBU2dCO0lBQ1AsTUFBTSxDQUFDaEIsY0FBY2lCLGdCQUFnQixHQUFHNUIsK0NBQVFBLENBQUM7SUFDakQsTUFBTTZCLFdBQVc1QixrREFBV0EsQ0FBQ00sQ0FBQUE7UUFDM0IsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCcUIsZ0JBQWdCckI7UUFDbEI7SUFDRixHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0xzQjtRQUNBbEI7SUFDRjtBQUNGO0FBRW1ELENBQ25ELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWR5Zm9ybXMtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L2FjY2Vzc2liaWxpdHkvZGlzdC9hY2Nlc3NpYmlsaXR5LmVzbS5qcz8zNzYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IGhpZGRlblN0eWxlcyA9IHtcbiAgZGlzcGxheTogJ25vbmUnXG59O1xuZnVuY3Rpb24gSGlkZGVuVGV4dChfcmVmKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgdmFsdWVcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaWQsXG4gICAgc3R5bGU6IGhpZGRlblN0eWxlc1xuICB9LCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIExpdmVSZWdpb24oX3JlZikge1xuICBsZXQge1xuICAgIGlkLFxuICAgIGFubm91bmNlbWVudCxcbiAgICBhcmlhTGl2ZVR5cGUgPSBcImFzc2VydGl2ZVwiXG4gIH0gPSBfcmVmO1xuICAvLyBIaWRlIGVsZW1lbnQgdmlzdWFsbHkgYnV0IGtlZXAgaXQgcmVhZGFibGUgYnkgc2NyZWVuIHJlYWRlcnNcbiAgY29uc3QgdmlzdWFsbHlIaWRkZW4gPSB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIG1hcmdpbjogLTEsXG4gICAgYm9yZGVyOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgICBjbGlwUGF0aDogJ2luc2V0KDEwMCUpJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIHN0eWxlOiB2aXN1YWxseUhpZGRlbixcbiAgICByb2xlOiBcInN0YXR1c1wiLFxuICAgIFwiYXJpYS1saXZlXCI6IGFyaWFMaXZlVHlwZSxcbiAgICBcImFyaWEtYXRvbWljXCI6IHRydWVcbiAgfSwgYW5ub3VuY2VtZW50KTtcbn1cblxuZnVuY3Rpb24gdXNlQW5ub3VuY2VtZW50KCkge1xuICBjb25zdCBbYW5ub3VuY2VtZW50LCBzZXRBbm5vdW5jZW1lbnRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBhbm5vdW5jZSA9IHVzZUNhbGxiYWNrKHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2V0QW5ub3VuY2VtZW50KHZhbHVlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdW5jZSxcbiAgICBhbm5vdW5jZW1lbnRcbiAgfTtcbn1cblxuZXhwb3J0IHsgSGlkZGVuVGV4dCwgTGl2ZVJlZ2lvbiwgdXNlQW5ub3VuY2VtZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NpYmlsaXR5LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJoaWRkZW5TdHlsZXMiLCJkaXNwbGF5IiwiSGlkZGVuVGV4dCIsIl9yZWYiLCJpZCIsInZhbHVlIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiTGl2ZVJlZ2lvbiIsImFubm91bmNlbWVudCIsImFyaWFMaXZlVHlwZSIsInZpc3VhbGx5SGlkZGVuIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJjbGlwIiwiY2xpcFBhdGgiLCJ3aGl0ZVNwYWNlIiwicm9sZSIsInVzZUFubm91bmNlbWVudCIsInNldEFubm91bmNlbWVudCIsImFubm91bmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@dnd-kit/core/dist/core.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dnd-kit/core/dist/core.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoScrollActivator: () => (/* binding */ AutoScrollActivator),\n/* harmony export */   DndContext: () => (/* binding */ DndContext),\n/* harmony export */   DragOverlay: () => (/* binding */ DragOverlay),\n/* harmony export */   KeyboardCode: () => (/* binding */ KeyboardCode),\n/* harmony export */   KeyboardSensor: () => (/* binding */ KeyboardSensor),\n/* harmony export */   MeasuringFrequency: () => (/* binding */ MeasuringFrequency),\n/* harmony export */   MeasuringStrategy: () => (/* binding */ MeasuringStrategy),\n/* harmony export */   MouseSensor: () => (/* binding */ MouseSensor),\n/* harmony export */   PointerSensor: () => (/* binding */ PointerSensor),\n/* harmony export */   TouchSensor: () => (/* binding */ TouchSensor),\n/* harmony export */   TraversalOrder: () => (/* binding */ TraversalOrder),\n/* harmony export */   applyModifiers: () => (/* binding */ applyModifiers),\n/* harmony export */   closestCenter: () => (/* binding */ closestCenter),\n/* harmony export */   closestCorners: () => (/* binding */ closestCorners),\n/* harmony export */   defaultAnnouncements: () => (/* binding */ defaultAnnouncements),\n/* harmony export */   defaultCoordinates: () => (/* binding */ defaultCoordinates),\n/* harmony export */   defaultDropAnimation: () => (/* binding */ defaultDropAnimationConfiguration),\n/* harmony export */   defaultDropAnimationSideEffects: () => (/* binding */ defaultDropAnimationSideEffects),\n/* harmony export */   defaultKeyboardCoordinateGetter: () => (/* binding */ defaultKeyboardCoordinateGetter),\n/* harmony export */   defaultScreenReaderInstructions: () => (/* binding */ defaultScreenReaderInstructions),\n/* harmony export */   getClientRect: () => (/* binding */ getClientRect),\n/* harmony export */   getFirstCollision: () => (/* binding */ getFirstCollision),\n/* harmony export */   getScrollableAncestors: () => (/* binding */ getScrollableAncestors),\n/* harmony export */   pointerWithin: () => (/* binding */ pointerWithin),\n/* harmony export */   rectIntersection: () => (/* binding */ rectIntersection),\n/* harmony export */   useDndContext: () => (/* binding */ useDndContext),\n/* harmony export */   useDndMonitor: () => (/* binding */ useDndMonitor),\n/* harmony export */   useDraggable: () => (/* binding */ useDraggable),\n/* harmony export */   useDroppable: () => (/* binding */ useDroppable),\n/* harmony export */   useSensor: () => (/* binding */ useSensor),\n/* harmony export */   useSensors: () => (/* binding */ useSensors)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n/* harmony import */ var _dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dnd-kit/accessibility */ \"(ssr)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\");\n\n\n\n\nconst DndMonitorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useDndMonitor(listener) {\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DndMonitorContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!registerListener) {\n            throw new Error(\"useDndMonitor must be used within a children of <DndContext>\");\n        }\n        const unsubscribe = registerListener(listener);\n        return unsubscribe;\n    }, [\n        listener,\n        registerListener\n    ]);\n}\nfunction useDndMonitorProvider() {\n    const [listeners] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Set());\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    }, [\n        listeners\n    ]);\n    const dispatch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((_ref)=>{\n        let { type, event } = _ref;\n        listeners.forEach((listener)=>{\n            var _listener$type;\n            return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);\n        });\n    }, [\n        listeners\n    ]);\n    return [\n        dispatch,\n        registerListener\n    ];\n}\nconst defaultScreenReaderInstructions = {\n    draggable: \"\\n    To pick up a draggable item, press the space bar.\\n    While dragging, use the arrow keys to move the item.\\n    Press space again to drop the item in its new position, or press escape to cancel.\\n  \"\n};\nconst defaultAnnouncements = {\n    onDragStart (_ref) {\n        let { active } = _ref;\n        return \"Picked up draggable item \" + active.id + \".\";\n    },\n    onDragOver (_ref2) {\n        let { active, over } = _ref2;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was moved over droppable area \" + over.id + \".\";\n        }\n        return \"Draggable item \" + active.id + \" is no longer over a droppable area.\";\n    },\n    onDragEnd (_ref3) {\n        let { active, over } = _ref3;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was dropped over droppable area \" + over.id;\n        }\n        return \"Draggable item \" + active.id + \" was dropped.\";\n    },\n    onDragCancel (_ref4) {\n        let { active } = _ref4;\n        return \"Dragging was cancelled. Draggable item \" + active.id + \" was dropped.\";\n    }\n};\nfunction Accessibility(_ref) {\n    let { announcements = defaultAnnouncements, container, hiddenTextDescribedById, screenReaderInstructions = defaultScreenReaderInstructions } = _ref;\n    const { announce, announcement } = (0,_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.useAnnouncement)();\n    const liveRegionId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndLiveRegion\");\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n    }, []);\n    useDndMonitor((0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            onDragStart (_ref2) {\n                let { active } = _ref2;\n                announce(announcements.onDragStart({\n                    active\n                }));\n            },\n            onDragMove (_ref3) {\n                let { active, over } = _ref3;\n                if (announcements.onDragMove) {\n                    announce(announcements.onDragMove({\n                        active,\n                        over\n                    }));\n                }\n            },\n            onDragOver (_ref4) {\n                let { active, over } = _ref4;\n                announce(announcements.onDragOver({\n                    active,\n                    over\n                }));\n            },\n            onDragEnd (_ref5) {\n                let { active, over } = _ref5;\n                announce(announcements.onDragEnd({\n                    active,\n                    over\n                }));\n            },\n            onDragCancel (_ref6) {\n                let { active, over } = _ref6;\n                announce(announcements.onDragCancel({\n                    active,\n                    over\n                }));\n            }\n        }), [\n        announce,\n        announcements\n    ]));\n    if (!mounted) {\n        return null;\n    }\n    const markup = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.HiddenText, {\n        id: hiddenTextDescribedById,\n        value: screenReaderInstructions.draggable\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.LiveRegion, {\n        id: liveRegionId,\n        announcement: announcement\n    }));\n    return container ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(markup, container) : markup;\n}\nvar Action;\n(function(Action) {\n    Action[\"DragStart\"] = \"dragStart\";\n    Action[\"DragMove\"] = \"dragMove\";\n    Action[\"DragEnd\"] = \"dragEnd\";\n    Action[\"DragCancel\"] = \"dragCancel\";\n    Action[\"DragOver\"] = \"dragOver\";\n    Action[\"RegisterDroppable\"] = \"registerDroppable\";\n    Action[\"SetDroppableDisabled\"] = \"setDroppableDisabled\";\n    Action[\"UnregisterDroppable\"] = \"unregisterDroppable\";\n})(Action || (Action = {}));\nfunction noop() {}\nfunction useSensor(sensor, options) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sensor,\n            options: options != null ? options : {}\n        }), [\n        sensor,\n        options\n    ]);\n}\nfunction useSensors() {\n    for(var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++){\n        sensors[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            ...sensors\n        ].filter((sensor)=>sensor != null), [\n        ...sensors\n    ]);\n}\nconst defaultCoordinates = /*#__PURE__*/ Object.freeze({\n    x: 0,\n    y: 0\n});\n/**\r\n * Returns the distance between two points\r\n */ function distanceBetween(p1, p2) {\n    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\nfunction getRelativeTransformOrigin(event, rect) {\n    const eventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event);\n    if (!eventCoordinates) {\n        return \"0 0\";\n    }\n    const transformOrigin = {\n        x: (eventCoordinates.x - rect.left) / rect.width * 100,\n        y: (eventCoordinates.y - rect.top) / rect.height * 100\n    };\n    return transformOrigin.x + \"% \" + transformOrigin.y + \"%\";\n}\n/**\r\n * Sort collisions from smallest to greatest value\r\n */ function sortCollisionsAsc(_ref, _ref2) {\n    let { data: { value: a } } = _ref;\n    let { data: { value: b } } = _ref2;\n    return a - b;\n}\n/**\r\n * Sort collisions from greatest to smallest value\r\n */ function sortCollisionsDesc(_ref3, _ref4) {\n    let { data: { value: a } } = _ref3;\n    let { data: { value: b } } = _ref4;\n    return b - a;\n}\n/**\r\n * Returns the coordinates of the corners of a given rectangle:\r\n * [TopLeft {x, y}, TopRight {x, y}, BottomLeft {x, y}, BottomRight {x, y}]\r\n */ function cornersOfRectangle(_ref5) {\n    let { left, top, height, width } = _ref5;\n    return [\n        {\n            x: left,\n            y: top\n        },\n        {\n            x: left + width,\n            y: top\n        },\n        {\n            x: left,\n            y: top + height\n        },\n        {\n            x: left + width,\n            y: top + height\n        }\n    ];\n}\nfunction getFirstCollision(collisions, property) {\n    if (!collisions || collisions.length === 0) {\n        return null;\n    }\n    const [firstCollision] = collisions;\n    return property ? firstCollision[property] : firstCollision;\n}\n/**\r\n * Returns the coordinates of the center of a given ClientRect\r\n */ function centerOfRectangle(rect, left, top) {\n    if (left === void 0) {\n        left = rect.left;\n    }\n    if (top === void 0) {\n        top = rect.top;\n    }\n    return {\n        x: left + rect.width * 0.5,\n        y: top + rect.height * 0.5\n    };\n}\n/**\r\n * Returns the closest rectangles from an array of rectangles to the center of a given\r\n * rectangle.\r\n */ const closestCenter = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: distBetween\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the closest rectangles from an array of rectangles to the corners of\r\n * another rectangle.\r\n */ const closestCorners = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const corners = cornersOfRectangle(collisionRect);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const rectCorners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner, index)=>{\n                return accumulator + distanceBetween(rectCorners[index], corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the intersecting rectangle area between two rectangles\r\n */ function getIntersectionRatio(entry, target) {\n    const top = Math.max(target.top, entry.top);\n    const left = Math.max(target.left, entry.left);\n    const right = Math.min(target.left + target.width, entry.left + entry.width);\n    const bottom = Math.min(target.top + target.height, entry.top + entry.height);\n    const width = right - left;\n    const height = bottom - top;\n    if (left < right && top < bottom) {\n        const targetArea = target.width * target.height;\n        const entryArea = entry.width * entry.height;\n        const intersectionArea = width * height;\n        const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);\n        return Number(intersectionRatio.toFixed(4));\n    } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)\n    return 0;\n}\n/**\r\n * Returns the rectangles that has the greatest intersection area with a given\r\n * rectangle in an array of rectangles.\r\n */ const rectIntersection = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const intersectionRatio = getIntersectionRatio(rect, collisionRect);\n            if (intersectionRatio > 0) {\n                collisions.push({\n                    id,\n                    data: {\n                        droppableContainer,\n                        value: intersectionRatio\n                    }\n                });\n            }\n        }\n    }\n    return collisions.sort(sortCollisionsDesc);\n};\n/**\r\n * Check if a given point is contained within a bounding rectangle\r\n */ function isPointWithinRect(point, rect) {\n    const { top, left, bottom, right } = rect;\n    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;\n}\n/**\r\n * Returns the rectangles that the pointer is hovering over\r\n */ const pointerWithin = (_ref)=>{\n    let { droppableContainers, droppableRects, pointerCoordinates } = _ref;\n    if (!pointerCoordinates) {\n        return [];\n    }\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect && isPointWithinRect(pointerCoordinates, rect)) {\n            /* There may be more than a single rectangle intersecting\r\n       * with the pointer coordinates. In order to sort the\r\n       * colliding rectangles, we measure the distance between\r\n       * the pointer and the corners of the intersecting rectangle\r\n       */ const corners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner)=>{\n                return accumulator + distanceBetween(pointerCoordinates, corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\nfunction adjustScale(transform, rect1, rect2) {\n    return {\n        ...transform,\n        scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,\n        scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1\n    };\n}\nfunction getRectDelta(rect1, rect2) {\n    return rect1 && rect2 ? {\n        x: rect1.left - rect2.left,\n        y: rect1.top - rect2.top\n    } : defaultCoordinates;\n}\nfunction createRectAdjustmentFn(modifier) {\n    return function adjustClientRect(rect) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((acc, adjustment)=>({\n                ...acc,\n                top: acc.top + modifier * adjustment.y,\n                bottom: acc.bottom + modifier * adjustment.y,\n                left: acc.left + modifier * adjustment.x,\n                right: acc.right + modifier * adjustment.x\n            }), {\n            ...rect\n        });\n    };\n}\nconst getAdjustedRect = /*#__PURE__*/ createRectAdjustmentFn(1);\nfunction parseTransform(transform) {\n    if (transform.startsWith(\"matrix3d(\")) {\n        const transformArray = transform.slice(9, -1).split(/, /);\n        return {\n            x: +transformArray[12],\n            y: +transformArray[13],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[5]\n        };\n    } else if (transform.startsWith(\"matrix(\")) {\n        const transformArray = transform.slice(7, -1).split(/, /);\n        return {\n            x: +transformArray[4],\n            y: +transformArray[5],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[3]\n        };\n    }\n    return null;\n}\nfunction inverseTransform(rect, transform, transformOrigin) {\n    const parsedTransform = parseTransform(transform);\n    if (!parsedTransform) {\n        return rect;\n    }\n    const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;\n    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);\n    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(\" \") + 1));\n    const w = scaleX ? rect.width / scaleX : rect.width;\n    const h = scaleY ? rect.height / scaleY : rect.height;\n    return {\n        width: w,\n        height: h,\n        top: y,\n        right: x + w,\n        bottom: y + h,\n        left: x\n    };\n}\nconst defaultOptions = {\n    ignoreTransform: false\n};\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n */ function getClientRect(element, options) {\n    if (options === void 0) {\n        options = defaultOptions;\n    }\n    let rect = element.getBoundingClientRect();\n    if (options.ignoreTransform) {\n        const { transform, transformOrigin } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n        if (transform) {\n            rect = inverseTransform(rect, transform, transformOrigin);\n        }\n    }\n    const { top, left, width, height, bottom, right } = rect;\n    return {\n        top,\n        left,\n        width,\n        height,\n        bottom,\n        right\n    };\n}\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n *\r\n * @remarks\r\n * The ClientRect returned by this method does not take into account transforms\r\n * applied to the element it measures.\r\n *\r\n */ function getTransformAgnosticClientRect(element) {\n    return getClientRect(element, {\n        ignoreTransform: true\n    });\n}\nfunction getWindowClientRect(element) {\n    const width = element.innerWidth;\n    const height = element.innerHeight;\n    return {\n        top: 0,\n        left: 0,\n        right: width,\n        bottom: height,\n        width,\n        height\n    };\n}\nfunction isFixed(node, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n    }\n    return computedStyle.position === \"fixed\";\n}\nfunction isScrollable(element, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n    }\n    const overflowRegex = /(auto|scroll|overlay)/;\n    const properties = [\n        \"overflow\",\n        \"overflowX\",\n        \"overflowY\"\n    ];\n    return properties.some((property)=>{\n        const value = computedStyle[property];\n        return typeof value === \"string\" ? overflowRegex.test(value) : false;\n    });\n}\nfunction getScrollableAncestors(element, limit) {\n    const scrollParents = [];\n    function findScrollableAncestors(node) {\n        if (limit != null && scrollParents.length >= limit) {\n            return scrollParents;\n        }\n        if (!node) {\n            return scrollParents;\n        }\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {\n            scrollParents.push(node.scrollingElement);\n            return scrollParents;\n        }\n        if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(node) || (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isSVGElement)(node)) {\n            return scrollParents;\n        }\n        if (scrollParents.includes(node)) {\n            return scrollParents;\n        }\n        const computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(node);\n        if (node !== element) {\n            if (isScrollable(node, computedStyle)) {\n                scrollParents.push(node);\n            }\n        }\n        if (isFixed(node, computedStyle)) {\n            return scrollParents;\n        }\n        return findScrollableAncestors(node.parentNode);\n    }\n    if (!element) {\n        return scrollParents;\n    }\n    return findScrollableAncestors(element);\n}\nfunction getFirstScrollableAncestor(node) {\n    const [firstScrollableAncestor] = getScrollableAncestors(node, 1);\n    return firstScrollableAncestor != null ? firstScrollableAncestor : null;\n}\nfunction getScrollableElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element;\n    }\n    if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isNode)(element)) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(element) || element === (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(element).scrollingElement) {\n        return window;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(element)) {\n        return element;\n    }\n    return null;\n}\nfunction getScrollXCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollX;\n    }\n    return element.scrollLeft;\n}\nfunction getScrollYCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollY;\n    }\n    return element.scrollTop;\n}\nfunction getScrollCoordinates(element) {\n    return {\n        x: getScrollXCoordinate(element),\n        y: getScrollYCoordinate(element)\n    };\n}\nvar Direction;\n(function(Direction) {\n    Direction[Direction[\"Forward\"] = 1] = \"Forward\";\n    Direction[Direction[\"Backward\"] = -1] = \"Backward\";\n})(Direction || (Direction = {}));\nfunction isDocumentScrollingElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return false;\n    }\n    return element === document.scrollingElement;\n}\nfunction getScrollPosition(scrollingContainer) {\n    const minScroll = {\n        x: 0,\n        y: 0\n    };\n    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {\n        height: window.innerHeight,\n        width: window.innerWidth\n    } : {\n        height: scrollingContainer.clientHeight,\n        width: scrollingContainer.clientWidth\n    };\n    const maxScroll = {\n        x: scrollingContainer.scrollWidth - dimensions.width,\n        y: scrollingContainer.scrollHeight - dimensions.height\n    };\n    const isTop = scrollingContainer.scrollTop <= minScroll.y;\n    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n    return {\n        isTop,\n        isLeft,\n        isBottom,\n        isRight,\n        maxScroll,\n        minScroll\n    };\n}\nconst defaultThreshold = {\n    x: 0.2,\n    y: 0.2\n};\nfunction getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {\n    let { top, left, right, bottom } = _ref;\n    if (acceleration === void 0) {\n        acceleration = 10;\n    }\n    if (thresholdPercentage === void 0) {\n        thresholdPercentage = defaultThreshold;\n    }\n    const { isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollContainer);\n    const direction = {\n        x: 0,\n        y: 0\n    };\n    const speed = {\n        x: 0,\n        y: 0\n    };\n    const threshold = {\n        height: scrollContainerRect.height * thresholdPercentage.y,\n        width: scrollContainerRect.width * thresholdPercentage.x\n    };\n    if (!isTop && top <= scrollContainerRect.top + threshold.height) {\n        // Scroll Up\n        direction.y = Direction.Backward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);\n    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {\n        // Scroll Down\n        direction.y = Direction.Forward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);\n    }\n    if (!isRight && right >= scrollContainerRect.right - threshold.width) {\n        // Scroll Right\n        direction.x = Direction.Forward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);\n    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {\n        // Scroll Left\n        direction.x = Direction.Backward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);\n    }\n    return {\n        direction,\n        speed\n    };\n}\nfunction getScrollElementRect(element) {\n    if (element === document.scrollingElement) {\n        const { innerWidth, innerHeight } = window;\n        return {\n            top: 0,\n            left: 0,\n            right: innerWidth,\n            bottom: innerHeight,\n            width: innerWidth,\n            height: innerHeight\n        };\n    }\n    const { top, left, right, bottom } = element.getBoundingClientRect();\n    return {\n        top,\n        left,\n        right,\n        bottom,\n        width: element.clientWidth,\n        height: element.clientHeight\n    };\n}\nfunction getScrollOffsets(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, getScrollCoordinates(node));\n    }, defaultCoordinates);\n}\nfunction getScrollXOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollXCoordinate(node);\n    }, 0);\n}\nfunction getScrollYOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollYCoordinate(node);\n    }, 0);\n}\nfunction scrollIntoViewIfNeeded(element, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    if (!element) {\n        return;\n    }\n    const { top, left, bottom, right } = measure(element);\n    const firstScrollableAncestor = getFirstScrollableAncestor(element);\n    if (!firstScrollableAncestor) {\n        return;\n    }\n    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {\n        element.scrollIntoView({\n            block: \"center\",\n            inline: \"center\"\n        });\n    }\n}\nconst properties = [\n    [\n        \"x\",\n        [\n            \"left\",\n            \"right\"\n        ],\n        getScrollXOffset\n    ],\n    [\n        \"y\",\n        [\n            \"top\",\n            \"bottom\"\n        ],\n        getScrollYOffset\n    ]\n];\nclass Rect {\n    constructor(rect, element){\n        this.rect = void 0;\n        this.width = void 0;\n        this.height = void 0;\n        this.top = void 0;\n        this.bottom = void 0;\n        this.right = void 0;\n        this.left = void 0;\n        const scrollableAncestors = getScrollableAncestors(element);\n        const scrollOffsets = getScrollOffsets(scrollableAncestors);\n        this.rect = {\n            ...rect\n        };\n        this.width = rect.width;\n        this.height = rect.height;\n        for (const [axis, keys, getScrollOffset] of properties){\n            for (const key of keys){\n                Object.defineProperty(this, key, {\n                    get: ()=>{\n                        const currentOffsets = getScrollOffset(scrollableAncestors);\n                        const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;\n                        return this.rect[key] + scrollOffsetsDeltla;\n                    },\n                    enumerable: true\n                });\n            }\n        }\n        Object.defineProperty(this, \"rect\", {\n            enumerable: false\n        });\n    }\n}\nclass Listeners {\n    constructor(target){\n        this.target = void 0;\n        this.listeners = [];\n        this.removeAll = ()=>{\n            this.listeners.forEach((listener)=>{\n                var _this$target;\n                return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);\n            });\n        };\n        this.target = target;\n    }\n    add(eventName, handler, options) {\n        var _this$target2;\n        (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);\n        this.listeners.push([\n            eventName,\n            handler,\n            options\n        ]);\n    }\n}\nfunction getEventListenerTarget(target) {\n    // If the `event.target` element is removed from the document events will still be targeted\n    // at it, and hence won't always bubble up to the window or document anymore.\n    // If there is any risk of an element being removed while it is being dragged,\n    // the best practice is to attach the event listeners directly to the target.\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n    const { EventTarget } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target);\n    return target instanceof EventTarget ? target : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n}\nfunction hasExceededDistance(delta, measurement) {\n    const dx = Math.abs(delta.x);\n    const dy = Math.abs(delta.y);\n    if (typeof measurement === \"number\") {\n        return Math.sqrt(dx ** 2 + dy ** 2) > measurement;\n    }\n    if (\"x\" in measurement && \"y\" in measurement) {\n        return dx > measurement.x && dy > measurement.y;\n    }\n    if (\"x\" in measurement) {\n        return dx > measurement.x;\n    }\n    if (\"y\" in measurement) {\n        return dy > measurement.y;\n    }\n    return false;\n}\nvar EventName;\n(function(EventName) {\n    EventName[\"Click\"] = \"click\";\n    EventName[\"DragStart\"] = \"dragstart\";\n    EventName[\"Keydown\"] = \"keydown\";\n    EventName[\"ContextMenu\"] = \"contextmenu\";\n    EventName[\"Resize\"] = \"resize\";\n    EventName[\"SelectionChange\"] = \"selectionchange\";\n    EventName[\"VisibilityChange\"] = \"visibilitychange\";\n})(EventName || (EventName = {}));\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nvar KeyboardCode;\n(function(KeyboardCode) {\n    KeyboardCode[\"Space\"] = \"Space\";\n    KeyboardCode[\"Down\"] = \"ArrowDown\";\n    KeyboardCode[\"Right\"] = \"ArrowRight\";\n    KeyboardCode[\"Left\"] = \"ArrowLeft\";\n    KeyboardCode[\"Up\"] = \"ArrowUp\";\n    KeyboardCode[\"Esc\"] = \"Escape\";\n    KeyboardCode[\"Enter\"] = \"Enter\";\n    KeyboardCode[\"Tab\"] = \"Tab\";\n})(KeyboardCode || (KeyboardCode = {}));\nconst defaultKeyboardCodes = {\n    start: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ],\n    cancel: [\n        KeyboardCode.Esc\n    ],\n    end: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter,\n        KeyboardCode.Tab\n    ]\n};\nconst defaultKeyboardCoordinateGetter = (event, _ref)=>{\n    let { currentCoordinates } = _ref;\n    switch(event.code){\n        case KeyboardCode.Right:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x + 25\n            };\n        case KeyboardCode.Left:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x - 25\n            };\n        case KeyboardCode.Down:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y + 25\n            };\n        case KeyboardCode.Up:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y - 25\n            };\n    }\n    return undefined;\n};\nclass KeyboardSensor {\n    constructor(props){\n        this.props = void 0;\n        this.autoScrollEnabled = false;\n        this.referenceCoordinates = void 0;\n        this.listeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        const { event: { target } } = props;\n        this.props = props;\n        this.listeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target));\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.attach();\n    }\n    attach() {\n        this.handleStart();\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        setTimeout(()=>this.listeners.add(EventName.Keydown, this.handleKeyDown));\n    }\n    handleStart() {\n        const { activeNode, onStart } = this.props;\n        const node = activeNode.node.current;\n        if (node) {\n            scrollIntoViewIfNeeded(node);\n        }\n        onStart(defaultCoordinates);\n    }\n    handleKeyDown(event) {\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(event)) {\n            const { active, context, options } = this.props;\n            const { keyboardCodes = defaultKeyboardCodes, coordinateGetter = defaultKeyboardCoordinateGetter, scrollBehavior = \"smooth\" } = options;\n            const { code } = event;\n            if (keyboardCodes.end.includes(code)) {\n                this.handleEnd(event);\n                return;\n            }\n            if (keyboardCodes.cancel.includes(code)) {\n                this.handleCancel(event);\n                return;\n            }\n            const { collisionRect } = context.current;\n            const currentCoordinates = collisionRect ? {\n                x: collisionRect.left,\n                y: collisionRect.top\n            } : defaultCoordinates;\n            if (!this.referenceCoordinates) {\n                this.referenceCoordinates = currentCoordinates;\n            }\n            const newCoordinates = coordinateGetter(event, {\n                active,\n                context: context.current,\n                currentCoordinates\n            });\n            if (newCoordinates) {\n                const coordinatesDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, currentCoordinates);\n                const scrollDelta = {\n                    x: 0,\n                    y: 0\n                };\n                const { scrollableAncestors } = context.current;\n                for (const scrollContainer of scrollableAncestors){\n                    const direction = event.code;\n                    const { isTop, isRight, isLeft, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);\n                    const scrollElementRect = getScrollElementRect(scrollContainer);\n                    const clampedCoordinates = {\n                        x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),\n                        y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))\n                    };\n                    const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;\n                    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;\n                    if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {\n                        const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.y) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                left: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;\n                        } else {\n                            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;\n                        }\n                        if (scrollDelta.x) {\n                            scrollContainer.scrollBy({\n                                left: -scrollDelta.x,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n                        const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.x) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                top: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;\n                        } else {\n                            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;\n                        }\n                        if (scrollDelta.y) {\n                            scrollContainer.scrollBy({\n                                top: -scrollDelta.y,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    }\n                }\n                this.handleMove(event, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, this.referenceCoordinates), scrollDelta));\n            }\n        }\n    }\n    handleMove(event, coordinates) {\n        const { onMove } = this.props;\n        event.preventDefault();\n        onMove(coordinates);\n    }\n    handleEnd(event) {\n        const { onEnd } = this.props;\n        event.preventDefault();\n        this.detach();\n        onEnd();\n    }\n    handleCancel(event) {\n        const { onCancel } = this.props;\n        event.preventDefault();\n        this.detach();\n        onCancel();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll();\n    }\n}\nKeyboardSensor.activators = [\n    {\n        eventName: \"onKeyDown\",\n        handler: (event, _ref, _ref2)=>{\n            let { keyboardCodes = defaultKeyboardCodes, onActivation } = _ref;\n            let { active } = _ref2;\n            const { code } = event.nativeEvent;\n            if (keyboardCodes.start.includes(code)) {\n                const activator = active.activatorNode.current;\n                if (activator && event.target !== activator) {\n                    return false;\n                }\n                event.preventDefault();\n                onActivation == null ? void 0 : onActivation({\n                    event: event.nativeEvent\n                });\n                return true;\n            }\n            return false;\n        }\n    }\n];\nfunction isDistanceConstraint(constraint) {\n    return Boolean(constraint && \"distance\" in constraint);\n}\nfunction isDelayConstraint(constraint) {\n    return Boolean(constraint && \"delay\" in constraint);\n}\nclass AbstractPointerSensor {\n    constructor(props, events, listenerTarget){\n        var _getEventCoordinates;\n        if (listenerTarget === void 0) {\n            listenerTarget = getEventListenerTarget(props.event.target);\n        }\n        this.props = void 0;\n        this.events = void 0;\n        this.autoScrollEnabled = true;\n        this.document = void 0;\n        this.activated = false;\n        this.initialCoordinates = void 0;\n        this.timeoutId = null;\n        this.listeners = void 0;\n        this.documentListeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        this.events = events;\n        const { event } = props;\n        const { target } = event;\n        this.props = props;\n        this.events = events;\n        this.document = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n        this.documentListeners = new Listeners(this.document);\n        this.listeners = new Listeners(listenerTarget);\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.initialCoordinates = (_getEventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates : defaultCoordinates;\n        this.handleStart = this.handleStart.bind(this);\n        this.handleMove = this.handleMove.bind(this);\n        this.handleEnd = this.handleEnd.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.handleKeydown = this.handleKeydown.bind(this);\n        this.removeTextSelection = this.removeTextSelection.bind(this);\n        this.attach();\n    }\n    attach() {\n        const { events, props: { options: { activationConstraint, bypassActivationConstraint } } } = this;\n        this.listeners.add(events.move.name, this.handleMove, {\n            passive: false\n        });\n        this.listeners.add(events.end.name, this.handleEnd);\n        if (events.cancel) {\n            this.listeners.add(events.cancel.name, this.handleCancel);\n        }\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.DragStart, preventDefault);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        this.windowListeners.add(EventName.ContextMenu, preventDefault);\n        this.documentListeners.add(EventName.Keydown, this.handleKeydown);\n        if (activationConstraint) {\n            if (bypassActivationConstraint != null && bypassActivationConstraint({\n                event: this.props.event,\n                activeNode: this.props.activeNode,\n                options: this.props.options\n            })) {\n                return this.handleStart();\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);\n                this.handlePending(activationConstraint);\n                return;\n            }\n            if (isDistanceConstraint(activationConstraint)) {\n                this.handlePending(activationConstraint);\n                return;\n            }\n        }\n        this.handleStart();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners\n        // This is necessary because we listen for `click` and `selection` events on the document\n        setTimeout(this.documentListeners.removeAll, 50);\n        if (this.timeoutId !== null) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    handlePending(constraint, offset) {\n        const { active, onPending } = this.props;\n        onPending(active, constraint, this.initialCoordinates, offset);\n    }\n    handleStart() {\n        const { initialCoordinates } = this;\n        const { onStart } = this.props;\n        if (initialCoordinates) {\n            this.activated = true; // Stop propagation of click events once activation constraints are met\n            this.documentListeners.add(EventName.Click, stopPropagation, {\n                capture: true\n            }); // Remove any text selection from the document\n            this.removeTextSelection(); // Prevent further text selection while dragging\n            this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);\n            onStart(initialCoordinates);\n        }\n    }\n    handleMove(event) {\n        var _getEventCoordinates2;\n        const { activated, initialCoordinates, props } = this;\n        const { onMove, options: { activationConstraint } } = props;\n        if (!initialCoordinates) {\n            return;\n        }\n        const coordinates = (_getEventCoordinates2 = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates2 : defaultCoordinates;\n        const delta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(initialCoordinates, coordinates); // Constraint validation\n        if (!activated && activationConstraint) {\n            if (isDistanceConstraint(activationConstraint)) {\n                if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n                if (hasExceededDistance(delta, activationConstraint.distance)) {\n                    return this.handleStart();\n                }\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                if (hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n            }\n            this.handlePending(activationConstraint, delta);\n            return;\n        }\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        onMove(coordinates);\n    }\n    handleEnd() {\n        const { onAbort, onEnd } = this.props;\n        this.detach();\n        if (!this.activated) {\n            onAbort(this.props.active);\n        }\n        onEnd();\n    }\n    handleCancel() {\n        const { onAbort, onCancel } = this.props;\n        this.detach();\n        if (!this.activated) {\n            onAbort(this.props.active);\n        }\n        onCancel();\n    }\n    handleKeydown(event) {\n        if (event.code === KeyboardCode.Esc) {\n            this.handleCancel();\n        }\n    }\n    removeTextSelection() {\n        var _this$document$getSel;\n        (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();\n    }\n}\nconst events = {\n    cancel: {\n        name: \"pointercancel\"\n    },\n    move: {\n        name: \"pointermove\"\n    },\n    end: {\n        name: \"pointerup\"\n    }\n};\nclass PointerSensor extends AbstractPointerSensor {\n    constructor(props){\n        const { event } = props; // Pointer events stop firing if the target is unmounted while dragging\n        // Therefore we attach listeners to the owner document instead\n        const listenerTarget = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(event.target);\n        super(props, events, listenerTarget);\n    }\n}\nPointerSensor.activators = [\n    {\n        eventName: \"onPointerDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (!event.isPrimary || event.button !== 0) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$1 = {\n    move: {\n        name: \"mousemove\"\n    },\n    end: {\n        name: \"mouseup\"\n    }\n};\nvar MouseButton;\n(function(MouseButton) {\n    MouseButton[MouseButton[\"RightClick\"] = 2] = \"RightClick\";\n})(MouseButton || (MouseButton = {}));\nclass MouseSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$1, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(props.event.target));\n    }\n}\nMouseSensor.activators = [\n    {\n        eventName: \"onMouseDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (event.button === MouseButton.RightClick) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$2 = {\n    cancel: {\n        name: \"touchcancel\"\n    },\n    move: {\n        name: \"touchmove\"\n    },\n    end: {\n        name: \"touchend\"\n    }\n};\nclass TouchSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$2);\n    }\n    static setup() {\n        // Adding a non-capture and non-passive `touchmove` listener in order\n        // to force `event.preventDefault()` calls to work in dynamically added\n        // touchmove event handlers. This is required for iOS Safari.\n        window.addEventListener(events$2.move.name, noop, {\n            capture: false,\n            passive: false\n        });\n        return function teardown() {\n            window.removeEventListener(events$2.move.name, noop);\n        }; // We create a new handler because the teardown function of another sensor\n        // could remove our event listener if we use a referentially equal listener.\n        function noop() {}\n    }\n}\nTouchSensor.activators = [\n    {\n        eventName: \"onTouchStart\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            const { touches } = event;\n            if (touches.length > 1) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nvar AutoScrollActivator;\n(function(AutoScrollActivator) {\n    AutoScrollActivator[AutoScrollActivator[\"Pointer\"] = 0] = \"Pointer\";\n    AutoScrollActivator[AutoScrollActivator[\"DraggableRect\"] = 1] = \"DraggableRect\";\n})(AutoScrollActivator || (AutoScrollActivator = {}));\nvar TraversalOrder;\n(function(TraversalOrder) {\n    TraversalOrder[TraversalOrder[\"TreeOrder\"] = 0] = \"TreeOrder\";\n    TraversalOrder[TraversalOrder[\"ReversedTreeOrder\"] = 1] = \"ReversedTreeOrder\";\n})(TraversalOrder || (TraversalOrder = {}));\nfunction useAutoScroller(_ref) {\n    let { acceleration, activator = AutoScrollActivator.Pointer, canScroll, draggingRect, enabled, interval = 5, order = TraversalOrder.TreeOrder, pointerCoordinates, scrollableAncestors, scrollableAncestorRects, delta, threshold } = _ref;\n    const scrollIntent = useScrollIntent({\n        delta,\n        disabled: !enabled\n    });\n    const [setAutoScrollInterval, clearAutoScrollInterval] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useInterval)();\n    const scrollSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const scrollDirection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        switch(activator){\n            case AutoScrollActivator.Pointer:\n                return pointerCoordinates ? {\n                    top: pointerCoordinates.y,\n                    bottom: pointerCoordinates.y,\n                    left: pointerCoordinates.x,\n                    right: pointerCoordinates.x\n                } : null;\n            case AutoScrollActivator.DraggableRect:\n                return draggingRect;\n        }\n    }, [\n        activator,\n        draggingRect,\n        pointerCoordinates\n    ]);\n    const scrollContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const scrollContainer = scrollContainerRef.current;\n        if (!scrollContainer) {\n            return;\n        }\n        const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;\n        const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;\n        scrollContainer.scrollBy(scrollLeft, scrollTop);\n    }, []);\n    const sortedScrollableAncestors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>order === TraversalOrder.TreeOrder ? [\n            ...scrollableAncestors\n        ].reverse() : scrollableAncestors, [\n        order,\n        scrollableAncestors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!enabled || !scrollableAncestors.length || !rect) {\n            clearAutoScrollInterval();\n            return;\n        }\n        for (const scrollContainer of sortedScrollableAncestors){\n            if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {\n                continue;\n            }\n            const index = scrollableAncestors.indexOf(scrollContainer);\n            const scrollContainerRect = scrollableAncestorRects[index];\n            if (!scrollContainerRect) {\n                continue;\n            }\n            const { direction, speed } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);\n            for (const axis of [\n                \"x\",\n                \"y\"\n            ]){\n                if (!scrollIntent[axis][direction[axis]]) {\n                    speed[axis] = 0;\n                    direction[axis] = 0;\n                }\n            }\n            if (speed.x > 0 || speed.y > 0) {\n                clearAutoScrollInterval();\n                scrollContainerRef.current = scrollContainer;\n                setAutoScrollInterval(autoScroll, interval);\n                scrollSpeed.current = speed;\n                scrollDirection.current = direction;\n                return;\n            }\n        }\n        scrollSpeed.current = {\n            x: 0,\n            y: 0\n        };\n        scrollDirection.current = {\n            x: 0,\n            y: 0\n        };\n        clearAutoScrollInterval();\n    }, [\n        acceleration,\n        autoScroll,\n        canScroll,\n        clearAutoScrollInterval,\n        enabled,\n        interval,\n        JSON.stringify(rect),\n        JSON.stringify(scrollIntent),\n        setAutoScrollInterval,\n        scrollableAncestors,\n        sortedScrollableAncestors,\n        scrollableAncestorRects,\n        JSON.stringify(threshold)\n    ]);\n}\nconst defaultScrollIntent = {\n    x: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    },\n    y: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    }\n};\nfunction useScrollIntent(_ref2) {\n    let { delta, disabled } = _ref2;\n    const previousDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(delta);\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousIntent)=>{\n        if (disabled || !previousDelta || !previousIntent) {\n            // Reset scroll intent tracking when auto-scrolling is disabled\n            return defaultScrollIntent;\n        }\n        const direction = {\n            x: Math.sign(delta.x - previousDelta.x),\n            y: Math.sign(delta.y - previousDelta.y)\n        }; // Keep track of the user intent to scroll in each direction for both axis\n        return {\n            x: {\n                [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,\n                [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1\n            },\n            y: {\n                [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,\n                [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1\n            }\n        };\n    }, [\n        disabled,\n        delta,\n        previousDelta\n    ]);\n}\nfunction useCachedNode(draggableNodes, id) {\n    const draggableNode = id != null ? draggableNodes.get(id) : undefined;\n    const node = draggableNode ? draggableNode.node.current : null;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((cachedNode)=>{\n        var _ref;\n        if (id == null) {\n            return null;\n        } // In some cases, the draggable node can unmount while dragging\n        // This is the case for virtualized lists. In those situations,\n        // we fall back to the last known value for that node.\n        return (_ref = node != null ? node : cachedNode) != null ? _ref : null;\n    }, [\n        node,\n        id\n    ]);\n}\nfunction useCombineActivators(sensors, getSyntheticHandler) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>sensors.reduce((accumulator, sensor)=>{\n            const { sensor: Sensor } = sensor;\n            const sensorActivators = Sensor.activators.map((activator)=>({\n                    eventName: activator.eventName,\n                    handler: getSyntheticHandler(activator.handler, sensor)\n                }));\n            return [\n                ...accumulator,\n                ...sensorActivators\n            ];\n        }, []), [\n        sensors,\n        getSyntheticHandler\n    ]);\n}\nvar MeasuringStrategy;\n(function(MeasuringStrategy) {\n    MeasuringStrategy[MeasuringStrategy[\"Always\"] = 0] = \"Always\";\n    MeasuringStrategy[MeasuringStrategy[\"BeforeDragging\"] = 1] = \"BeforeDragging\";\n    MeasuringStrategy[MeasuringStrategy[\"WhileDragging\"] = 2] = \"WhileDragging\";\n})(MeasuringStrategy || (MeasuringStrategy = {}));\nvar MeasuringFrequency;\n(function(MeasuringFrequency) {\n    MeasuringFrequency[\"Optimized\"] = \"optimized\";\n})(MeasuringFrequency || (MeasuringFrequency = {}));\nconst defaultValue = /*#__PURE__*/ new Map();\nfunction useDroppableMeasuring(containers, _ref) {\n    let { dragging, dependencies, config } = _ref;\n    const [queue, setQueue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { frequency, measure, strategy } = config;\n    const containersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(containers);\n    const disabled = isDisabled();\n    const disabledRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(disabled);\n    const measureDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(ids) {\n        if (ids === void 0) {\n            ids = [];\n        }\n        if (disabledRef.current) {\n            return;\n        }\n        setQueue((value)=>{\n            if (value === null) {\n                return ids;\n            }\n            return value.concat(ids.filter((id)=>!value.includes(id)));\n        });\n    }, [\n        disabledRef\n    ]);\n    const timeoutId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const droppableRects = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (disabled && !dragging) {\n            return defaultValue;\n        }\n        if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {\n            const map = new Map();\n            for (let container of containers){\n                if (!container) {\n                    continue;\n                }\n                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {\n                    // This container does not need to be re-measured\n                    map.set(container.id, container.rect.current);\n                    continue;\n                }\n                const node = container.node.current;\n                const rect = node ? new Rect(measure(node), node) : null;\n                container.rect.current = rect;\n                if (rect) {\n                    map.set(container.id, rect);\n                }\n            }\n            return map;\n        }\n        return previousValue;\n    }, [\n        containers,\n        queue,\n        dragging,\n        disabled,\n        measure\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        containersRef.current = containers;\n    }, [\n        containers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        measureDroppableContainers();\n    }, [\n        dragging,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (queue && queue.length > 0) {\n            setQueue(null);\n        }\n    }, [\n        JSON.stringify(queue)\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled || typeof frequency !== \"number\" || timeoutId.current !== null) {\n            return;\n        }\n        timeoutId.current = setTimeout(()=>{\n            measureDroppableContainers();\n            timeoutId.current = null;\n        }, frequency);\n    }, [\n        frequency,\n        disabled,\n        measureDroppableContainers,\n        ...dependencies\n    ]);\n    return {\n        droppableRects,\n        measureDroppableContainers,\n        measuringScheduled: queue != null\n    };\n    function isDisabled() {\n        switch(strategy){\n            case MeasuringStrategy.Always:\n                return false;\n            case MeasuringStrategy.BeforeDragging:\n                return dragging;\n            default:\n                return !dragging;\n        }\n    }\n}\nfunction useInitialValue(value, computeFn) {\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!value) {\n            return null;\n        }\n        if (previousValue) {\n            return previousValue;\n        }\n        return typeof computeFn === \"function\" ? computeFn(value) : value;\n    }, [\n        computeFn,\n        value\n    ]);\n}\nfunction useInitialRect(node, measure) {\n    return useInitialValue(node, measure);\n}\n/**\r\n * Returns a new MutationObserver instance.\r\n * If `MutationObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useMutationObserver(_ref) {\n    let { callback, disabled } = _ref;\n    const handleMutations = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const mutationObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"undefined\" === \"undefined\" || 0) {\n            return undefined;\n        }\n        const { MutationObserver } = window;\n        return new MutationObserver(handleMutations);\n    }, [\n        handleMutations,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>mutationObserver == null ? void 0 : mutationObserver.disconnect();\n    }, [\n        mutationObserver\n    ]);\n    return mutationObserver;\n}\n/**\r\n * Returns a new ResizeObserver instance bound to the `onResize` callback.\r\n * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useResizeObserver(_ref) {\n    let { callback, disabled } = _ref;\n    const handleResize = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"undefined\" === \"undefined\" || 0) {\n            return undefined;\n        }\n        const { ResizeObserver } = window;\n        return new ResizeObserver(handleResize);\n    }, [\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>resizeObserver == null ? void 0 : resizeObserver.disconnect();\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\nfunction defaultMeasure(element) {\n    return new Rect(getClientRect(element), element);\n}\nfunction useRect(element, measure, fallbackRect) {\n    if (measure === void 0) {\n        measure = defaultMeasure;\n    }\n    const [rect, setRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    function measureRect() {\n        setRect((currentRect)=>{\n            if (!element) {\n                return null;\n            }\n            if (element.isConnected === false) {\n                var _ref;\n                // Fall back to last rect we measured if the element is\n                // no longer connected to the DOM.\n                return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;\n            }\n            const newRect = measure(element);\n            if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {\n                return currentRect;\n            }\n            return newRect;\n        });\n    }\n    const mutationObserver = useMutationObserver({\n        callback (records) {\n            if (!element) {\n                return;\n            }\n            for (const record of records){\n                const { type, target } = record;\n                if (type === \"childList\" && target instanceof HTMLElement && target.contains(element)) {\n                    measureRect();\n                    break;\n                }\n            }\n        }\n    });\n    const resizeObserver = useResizeObserver({\n        callback: measureRect\n    });\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        measureRect();\n        if (element) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(element);\n            mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        }\n    }, [\n        element\n    ]);\n    return rect;\n}\nfunction useRectDelta(rect) {\n    const initialRect = useInitialValue(rect);\n    return getRectDelta(rect, initialRect);\n}\nconst defaultValue$1 = [];\nfunction useScrollableAncestors(node) {\n    const previousNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(node);\n    const ancestors = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!node) {\n            return defaultValue$1;\n        }\n        if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {\n            return previousValue;\n        }\n        return getScrollableAncestors(node);\n    }, [\n        node\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousNode.current = node;\n    }, [\n        node\n    ]);\n    return ancestors;\n}\nfunction useScrollOffsets(elements) {\n    const [scrollCoordinates, setScrollCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const prevElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(elements); // To-do: Throttle the handleScroll callback\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const scrollingElement = getScrollableElement(event.target);\n        if (!scrollingElement) {\n            return;\n        }\n        setScrollCoordinates((scrollCoordinates)=>{\n            if (!scrollCoordinates) {\n                return null;\n            }\n            scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));\n            return new Map(scrollCoordinates);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const previousElements = prevElements.current;\n        if (elements !== previousElements) {\n            cleanup(previousElements);\n            const entries = elements.map((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                if (scrollableElement) {\n                    scrollableElement.addEventListener(\"scroll\", handleScroll, {\n                        passive: true\n                    });\n                    return [\n                        scrollableElement,\n                        getScrollCoordinates(scrollableElement)\n                    ];\n                }\n                return null;\n            }).filter((entry)=>entry != null);\n            setScrollCoordinates(entries.length ? new Map(entries) : null);\n            prevElements.current = elements;\n        }\n        return ()=>{\n            cleanup(elements);\n            cleanup(previousElements);\n        };\n        function cleanup(elements) {\n            elements.forEach((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                scrollableElement == null ? void 0 : scrollableElement.removeEventListener(\"scroll\", handleScroll);\n            });\n        }\n    }, [\n        handleScroll,\n        elements\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (elements.length) {\n            return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates)=>(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);\n        }\n        return defaultCoordinates;\n    }, [\n        elements,\n        scrollCoordinates\n    ]);\n}\nfunction useScrollOffsetsDelta(scrollOffsets, dependencies) {\n    if (dependencies === void 0) {\n        dependencies = [];\n    }\n    const initialScrollOffsets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initialScrollOffsets.current = null;\n    }, dependencies);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const hasScrollOffsets = scrollOffsets !== defaultCoordinates;\n        if (hasScrollOffsets && !initialScrollOffsets.current) {\n            initialScrollOffsets.current = scrollOffsets;\n        }\n        if (!hasScrollOffsets && initialScrollOffsets.current) {\n            initialScrollOffsets.current = null;\n        }\n    }, [\n        scrollOffsets\n    ]);\n    return initialScrollOffsets.current ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;\n}\nfunction useSensorSetup(sensors) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM) {\n            return;\n        }\n        const teardownFns = sensors.map((_ref)=>{\n            let { sensor } = _ref;\n            return sensor.setup == null ? void 0 : sensor.setup();\n        });\n        return ()=>{\n            for (const teardown of teardownFns){\n                teardown == null ? void 0 : teardown();\n            }\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    sensors.map((_ref2)=>{\n        let { sensor } = _ref2;\n        return sensor;\n    }));\n}\nfunction useSyntheticListeners(listeners, id) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return listeners.reduce((acc, _ref)=>{\n            let { eventName, handler } = _ref;\n            acc[eventName] = (event)=>{\n                handler(event, id);\n            };\n            return acc;\n        }, {});\n    }, [\n        listeners,\n        id\n    ]);\n}\nfunction useWindowRect(element) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>element ? getWindowClientRect(element) : null, [\n        element\n    ]);\n}\nconst defaultValue$2 = [];\nfunction useRects(elements, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    const [firstElement] = elements;\n    const windowRect = useWindowRect(firstElement ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(firstElement) : null);\n    const [rects, setRects] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue$2);\n    function measureRects() {\n        setRects(()=>{\n            if (!elements.length) {\n                return defaultValue$2;\n            }\n            return elements.map((element)=>isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));\n        });\n    }\n    const resizeObserver = useResizeObserver({\n        callback: measureRects\n    });\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        resizeObserver == null ? void 0 : resizeObserver.disconnect();\n        measureRects();\n        elements.forEach((element)=>resizeObserver == null ? void 0 : resizeObserver.observe(element));\n    }, [\n        elements\n    ]);\n    return rects;\n}\nfunction getMeasurableNode(node) {\n    if (!node) {\n        return null;\n    }\n    if (node.children.length > 1) {\n        return node;\n    }\n    const firstChild = node.children[0];\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(firstChild) ? firstChild : node;\n}\nfunction useDragOverlayMeasuring(_ref) {\n    let { measure } = _ref;\n    const [rect, setRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((entries)=>{\n        for (const { target } of entries){\n            if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(target)) {\n                setRect((rect)=>{\n                    const newRect = measure(target);\n                    return rect ? {\n                        ...rect,\n                        width: newRect.width,\n                        height: newRect.height\n                    } : newRect;\n                });\n                break;\n            }\n        }\n    }, [\n        measure\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        const node = getMeasurableNode(element);\n        resizeObserver == null ? void 0 : resizeObserver.disconnect();\n        if (node) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(node);\n        }\n        setRect(node ? measure(node) : null);\n    }, [\n        measure,\n        resizeObserver\n    ]);\n    const [nodeRef, setRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            nodeRef,\n            rect,\n            setRef\n        }), [\n        rect,\n        nodeRef,\n        setRef\n    ]);\n}\nconst defaultSensors = [\n    {\n        sensor: PointerSensor,\n        options: {}\n    },\n    {\n        sensor: KeyboardSensor,\n        options: {}\n    }\n];\nconst defaultData = {\n    current: {}\n};\nconst defaultMeasuringConfiguration = {\n    draggable: {\n        measure: getTransformAgnosticClientRect\n    },\n    droppable: {\n        measure: getTransformAgnosticClientRect,\n        strategy: MeasuringStrategy.WhileDragging,\n        frequency: MeasuringFrequency.Optimized\n    },\n    dragOverlay: {\n        measure: getClientRect\n    }\n};\nclass DroppableContainersMap extends Map {\n    get(id) {\n        var _super$get;\n        return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;\n    }\n    toArray() {\n        return Array.from(this.values());\n    }\n    getEnabled() {\n        return this.toArray().filter((_ref)=>{\n            let { disabled } = _ref;\n            return !disabled;\n        });\n    }\n    getNodeFor(id) {\n        var _this$get$node$curren, _this$get;\n        return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;\n    }\n}\nconst defaultPublicContext = {\n    activatorEvent: null,\n    active: null,\n    activeNode: null,\n    activeNodeRect: null,\n    collisions: null,\n    containerNodeRect: null,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    droppableRects: /*#__PURE__*/ new Map(),\n    droppableContainers: /*#__PURE__*/ new DroppableContainersMap(),\n    over: null,\n    dragOverlay: {\n        nodeRef: {\n            current: null\n        },\n        rect: null,\n        setRef: noop\n    },\n    scrollableAncestors: [],\n    scrollableAncestorRects: [],\n    measuringConfiguration: defaultMeasuringConfiguration,\n    measureDroppableContainers: noop,\n    windowRect: null,\n    measuringScheduled: false\n};\nconst defaultInternalContext = {\n    activatorEvent: null,\n    activators: [],\n    active: null,\n    activeNodeRect: null,\n    ariaDescribedById: {\n        draggable: \"\"\n    },\n    dispatch: noop,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    over: null,\n    measureDroppableContainers: noop\n};\nconst InternalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultInternalContext);\nconst PublicContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultPublicContext);\nfunction getInitialState() {\n    return {\n        draggable: {\n            active: null,\n            initialCoordinates: {\n                x: 0,\n                y: 0\n            },\n            nodes: new Map(),\n            translate: {\n                x: 0,\n                y: 0\n            }\n        },\n        droppable: {\n            containers: new DroppableContainersMap()\n        }\n    };\n}\nfunction reducer(state, action) {\n    switch(action.type){\n        case Action.DragStart:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    initialCoordinates: action.initialCoordinates,\n                    active: action.active\n                }\n            };\n        case Action.DragMove:\n            if (state.draggable.active == null) {\n                return state;\n            }\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    translate: {\n                        x: action.coordinates.x - state.draggable.initialCoordinates.x,\n                        y: action.coordinates.y - state.draggable.initialCoordinates.y\n                    }\n                }\n            };\n        case Action.DragEnd:\n        case Action.DragCancel:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    active: null,\n                    initialCoordinates: {\n                        x: 0,\n                        y: 0\n                    },\n                    translate: {\n                        x: 0,\n                        y: 0\n                    }\n                }\n            };\n        case Action.RegisterDroppable:\n            {\n                const { element } = action;\n                const { id } = element;\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, element);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.SetDroppableDisabled:\n            {\n                const { id, key, disabled } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, {\n                    ...element,\n                    disabled\n                });\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.UnregisterDroppable:\n            {\n                const { id, key } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.delete(id);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        default:\n            {\n                return state;\n            }\n    }\n}\nfunction RestoreFocus(_ref) {\n    let { disabled } = _ref;\n    const { active, activatorEvent, draggableNodes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previousActivatorEvent = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(activatorEvent);\n    const previousActiveId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {\n            if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(previousActivatorEvent)) {\n                return;\n            }\n            if (document.activeElement === previousActivatorEvent.target) {\n                // No need to restore focus\n                return;\n            }\n            const draggableNode = draggableNodes.get(previousActiveId);\n            if (!draggableNode) {\n                return;\n            }\n            const { activatorNode, node } = draggableNode;\n            if (!activatorNode.current && !node.current) {\n                return;\n            }\n            requestAnimationFrame(()=>{\n                for (const element of [\n                    activatorNode.current,\n                    node.current\n                ]){\n                    if (!element) {\n                        continue;\n                    }\n                    const focusableNode = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.findFirstFocusableNode)(element);\n                    if (focusableNode) {\n                        focusableNode.focus();\n                        break;\n                    }\n                }\n            });\n        }\n    }, [\n        activatorEvent,\n        disabled,\n        draggableNodes,\n        previousActiveId,\n        previousActivatorEvent\n    ]);\n    return null;\n}\nfunction applyModifiers(modifiers, _ref) {\n    let { transform, ...args } = _ref;\n    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier)=>{\n        return modifier({\n            transform: accumulator,\n            ...args\n        });\n    }, transform) : transform;\n}\nfunction useMeasuringConfiguration(config) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            draggable: {\n                ...defaultMeasuringConfiguration.draggable,\n                ...config == null ? void 0 : config.draggable\n            },\n            droppable: {\n                ...defaultMeasuringConfiguration.droppable,\n                ...config == null ? void 0 : config.droppable\n            },\n            dragOverlay: {\n                ...defaultMeasuringConfiguration.dragOverlay,\n                ...config == null ? void 0 : config.dragOverlay\n            }\n        }), [\n        config == null ? void 0 : config.draggable,\n        config == null ? void 0 : config.droppable,\n        config == null ? void 0 : config.dragOverlay\n    ]);\n}\nfunction useLayoutShiftScrollCompensation(_ref) {\n    let { activeNode, measure, initialRect, config = true } = _ref;\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { x, y } = typeof config === \"boolean\" ? {\n        x: config,\n        y: config\n    } : config;\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        const disabled = !x && !y;\n        if (disabled || !activeNode) {\n            initialized.current = false;\n            return;\n        }\n        if (initialized.current || !initialRect) {\n            // Return early if layout shift scroll compensation was already attempted\n            // or if there is no initialRect to compare to.\n            return;\n        } // Get the most up to date node ref for the active draggable\n        const node = activeNode == null ? void 0 : activeNode.node.current;\n        if (!node || node.isConnected === false) {\n            // Return early if there is no attached node ref or if the node is\n            // disconnected from the document.\n            return;\n        }\n        const rect = measure(node);\n        const rectDelta = getRectDelta(rect, initialRect);\n        if (!x) {\n            rectDelta.x = 0;\n        }\n        if (!y) {\n            rectDelta.y = 0;\n        } // Only perform layout shift scroll compensation once\n        initialized.current = true;\n        if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {\n            const firstScrollableAncestor = getFirstScrollableAncestor(node);\n            if (firstScrollableAncestor) {\n                firstScrollableAncestor.scrollBy({\n                    top: rectDelta.y,\n                    left: rectDelta.x\n                });\n            }\n        }\n    }, [\n        activeNode,\n        x,\n        y,\n        initialRect,\n        measure\n    ]);\n}\nconst ActiveDraggableContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    ...defaultCoordinates,\n    scaleX: 1,\n    scaleY: 1\n});\nvar Status;\n(function(Status) {\n    Status[Status[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    Status[Status[\"Initializing\"] = 1] = \"Initializing\";\n    Status[Status[\"Initialized\"] = 2] = \"Initialized\";\n})(Status || (Status = {}));\nconst DndContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function DndContext(_ref) {\n    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;\n    let { id, accessibility, autoScroll = true, children, sensors = defaultSensors, collisionDetection = rectIntersection, measuring, modifiers, ...props } = _ref;\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, undefined, getInitialState);\n    const [state, dispatch] = store;\n    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Status.Uninitialized);\n    const isInitialized = status === Status.Initialized;\n    const { draggable: { active: activeId, nodes: draggableNodes, translate }, droppable: { containers: droppableContainers } } = state;\n    const node = activeId != null ? draggableNodes.get(activeId) : null;\n    const activeRects = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        initial: null,\n        translated: null\n    });\n    const active = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _node$data;\n        return activeId != null ? {\n            id: activeId,\n            // It's possible for the active node to unmount while dragging\n            data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,\n            rect: activeRects\n        } : null;\n    }, [\n        activeId,\n        node\n    ]);\n    const activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [activeSensor, setActiveSensor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activatorEvent, setActivatorEvent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const latestProps = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(props, Object.values(props));\n    const draggableDescribedById = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndDescribedBy\", id);\n    const enabledDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>droppableContainers.getEnabled(), [\n        droppableContainers\n    ]);\n    const measuringConfiguration = useMeasuringConfiguration(measuring);\n    const { droppableRects, measureDroppableContainers, measuringScheduled } = useDroppableMeasuring(enabledDroppableContainers, {\n        dragging: isInitialized,\n        dependencies: [\n            translate.x,\n            translate.y\n        ],\n        config: measuringConfiguration.droppable\n    });\n    const activeNode = useCachedNode(draggableNodes, activeId);\n    const activationCoordinates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>activatorEvent ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(activatorEvent) : null, [\n        activatorEvent\n    ]);\n    const autoScrollOptions = getAutoScrollerOptions();\n    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);\n    useLayoutShiftScrollCompensation({\n        activeNode: activeId != null ? draggableNodes.get(activeId) : null,\n        config: autoScrollOptions.layoutShiftCompensation,\n        initialRect: initialActiveNodeRect,\n        measure: measuringConfiguration.draggable.measure\n    });\n    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);\n    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);\n    const sensorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activatorEvent: null,\n        active: null,\n        activeNode,\n        collisionRect: null,\n        collisions: null,\n        droppableRects,\n        draggableNodes,\n        draggingNode: null,\n        draggingNodeRect: null,\n        droppableContainers,\n        over: null,\n        scrollableAncestors: [],\n        scrollAdjustedTranslate: null\n    });\n    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);\n    const dragOverlay = useDragOverlayMeasuring({\n        measure: measuringConfiguration.dragOverlay.measure\n    }); // Use the rect of the drag overlay if it is mounted\n    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;\n    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;\n    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node\n    // is only relevant when there is no drag overlay\n    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node\n    const windowRect = useWindowRect(draggingNode ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(draggingNode) : null); // Get scrollable ancestors of the dragging node\n    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);\n    const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers\n    const modifiedTranslate = applyModifiers(modifiers, {\n        transform: {\n            x: translate.x - nodeRectDelta.x,\n            y: translate.y - nodeRectDelta.y,\n            scaleX: 1,\n            scaleY: 1\n        },\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect,\n        over: sensorContext.current.over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        windowRect\n    });\n    const pointerCoordinates = activationCoordinates ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(activationCoordinates, translate) : null;\n    const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated\n    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured\n    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [\n        activeNodeRect\n    ]);\n    const scrollAdjustedTranslate = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, scrollAdjustment);\n    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;\n    const collisions = active && collisionRect ? collisionDetection({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers: enabledDroppableContainers,\n        pointerCoordinates\n    }) : null;\n    const overId = getFirstCollision(collisions, \"id\");\n    const [over, setOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // When there is no drag overlay used, we need to account for the\n    // window scroll delta\n    const appliedTranslate = usesDragOverlay ? modifiedTranslate : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, activeNodeScrollDelta);\n    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);\n    const activeSensorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const instantiateSensor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, _ref2)=>{\n        let { sensor: Sensor, options } = _ref2;\n        if (activeRef.current == null) {\n            return;\n        }\n        const activeNode = draggableNodes.get(activeRef.current);\n        if (!activeNode) {\n            return;\n        }\n        const activatorEvent = event.nativeEvent;\n        const sensorInstance = new Sensor({\n            active: activeRef.current,\n            activeNode,\n            event: activatorEvent,\n            options,\n            // Sensors need to be instantiated with refs for arguments that change over time\n            // otherwise they are frozen in time with the stale arguments\n            context: sensorContext,\n            onAbort (id) {\n                const draggableNode = draggableNodes.get(id);\n                if (!draggableNode) {\n                    return;\n                }\n                const { onDragAbort } = latestProps.current;\n                const event = {\n                    id\n                };\n                onDragAbort == null ? void 0 : onDragAbort(event);\n                dispatchMonitorEvent({\n                    type: \"onDragAbort\",\n                    event\n                });\n            },\n            onPending (id, constraint, initialCoordinates, offset) {\n                const draggableNode = draggableNodes.get(id);\n                if (!draggableNode) {\n                    return;\n                }\n                const { onDragPending } = latestProps.current;\n                const event = {\n                    id,\n                    constraint,\n                    initialCoordinates,\n                    offset\n                };\n                onDragPending == null ? void 0 : onDragPending(event);\n                dispatchMonitorEvent({\n                    type: \"onDragPending\",\n                    event\n                });\n            },\n            onStart (initialCoordinates) {\n                const id = activeRef.current;\n                if (id == null) {\n                    return;\n                }\n                const draggableNode = draggableNodes.get(id);\n                if (!draggableNode) {\n                    return;\n                }\n                const { onDragStart } = latestProps.current;\n                const event = {\n                    activatorEvent,\n                    active: {\n                        id,\n                        data: draggableNode.data,\n                        rect: activeRects\n                    }\n                };\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    onDragStart == null ? void 0 : onDragStart(event);\n                    setStatus(Status.Initializing);\n                    dispatch({\n                        type: Action.DragStart,\n                        initialCoordinates,\n                        active: id\n                    });\n                    dispatchMonitorEvent({\n                        type: \"onDragStart\",\n                        event\n                    });\n                    setActiveSensor(activeSensorRef.current);\n                    setActivatorEvent(activatorEvent);\n                });\n            },\n            onMove (coordinates) {\n                dispatch({\n                    type: Action.DragMove,\n                    coordinates\n                });\n            },\n            onEnd: createHandler(Action.DragEnd),\n            onCancel: createHandler(Action.DragCancel)\n        });\n        activeSensorRef.current = sensorInstance;\n        function createHandler(type) {\n            return async function handler() {\n                const { active, collisions, over, scrollAdjustedTranslate } = sensorContext.current;\n                let event = null;\n                if (active && scrollAdjustedTranslate) {\n                    const { cancelDrop } = latestProps.current;\n                    event = {\n                        activatorEvent,\n                        active: active,\n                        collisions,\n                        delta: scrollAdjustedTranslate,\n                        over\n                    };\n                    if (type === Action.DragEnd && typeof cancelDrop === \"function\") {\n                        const shouldCancel = await Promise.resolve(cancelDrop(event));\n                        if (shouldCancel) {\n                            type = Action.DragCancel;\n                        }\n                    }\n                }\n                activeRef.current = null;\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    dispatch({\n                        type\n                    });\n                    setStatus(Status.Uninitialized);\n                    setOver(null);\n                    setActiveSensor(null);\n                    setActivatorEvent(null);\n                    activeSensorRef.current = null;\n                    const eventName = type === Action.DragEnd ? \"onDragEnd\" : \"onDragCancel\";\n                    if (event) {\n                        const handler = latestProps.current[eventName];\n                        handler == null ? void 0 : handler(event);\n                        dispatchMonitorEvent({\n                            type: eventName,\n                            event\n                        });\n                    }\n                });\n            };\n        }\n    }, [\n        draggableNodes\n    ]);\n    const bindActivatorToSensorInstantiator = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handler, sensor)=>{\n        return (event, active)=>{\n            const nativeEvent = event.nativeEvent;\n            const activeDraggableNode = draggableNodes.get(active);\n            if (activeRef.current !== null || // No active draggable\n            !activeDraggableNode || // Event has already been captured\n            nativeEvent.dndKit || nativeEvent.defaultPrevented) {\n                return;\n            }\n            const activationContext = {\n                active: activeDraggableNode\n            };\n            const shouldActivate = handler(event, sensor.options, activationContext);\n            if (shouldActivate === true) {\n                nativeEvent.dndKit = {\n                    capturedBy: sensor.sensor\n                };\n                activeRef.current = active;\n                instantiateSensor(event, sensor);\n            }\n        };\n    }, [\n        draggableNodes,\n        instantiateSensor\n    ]);\n    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);\n    useSensorSetup(sensors);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (activeNodeRect && status === Status.Initializing) {\n            setStatus(Status.Initialized);\n        }\n    }, [\n        activeNodeRect,\n        status\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { onDragMove } = latestProps.current;\n        const { active, activatorEvent, collisions, over } = sensorContext.current;\n        if (!active || !activatorEvent) {\n            return;\n        }\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            onDragMove == null ? void 0 : onDragMove(event);\n            dispatchMonitorEvent({\n                type: \"onDragMove\",\n                event\n            });\n        });\n    }, [\n        scrollAdjustedTranslate.x,\n        scrollAdjustedTranslate.y\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { active, activatorEvent, collisions, droppableContainers, scrollAdjustedTranslate } = sensorContext.current;\n        if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {\n            return;\n        }\n        const { onDragOver } = latestProps.current;\n        const overContainer = droppableContainers.get(overId);\n        const over = overContainer && overContainer.rect.current ? {\n            id: overContainer.id,\n            rect: overContainer.rect.current,\n            data: overContainer.data,\n            disabled: overContainer.disabled\n        } : null;\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setOver(over);\n            onDragOver == null ? void 0 : onDragOver(event);\n            dispatchMonitorEvent({\n                type: \"onDragOver\",\n                event\n            });\n        });\n    }, [\n        overId\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        sensorContext.current = {\n            activatorEvent,\n            active,\n            activeNode,\n            collisionRect,\n            collisions,\n            droppableRects,\n            draggableNodes,\n            draggingNode,\n            draggingNodeRect,\n            droppableContainers,\n            over,\n            scrollableAncestors,\n            scrollAdjustedTranslate\n        };\n        activeRects.current = {\n            initial: draggingNodeRect,\n            translated: collisionRect\n        };\n    }, [\n        active,\n        activeNode,\n        collisions,\n        collisionRect,\n        draggableNodes,\n        draggingNode,\n        draggingNodeRect,\n        droppableRects,\n        droppableContainers,\n        over,\n        scrollableAncestors,\n        scrollAdjustedTranslate\n    ]);\n    useAutoScroller({\n        ...autoScrollOptions,\n        delta: translate,\n        draggingRect: collisionRect,\n        pointerCoordinates,\n        scrollableAncestors,\n        scrollableAncestorRects\n    });\n    const publicContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            active,\n            activeNode,\n            activeNodeRect,\n            activatorEvent,\n            collisions,\n            containerNodeRect,\n            dragOverlay,\n            draggableNodes,\n            droppableContainers,\n            droppableRects,\n            over,\n            measureDroppableContainers,\n            scrollableAncestors,\n            scrollableAncestorRects,\n            measuringConfiguration,\n            measuringScheduled,\n            windowRect\n        };\n        return context;\n    }, [\n        active,\n        activeNode,\n        activeNodeRect,\n        activatorEvent,\n        collisions,\n        containerNodeRect,\n        dragOverlay,\n        draggableNodes,\n        droppableContainers,\n        droppableRects,\n        over,\n        measureDroppableContainers,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        measuringConfiguration,\n        measuringScheduled,\n        windowRect\n    ]);\n    const internalContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            activatorEvent,\n            activators,\n            active,\n            activeNodeRect,\n            ariaDescribedById: {\n                draggable: draggableDescribedById\n            },\n            dispatch,\n            draggableNodes,\n            over,\n            measureDroppableContainers\n        };\n        return context;\n    }, [\n        activatorEvent,\n        activators,\n        active,\n        activeNodeRect,\n        dispatch,\n        draggableDescribedById,\n        draggableNodes,\n        over,\n        measureDroppableContainers\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DndMonitorContext.Provider, {\n        value: registerMonitorListener\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: internalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PublicContext.Provider, {\n        value: publicContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: transform\n    }, children)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RestoreFocus, {\n        disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Accessibility, {\n        ...accessibility,\n        hiddenTextDescribedById: draggableDescribedById\n    }));\n    function getAutoScrollerOptions() {\n        const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;\n        const autoScrollGloballyDisabled = typeof autoScroll === \"object\" ? autoScroll.enabled === false : autoScroll === false;\n        const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;\n        if (typeof autoScroll === \"object\") {\n            return {\n                ...autoScroll,\n                enabled\n            };\n        }\n        return {\n            enabled\n        };\n    }\n});\nconst NullContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst defaultRole = \"button\";\nconst ID_PREFIX = \"Draggable\";\nfunction useDraggable(_ref) {\n    let { id, data, disabled = false, attributes } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX);\n    const { activators, activatorEvent, active, activeNodeRect, ariaDescribedById, draggableNodes, over } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const { role = defaultRole, roleDescription = \"draggable\", tabIndex = 0 } = attributes != null ? attributes : {};\n    const isDragging = (active == null ? void 0 : active.id) === id;\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(isDragging ? ActiveDraggableContext : NullContext);\n    const [node, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const [activatorNode, setActivatorNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const listeners = useSyntheticListeners(activators, id);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        draggableNodes.set(id, {\n            id,\n            key,\n            node,\n            activatorNode,\n            data: dataRef\n        });\n        return ()=>{\n            const node = draggableNodes.get(id);\n            if (node && node.key === key) {\n                draggableNodes.delete(id);\n            }\n        };\n    }, [\n        draggableNodes,\n        id\n    ]);\n    const memoizedAttributes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            role,\n            tabIndex,\n            \"aria-disabled\": disabled,\n            \"aria-pressed\": isDragging && role === defaultRole ? true : undefined,\n            \"aria-roledescription\": roleDescription,\n            \"aria-describedby\": ariaDescribedById.draggable\n        }), [\n        disabled,\n        role,\n        tabIndex,\n        isDragging,\n        roleDescription,\n        ariaDescribedById.draggable\n    ]);\n    return {\n        active,\n        activatorEvent,\n        activeNodeRect,\n        attributes: memoizedAttributes,\n        isDragging,\n        listeners: disabled ? undefined : listeners,\n        node,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        transform\n    };\n}\nfunction useDndContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PublicContext);\n}\nconst ID_PREFIX$1 = \"Droppable\";\nconst defaultResizeObserverConfig = {\n    timeout: 25\n};\nfunction useDroppable(_ref) {\n    let { data, disabled = false, id, resizeObserverConfig } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX$1);\n    const { active, dispatch, over, measureDroppableContainers } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        disabled\n    });\n    const resizeObserverConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const callbackId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { disabled: resizeObserverDisabled, updateMeasurementsFor, timeout: resizeObserverTimeout } = {\n        ...defaultResizeObserverConfig,\n        ...resizeObserverConfig\n    };\n    const ids = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(updateMeasurementsFor != null ? updateMeasurementsFor : id);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!resizeObserverConnected.current) {\n            // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,\n            // assuming the element is rendered and displayed.\n            resizeObserverConnected.current = true;\n            return;\n        }\n        if (callbackId.current != null) {\n            clearTimeout(callbackId.current);\n        }\n        callbackId.current = setTimeout(()=>{\n            measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [\n                ids.current\n            ]);\n            callbackId.current = null;\n        }, resizeObserverTimeout);\n    }, [\n        resizeObserverTimeout\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize,\n        disabled: resizeObserverDisabled || !active\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newElement, previousElement)=>{\n        if (!resizeObserver) {\n            return;\n        }\n        if (previousElement) {\n            resizeObserver.unobserve(previousElement);\n            resizeObserverConnected.current = false;\n        }\n        if (newElement) {\n            resizeObserver.observe(newElement);\n        }\n    }, [\n        resizeObserver\n    ]);\n    const [nodeRef, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!resizeObserver || !nodeRef.current) {\n            return;\n        }\n        resizeObserver.disconnect();\n        resizeObserverConnected.current = false;\n        resizeObserver.observe(nodeRef.current);\n    }, [\n        nodeRef,\n        resizeObserver\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        dispatch({\n            type: Action.RegisterDroppable,\n            element: {\n                id,\n                key,\n                disabled,\n                node: nodeRef,\n                rect,\n                data: dataRef\n            }\n        });\n        return ()=>dispatch({\n                type: Action.UnregisterDroppable,\n                key,\n                id\n            });\n    }, [\n        id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled !== previous.current.disabled) {\n            dispatch({\n                type: Action.SetDroppableDisabled,\n                id,\n                key,\n                disabled\n            });\n            previous.current.disabled = disabled;\n        }\n    }, [\n        id,\n        key,\n        disabled,\n        dispatch\n    ]);\n    return {\n        active,\n        rect,\n        isOver: (over == null ? void 0 : over.id) === id,\n        node: nodeRef,\n        over,\n        setNodeRef\n    };\n}\nfunction AnimationManager(_ref) {\n    let { animation, children } = _ref;\n    const [clonedChildren, setClonedChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousChildren = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(children);\n    if (!children && !clonedChildren && previousChildren) {\n        setClonedChildren(previousChildren);\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!element) {\n            return;\n        }\n        const key = clonedChildren == null ? void 0 : clonedChildren.key;\n        const id = clonedChildren == null ? void 0 : clonedChildren.props.id;\n        if (key == null || id == null) {\n            setClonedChildren(null);\n            return;\n        }\n        Promise.resolve(animation(id, element)).then(()=>{\n            setClonedChildren(null);\n        });\n    }, [\n        animation,\n        clonedChildren,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children, clonedChildren ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(clonedChildren, {\n        ref: setElement\n    }) : null);\n}\nconst defaultTransform = {\n    x: 0,\n    y: 0,\n    scaleX: 1,\n    scaleY: 1\n};\nfunction NullifiedContextProvider(_ref) {\n    let { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: defaultInternalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: defaultTransform\n    }, children));\n}\nconst baseStyles = {\n    position: \"fixed\",\n    touchAction: \"none\"\n};\nconst defaultTransition = (activatorEvent)=>{\n    const isKeyboardActivator = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent);\n    return isKeyboardActivator ? \"transform 250ms ease\" : undefined;\n};\nconst PositionedOverlay = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((_ref, ref)=>{\n    let { as, activatorEvent, adjustScale, children, className, rect, style, transform, transition = defaultTransition } = _ref;\n    if (!rect) {\n        return null;\n    }\n    const scaleAdjustedTransform = adjustScale ? transform : {\n        ...transform,\n        scaleX: 1,\n        scaleY: 1\n    };\n    const styles = {\n        ...baseStyles,\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        left: rect.left,\n        transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(scaleAdjustedTransform),\n        transformOrigin: adjustScale && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : undefined,\n        transition: typeof transition === \"function\" ? transition(activatorEvent) : transition,\n        ...style\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(as, {\n        className,\n        style: styles,\n        ref\n    }, children);\n});\nconst defaultDropAnimationSideEffects = (options)=>(_ref)=>{\n        let { active, dragOverlay } = _ref;\n        const originalStyles = {};\n        const { styles, className } = options;\n        if (styles != null && styles.active) {\n            for (const [key, value] of Object.entries(styles.active)){\n                if (value === undefined) {\n                    continue;\n                }\n                originalStyles[key] = active.node.style.getPropertyValue(key);\n                active.node.style.setProperty(key, value);\n            }\n        }\n        if (styles != null && styles.dragOverlay) {\n            for (const [key, value] of Object.entries(styles.dragOverlay)){\n                if (value === undefined) {\n                    continue;\n                }\n                dragOverlay.node.style.setProperty(key, value);\n            }\n        }\n        if (className != null && className.active) {\n            active.node.classList.add(className.active);\n        }\n        if (className != null && className.dragOverlay) {\n            dragOverlay.node.classList.add(className.dragOverlay);\n        }\n        return function cleanup() {\n            for (const [key, value] of Object.entries(originalStyles)){\n                active.node.style.setProperty(key, value);\n            }\n            if (className != null && className.active) {\n                active.node.classList.remove(className.active);\n            }\n        };\n    };\nconst defaultKeyframeResolver = (_ref2)=>{\n    let { transform: { initial, final } } = _ref2;\n    return [\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(initial)\n        },\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(final)\n        }\n    ];\n};\nconst defaultDropAnimationConfiguration = {\n    duration: 250,\n    easing: \"ease\",\n    keyframes: defaultKeyframeResolver,\n    sideEffects: /*#__PURE__*/ defaultDropAnimationSideEffects({\n        styles: {\n            active: {\n                opacity: \"0\"\n            }\n        }\n    })\n};\nfunction useDropAnimation(_ref3) {\n    let { config, draggableNodes, droppableContainers, measuringConfiguration } = _ref3;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)((id, node)=>{\n        if (config === null) {\n            return;\n        }\n        const activeDraggable = draggableNodes.get(id);\n        if (!activeDraggable) {\n            return;\n        }\n        const activeNode = activeDraggable.node.current;\n        if (!activeNode) {\n            return;\n        }\n        const measurableNode = getMeasurableNode(node);\n        if (!measurableNode) {\n            return;\n        }\n        const { transform } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n        const parsedTransform = parseTransform(transform);\n        if (!parsedTransform) {\n            return;\n        }\n        const animation = typeof config === \"function\" ? config : createDefaultDropAnimation(config);\n        scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);\n        return animation({\n            active: {\n                id,\n                data: activeDraggable.data,\n                node: activeNode,\n                rect: measuringConfiguration.draggable.measure(activeNode)\n            },\n            draggableNodes,\n            dragOverlay: {\n                node,\n                rect: measuringConfiguration.dragOverlay.measure(measurableNode)\n            },\n            droppableContainers,\n            measuringConfiguration,\n            transform: parsedTransform\n        });\n    });\n}\nfunction createDefaultDropAnimation(options) {\n    const { duration, easing, sideEffects, keyframes } = {\n        ...defaultDropAnimationConfiguration,\n        ...options\n    };\n    return (_ref4)=>{\n        let { active, dragOverlay, transform, ...rest } = _ref4;\n        if (!duration) {\n            // Do not animate if animation duration is zero.\n            return;\n        }\n        const delta = {\n            x: dragOverlay.rect.left - active.rect.left,\n            y: dragOverlay.rect.top - active.rect.top\n        };\n        const scale = {\n            scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,\n            scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1\n        };\n        const finalTransform = {\n            x: transform.x - delta.x,\n            y: transform.y - delta.y,\n            ...scale\n        };\n        const animationKeyframes = keyframes({\n            ...rest,\n            active,\n            dragOverlay,\n            transform: {\n                initial: transform,\n                final: finalTransform\n            }\n        });\n        const [firstKeyframe] = animationKeyframes;\n        const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];\n        if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {\n            // The start and end keyframes are the same, infer that there is no animation needed.\n            return;\n        }\n        const cleanup = sideEffects == null ? void 0 : sideEffects({\n            active,\n            dragOverlay,\n            ...rest\n        });\n        const animation = dragOverlay.node.animate(animationKeyframes, {\n            duration,\n            easing,\n            fill: \"forwards\"\n        });\n        return new Promise((resolve)=>{\n            animation.onfinish = ()=>{\n                cleanup == null ? void 0 : cleanup();\n                resolve();\n            };\n        });\n    };\n}\nlet key = 0;\nfunction useKey(id) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (id == null) {\n            return;\n        }\n        key++;\n        return key;\n    }, [\n        id\n    ]);\n}\nconst DragOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo((_ref)=>{\n    let { adjustScale = false, children, dropAnimation: dropAnimationConfig, style, transition, modifiers, wrapperElement = \"div\", className, zIndex = 999 } = _ref;\n    const { activatorEvent, active, activeNodeRect, containerNodeRect, draggableNodes, droppableContainers, dragOverlay, over, measuringConfiguration, scrollableAncestors, scrollableAncestorRects, windowRect } = useDndContext();\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ActiveDraggableContext);\n    const key = useKey(active == null ? void 0 : active.id);\n    const modifiedTransform = applyModifiers(modifiers, {\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect: dragOverlay.rect,\n        over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        transform,\n        windowRect\n    });\n    const initialRect = useInitialValue(activeNodeRect);\n    const dropAnimation = useDropAnimation({\n        config: dropAnimationConfig,\n        draggableNodes,\n        droppableContainers,\n        measuringConfiguration\n    }); // We need to wait for the active node to be measured before connecting the drag overlay ref\n    // otherwise collisions can be computed against a mispositioned drag overlay\n    const ref = initialRect ? dragOverlay.setRef : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NullifiedContextProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimationManager, {\n        animation: dropAnimation\n    }, active && key ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PositionedOverlay, {\n        key: key,\n        id: active.id,\n        ref: ref,\n        as: wrapperElement,\n        activatorEvent: activatorEvent,\n        adjustScale: adjustScale,\n        className: className,\n        transition: transition,\n        rect: initialRect,\n        style: {\n            zIndex,\n            ...style\n        },\n        transform: modifiedTransform\n    }, children) : null));\n});\n //# sourceMappingURL=core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvY29yZS9kaXN0L2NvcmUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0o7QUFDdEY7QUFDNFE7QUFDN1A7QUFFakYsTUFBTXVDLG9CQUFvQixXQUFXLEdBQUV0QyxvREFBYUEsQ0FBQztBQUVyRCxTQUFTdUMsY0FBY0MsUUFBUTtJQUM3QixNQUFNQyxtQkFBbUJ4QyxpREFBVUEsQ0FBQ3FDO0lBQ3BDcEMsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUN1QyxrQkFBa0I7WUFDckIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTUMsY0FBY0YsaUJBQWlCRDtRQUNyQyxPQUFPRztJQUNULEdBQUc7UUFBQ0g7UUFBVUM7S0FBaUI7QUFDakM7QUFFQSxTQUFTRztJQUNQLE1BQU0sQ0FBQ0MsVUFBVSxHQUFHMUMsK0NBQVFBLENBQUMsSUFBTSxJQUFJMkM7SUFDdkMsTUFBTUwsbUJBQW1CckMsa0RBQVdBLENBQUNvQyxDQUFBQTtRQUNuQ0ssVUFBVXRCLEdBQUcsQ0FBQ2lCO1FBQ2QsT0FBTyxJQUFNSyxVQUFVRSxNQUFNLENBQUNQO0lBQ2hDLEdBQUc7UUFBQ0s7S0FBVTtJQUNkLE1BQU1HLFdBQVc1QyxrREFBV0EsQ0FBQzZDLENBQUFBO1FBQzNCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxLQUFLLEVBQ04sR0FBR0Y7UUFDSkosVUFBVU8sT0FBTyxDQUFDWixDQUFBQTtZQUNoQixJQUFJYTtZQUVKLE9BQU8sQ0FBQ0EsaUJBQWlCYixRQUFRLENBQUNVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUcsZUFBZUMsSUFBSSxDQUFDZCxVQUFVVztRQUM1RjtJQUNGLEdBQUc7UUFBQ047S0FBVTtJQUNkLE9BQU87UUFBQ0c7UUFBVVA7S0FBaUI7QUFDckM7QUFFQSxNQUFNYyxrQ0FBa0M7SUFDdENDLFdBQVc7QUFDYjtBQUNBLE1BQU1DLHVCQUF1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QUFJQSxPQUFPQyxFQUFFO0lBQ3RELE1BQU0rcUIsb0JBQW9CeEssZUFBZUMsV0FBVztRQUNsRDVCO1FBQ0E3ZTtRQUNBOGU7UUFDQUM7UUFDQXNFLGtCQUFrQmpGLFlBQVlqYixJQUFJO1FBQ2xDL0M7UUFDQXVqQixpQkFBaUJ2RixZQUFZamIsSUFBSTtRQUNqQ3FKO1FBQ0E4SjtRQUNBM1A7UUFDQXdXO0lBQ0Y7SUFDQSxNQUFNM0IsY0FBYzlCLGdCQUFnQm9GO0lBQ3BDLE1BQU04TCxnQkFBZ0JmLGlCQUFpQjtRQUNyQ25SLFFBQVFtUztRQUNSblQ7UUFDQWxUO1FBQ0F3YTtJQUNGLElBQUksNEZBQTRGO0lBQ2hHLDRFQUE0RTtJQUU1RSxNQUFNK0ksTUFBTXZNLGNBQWM0QyxZQUFZUCxNQUFNLEdBQUdoTztJQUMvQyxxQkFBT3pULDBEQUFtQixDQUFDNnJCLDBCQUEwQixvQkFBTTdyQiwwREFBbUIsQ0FBQ29yQixrQkFBa0I7UUFDL0ZDLFdBQVdtRDtJQUNiLEdBQUc1cUIsVUFBVXNOLG9CQUFNbFIsMERBQW1CLENBQUNrc0IsbUJBQW1CO1FBQ3hEaGIsS0FBS0E7UUFDTHJOLElBQUlELE9BQU9DLEVBQUU7UUFDYjhuQixLQUFLQTtRQUNMUSxJQUFJdUM7UUFDSmpNLGdCQUFnQkE7UUFDaEJuWSxhQUFhQTtRQUNiOGhCLFdBQVdBO1FBQ1hFLFlBQVlBO1FBQ1p2bEIsTUFBTXFZO1FBQ05pTixPQUFPO1lBQ0xzQztZQUNBLEdBQUd0QyxLQUFLO1FBQ1Y7UUFDQTloQixXQUFXcWtCO0lBQ2IsR0FBR3hOLFlBQVk7QUFDakI7QUFFeWxCLENBQ3psQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFkeWZvcm1zLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9jb3JlL2Rpc3QvY29yZS5lc20uanM/OTgxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiwgbWVtbywgdXNlUmVkdWNlciwgY2xvbmVFbGVtZW50LCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyB1c2VVbmlxdWVJZCwgZ2V0RXZlbnRDb29yZGluYXRlcywgZ2V0V2luZG93LCBpc0RvY3VtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NWR0VsZW1lbnQsIGNhblVzZURPTSwgaXNXaW5kb3csIGlzTm9kZSwgZ2V0T3duZXJEb2N1bWVudCwgYWRkLCBpc0tleWJvYXJkRXZlbnQsIHN1YnRyYWN0LCB1c2VMYXp5TWVtbywgdXNlSW50ZXJ2YWwsIHVzZVByZXZpb3VzLCB1c2VMYXRlc3RWYWx1ZSwgdXNlRXZlbnQsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHVzZU5vZGVSZWYsIGZpbmRGaXJzdEZvY3VzYWJsZU5vZGUsIENTUyB9IGZyb20gJ0BkbmQta2l0L3V0aWxpdGllcyc7XG5pbXBvcnQgeyB1c2VBbm5vdW5jZW1lbnQsIEhpZGRlblRleHQsIExpdmVSZWdpb24gfSBmcm9tICdAZG5kLWtpdC9hY2Nlc3NpYmlsaXR5JztcblxuY29uc3QgRG5kTW9uaXRvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gdXNlRG5kTW9uaXRvcihsaXN0ZW5lcikge1xuICBjb25zdCByZWdpc3Rlckxpc3RlbmVyID0gdXNlQ29udGV4dChEbmRNb25pdG9yQ29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyZWdpc3Rlckxpc3RlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZURuZE1vbml0b3IgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGNoaWxkcmVuIG9mIDxEbmRDb250ZXh0PicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbbGlzdGVuZXIsIHJlZ2lzdGVyTGlzdGVuZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlRG5kTW9uaXRvclByb3ZpZGVyKCkge1xuICBjb25zdCBbbGlzdGVuZXJzXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBTZXQoKSk7XG4gIGNvbnN0IHJlZ2lzdGVyTGlzdGVuZXIgPSB1c2VDYWxsYmFjayhsaXN0ZW5lciA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9LCBbbGlzdGVuZXJzXSk7XG4gIGNvbnN0IGRpc3BhdGNoID0gdXNlQ2FsbGJhY2soX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHR5cGUsXG4gICAgICBldmVudFxuICAgIH0gPSBfcmVmO1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgIHZhciBfbGlzdGVuZXIkdHlwZTtcblxuICAgICAgcmV0dXJuIChfbGlzdGVuZXIkdHlwZSA9IGxpc3RlbmVyW3R5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3RlbmVyJHR5cGUuY2FsbChsaXN0ZW5lciwgZXZlbnQpO1xuICAgIH0pO1xuICB9LCBbbGlzdGVuZXJzXSk7XG4gIHJldHVybiBbZGlzcGF0Y2gsIHJlZ2lzdGVyTGlzdGVuZXJdO1xufVxuXG5jb25zdCBkZWZhdWx0U2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zID0ge1xuICBkcmFnZ2FibGU6IFwiXFxuICAgIFRvIHBpY2sgdXAgYSBkcmFnZ2FibGUgaXRlbSwgcHJlc3MgdGhlIHNwYWNlIGJhci5cXG4gICAgV2hpbGUgZHJhZ2dpbmcsIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBpdGVtLlxcbiAgICBQcmVzcyBzcGFjZSBhZ2FpbiB0byBkcm9wIHRoZSBpdGVtIGluIGl0cyBuZXcgcG9zaXRpb24sIG9yIHByZXNzIGVzY2FwZSB0byBjYW5jZWwuXFxuICBcIlxufTtcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICBvbkRyYWdTdGFydChfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBcIlBpY2tlZCB1cCBkcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiLlwiO1xuICB9LFxuXG4gIG9uRHJhZ092ZXIoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgb3ZlclxuICAgIH0gPSBfcmVmMjtcblxuICAgIGlmIChvdmVyKSB7XG4gICAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBtb3ZlZCBvdmVyIGRyb3BwYWJsZSBhcmVhIFwiICsgb3Zlci5pZCArIFwiLlwiO1xuICAgIH1cblxuICAgIHJldHVybiBcIkRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgaXMgbm8gbG9uZ2VyIG92ZXIgYSBkcm9wcGFibGUgYXJlYS5cIjtcbiAgfSxcblxuICBvbkRyYWdFbmQoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgb3ZlclxuICAgIH0gPSBfcmVmMztcblxuICAgIGlmIChvdmVyKSB7XG4gICAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBkcm9wcGVkIG92ZXIgZHJvcHBhYmxlIGFyZWEgXCIgKyBvdmVyLmlkO1xuICAgIH1cblxuICAgIHJldHVybiBcIkRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgd2FzIGRyb3BwZWQuXCI7XG4gIH0sXG5cbiAgb25EcmFnQ2FuY2VsKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZVxuICAgIH0gPSBfcmVmNDtcbiAgICByZXR1cm4gXCJEcmFnZ2luZyB3YXMgY2FuY2VsbGVkLiBEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBkcm9wcGVkLlwiO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIEFjY2Vzc2liaWxpdHkoX3JlZikge1xuICBsZXQge1xuICAgIGFubm91bmNlbWVudHMgPSBkZWZhdWx0QW5ub3VuY2VtZW50cyxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQsXG4gICAgc2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zID0gZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFubm91bmNlLFxuICAgIGFubm91bmNlbWVudFxuICB9ID0gdXNlQW5ub3VuY2VtZW50KCk7XG4gIGNvbnN0IGxpdmVSZWdpb25JZCA9IHVzZVVuaXF1ZUlkKFwiRG5kTGl2ZVJlZ2lvblwiKTtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgdXNlRG5kTW9uaXRvcih1c2VNZW1vKCgpID0+ICh7XG4gICAgb25EcmFnU3RhcnQoX3JlZjIpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZVxuICAgICAgfSA9IF9yZWYyO1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdTdGFydCh7XG4gICAgICAgIGFjdGl2ZVxuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBvbkRyYWdNb3ZlKF9yZWYzKSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0gPSBfcmVmMztcblxuICAgICAgaWYgKGFubm91bmNlbWVudHMub25EcmFnTW92ZSkge1xuICAgICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ01vdmUoe1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBvdmVyXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25EcmFnT3ZlcihfcmVmNCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjQ7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ092ZXIoe1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgb25EcmFnRW5kKF9yZWY1KSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0gPSBfcmVmNTtcbiAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnRW5kKHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIG9uRHJhZ0NhbmNlbChfcmVmNikge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjY7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ0NhbmNlbCh7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSkpO1xuICAgIH1cblxuICB9KSwgW2Fubm91bmNlLCBhbm5vdW5jZW1lbnRzXSkpO1xuXG4gIGlmICghbW91bnRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbWFya3VwID0gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChIaWRkZW5UZXh0LCB7XG4gICAgaWQ6IGhpZGRlblRleHREZXNjcmliZWRCeUlkLFxuICAgIHZhbHVlOiBzY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMuZHJhZ2dhYmxlXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KExpdmVSZWdpb24sIHtcbiAgICBpZDogbGl2ZVJlZ2lvbklkLFxuICAgIGFubm91bmNlbWVudDogYW5ub3VuY2VtZW50XG4gIH0pKTtcbiAgcmV0dXJuIGNvbnRhaW5lciA/IGNyZWF0ZVBvcnRhbChtYXJrdXAsIGNvbnRhaW5lcikgOiBtYXJrdXA7XG59XG5cbnZhciBBY3Rpb247XG5cbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIEFjdGlvbltcIkRyYWdTdGFydFwiXSA9IFwiZHJhZ1N0YXJ0XCI7XG4gIEFjdGlvbltcIkRyYWdNb3ZlXCJdID0gXCJkcmFnTW92ZVwiO1xuICBBY3Rpb25bXCJEcmFnRW5kXCJdID0gXCJkcmFnRW5kXCI7XG4gIEFjdGlvbltcIkRyYWdDYW5jZWxcIl0gPSBcImRyYWdDYW5jZWxcIjtcbiAgQWN0aW9uW1wiRHJhZ092ZXJcIl0gPSBcImRyYWdPdmVyXCI7XG4gIEFjdGlvbltcIlJlZ2lzdGVyRHJvcHBhYmxlXCJdID0gXCJyZWdpc3RlckRyb3BwYWJsZVwiO1xuICBBY3Rpb25bXCJTZXREcm9wcGFibGVEaXNhYmxlZFwiXSA9IFwic2V0RHJvcHBhYmxlRGlzYWJsZWRcIjtcbiAgQWN0aW9uW1wiVW5yZWdpc3RlckRyb3BwYWJsZVwiXSA9IFwidW5yZWdpc3RlckRyb3BwYWJsZVwiO1xufSkoQWN0aW9uIHx8IChBY3Rpb24gPSB7fSkpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdXNlU2Vuc29yKHNlbnNvciwgb3B0aW9ucykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIHNlbnNvcixcbiAgICBvcHRpb25zOiBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge31cbiAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3NlbnNvciwgb3B0aW9uc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTZW5zb3JzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2Vuc29ycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzZW5zb3JzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gWy4uLnNlbnNvcnNdLmZpbHRlcihzZW5zb3IgPT4gc2Vuc29yICE9IG51bGwpLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFsuLi5zZW5zb3JzXSk7XG59XG5cbmNvbnN0IGRlZmF1bHRDb29yZGluYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgeDogMCxcbiAgeTogMFxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICovXG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW4ocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVUcmFuc2Zvcm1PcmlnaW4oZXZlbnQsIHJlY3QpIHtcbiAgY29uc3QgZXZlbnRDb29yZGluYXRlcyA9IGdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuXG4gIGlmICghZXZlbnRDb29yZGluYXRlcykge1xuICAgIHJldHVybiAnMCAwJztcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybU9yaWdpbiA9IHtcbiAgICB4OiAoZXZlbnRDb29yZGluYXRlcy54IC0gcmVjdC5sZWZ0KSAvIHJlY3Qud2lkdGggKiAxMDAsXG4gICAgeTogKGV2ZW50Q29vcmRpbmF0ZXMueSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0ICogMTAwXG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1PcmlnaW4ueCArIFwiJSBcIiArIHRyYW5zZm9ybU9yaWdpbi55ICsgXCIlXCI7XG59XG5cbi8qKlxyXG4gKiBTb3J0IGNvbGxpc2lvbnMgZnJvbSBzbWFsbGVzdCB0byBncmVhdGVzdCB2YWx1ZVxyXG4gKi9cbmZ1bmN0aW9uIHNvcnRDb2xsaXNpb25zQXNjKF9yZWYsIF9yZWYyKSB7XG4gIGxldCB7XG4gICAgZGF0YToge1xuICAgICAgdmFsdWU6IGFcbiAgICB9XG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBiXG4gICAgfVxuICB9ID0gX3JlZjI7XG4gIHJldHVybiBhIC0gYjtcbn1cbi8qKlxyXG4gKiBTb3J0IGNvbGxpc2lvbnMgZnJvbSBncmVhdGVzdCB0byBzbWFsbGVzdCB2YWx1ZVxyXG4gKi9cblxuZnVuY3Rpb24gc29ydENvbGxpc2lvbnNEZXNjKF9yZWYzLCBfcmVmNCkge1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBhXG4gICAgfVxuICB9ID0gX3JlZjM7XG4gIGxldCB7XG4gICAgZGF0YToge1xuICAgICAgdmFsdWU6IGJcbiAgICB9XG4gIH0gPSBfcmVmNDtcbiAgcmV0dXJuIGIgLSBhO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXJzIG9mIGEgZ2l2ZW4gcmVjdGFuZ2xlOlxyXG4gKiBbVG9wTGVmdCB7eCwgeX0sIFRvcFJpZ2h0IHt4LCB5fSwgQm90dG9tTGVmdCB7eCwgeX0sIEJvdHRvbVJpZ2h0IHt4LCB5fV1cclxuICovXG5cbmZ1bmN0aW9uIGNvcm5lcnNPZlJlY3RhbmdsZShfcmVmNSkge1xuICBsZXQge1xuICAgIGxlZnQsXG4gICAgdG9wLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjU7XG4gIHJldHVybiBbe1xuICAgIHg6IGxlZnQsXG4gICAgeTogdG9wXG4gIH0sIHtcbiAgICB4OiBsZWZ0ICsgd2lkdGgsXG4gICAgeTogdG9wXG4gIH0sIHtcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcCArIGhlaWdodFxuICB9LCB7XG4gICAgeDogbGVmdCArIHdpZHRoLFxuICAgIHk6IHRvcCArIGhlaWdodFxuICB9XTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpc2lvbnMsIHByb3BlcnR5KSB7XG4gIGlmICghY29sbGlzaW9ucyB8fCBjb2xsaXNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgW2ZpcnN0Q29sbGlzaW9uXSA9IGNvbGxpc2lvbnM7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGZpcnN0Q29sbGlzaW9uW3Byb3BlcnR5XSA6IGZpcnN0Q29sbGlzaW9uO1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBvZiBhIGdpdmVuIENsaWVudFJlY3RcclxuICovXG5cbmZ1bmN0aW9uIGNlbnRlck9mUmVjdGFuZ2xlKHJlY3QsIGxlZnQsIHRvcCkge1xuICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgbGVmdCA9IHJlY3QubGVmdDtcbiAgfVxuXG4gIGlmICh0b3AgPT09IHZvaWQgMCkge1xuICAgIHRvcCA9IHJlY3QudG9wO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBsZWZ0ICsgcmVjdC53aWR0aCAqIDAuNSxcbiAgICB5OiB0b3AgKyByZWN0LmhlaWdodCAqIDAuNVxuICB9O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3QgcmVjdGFuZ2xlcyBmcm9tIGFuIGFycmF5IG9mIHJlY3RhbmdsZXMgdG8gdGhlIGNlbnRlciBvZiBhIGdpdmVuXHJcbiAqIHJlY3RhbmdsZS5cclxuICovXG5cblxuY29uc3QgY2xvc2VzdENlbnRlciA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY2VudGVyUmVjdCA9IGNlbnRlck9mUmVjdGFuZ2xlKGNvbGxpc2lvblJlY3QsIGNvbGxpc2lvblJlY3QubGVmdCwgY29sbGlzaW9uUmVjdC50b3ApO1xuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCBkaXN0QmV0d2VlbiA9IGRpc3RhbmNlQmV0d2VlbihjZW50ZXJPZlJlY3RhbmdsZShyZWN0KSwgY2VudGVyUmVjdCk7XG4gICAgICBjb2xsaXNpb25zLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcixcbiAgICAgICAgICB2YWx1ZTogZGlzdEJldHdlZW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbGxpc2lvbnMuc29ydChzb3J0Q29sbGlzaW9uc0FzYyk7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgY2xvc2VzdCByZWN0YW5nbGVzIGZyb20gYW4gYXJyYXkgb2YgcmVjdGFuZ2xlcyB0byB0aGUgY29ybmVycyBvZlxyXG4gKiBhbm90aGVyIHJlY3RhbmdsZS5cclxuICovXG5cbmNvbnN0IGNsb3Nlc3RDb3JuZXJzID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29sbGlzaW9uUmVjdCxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBjb3JuZXJzID0gY29ybmVyc09mUmVjdGFuZ2xlKGNvbGxpc2lvblJlY3QpO1xuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCByZWN0Q29ybmVycyA9IGNvcm5lcnNPZlJlY3RhbmdsZShyZWN0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IGNvcm5lcnMucmVkdWNlKChhY2N1bXVsYXRvciwgY29ybmVyLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyBkaXN0YW5jZUJldHdlZW4ocmVjdENvcm5lcnNbaW5kZXhdLCBjb3JuZXIpO1xuICAgICAgfSwgMCk7XG4gICAgICBjb25zdCBlZmZlY3RpdmVEaXN0YW5jZSA9IE51bWJlcigoZGlzdGFuY2VzIC8gNCkudG9GaXhlZCg0KSk7XG4gICAgICBjb2xsaXNpb25zLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcixcbiAgICAgICAgICB2YWx1ZTogZWZmZWN0aXZlRGlzdGFuY2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbGxpc2lvbnMuc29ydChzb3J0Q29sbGlzaW9uc0FzYyk7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW5nIHJlY3RhbmdsZSBhcmVhIGJldHdlZW4gdHdvIHJlY3RhbmdsZXNcclxuICovXG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblJhdGlvKGVudHJ5LCB0YXJnZXQpIHtcbiAgY29uc3QgdG9wID0gTWF0aC5tYXgodGFyZ2V0LnRvcCwgZW50cnkudG9wKTtcbiAgY29uc3QgbGVmdCA9IE1hdGgubWF4KHRhcmdldC5sZWZ0LCBlbnRyeS5sZWZ0KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1pbih0YXJnZXQubGVmdCArIHRhcmdldC53aWR0aCwgZW50cnkubGVmdCArIGVudHJ5LndpZHRoKTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5taW4odGFyZ2V0LnRvcCArIHRhcmdldC5oZWlnaHQsIGVudHJ5LnRvcCArIGVudHJ5LmhlaWdodCk7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgaWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcbiAgICBjb25zdCB0YXJnZXRBcmVhID0gdGFyZ2V0LndpZHRoICogdGFyZ2V0LmhlaWdodDtcbiAgICBjb25zdCBlbnRyeUFyZWEgPSBlbnRyeS53aWR0aCAqIGVudHJ5LmhlaWdodDtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25BcmVhID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUmF0aW8gPSBpbnRlcnNlY3Rpb25BcmVhIC8gKHRhcmdldEFyZWEgKyBlbnRyeUFyZWEgLSBpbnRlcnNlY3Rpb25BcmVhKTtcbiAgICByZXR1cm4gTnVtYmVyKGludGVyc2VjdGlvblJhdGlvLnRvRml4ZWQoNCkpO1xuICB9IC8vIFJlY3RhbmdsZXMgZG8gbm90IG92ZXJsYXAsIG9yIG92ZXJsYXAgaGFzIGFuIGFyZWEgb2YgemVybyAoZWRnZS9jb3JuZXIgb3ZlcmxhcClcblxuXG4gIHJldHVybiAwO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJlY3RhbmdsZXMgdGhhdCBoYXMgdGhlIGdyZWF0ZXN0IGludGVyc2VjdGlvbiBhcmVhIHdpdGggYSBnaXZlblxyXG4gKiByZWN0YW5nbGUgaW4gYW4gYXJyYXkgb2YgcmVjdGFuZ2xlcy5cclxuICovXG5cbmNvbnN0IHJlY3RJbnRlcnNlY3Rpb24gPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjb2xsaXNpb25SZWN0LFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGRyb3BwYWJsZUNvbnRhaW5lciBvZiBkcm9wcGFibGVDb250YWluZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRcbiAgICB9ID0gZHJvcHBhYmxlQ29udGFpbmVyO1xuICAgIGNvbnN0IHJlY3QgPSBkcm9wcGFibGVSZWN0cy5nZXQoaWQpO1xuXG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IGludGVyc2VjdGlvblJhdGlvID0gZ2V0SW50ZXJzZWN0aW9uUmF0aW8ocmVjdCwgY29sbGlzaW9uUmVjdCk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgICB2YWx1ZTogaW50ZXJzZWN0aW9uUmF0aW9cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNEZXNjKTtcbn07XG5cbi8qKlxyXG4gKiBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBib3VuZGluZyByZWN0YW5nbGVcclxuICovXG5cbmZ1bmN0aW9uIGlzUG9pbnRXaXRoaW5SZWN0KHBvaW50LCByZWN0KSB7XG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB0b3AgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IGJvdHRvbSAmJiBsZWZ0IDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSByaWdodDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWN0YW5nbGVzIHRoYXQgdGhlIHBvaW50ZXIgaXMgaG92ZXJpbmcgb3ZlclxyXG4gKi9cblxuXG5jb25zdCBwb2ludGVyV2l0aGluID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBwb2ludGVyQ29vcmRpbmF0ZXNcbiAgfSA9IF9yZWY7XG5cbiAgaWYgKCFwb2ludGVyQ29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0ICYmIGlzUG9pbnRXaXRoaW5SZWN0KHBvaW50ZXJDb29yZGluYXRlcywgcmVjdCkpIHtcbiAgICAgIC8qIFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gYSBzaW5nbGUgcmVjdGFuZ2xlIGludGVyc2VjdGluZ1xyXG4gICAgICAgKiB3aXRoIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzLiBJbiBvcmRlciB0byBzb3J0IHRoZVxyXG4gICAgICAgKiBjb2xsaWRpbmcgcmVjdGFuZ2xlcywgd2UgbWVhc3VyZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxyXG4gICAgICAgKiB0aGUgcG9pbnRlciBhbmQgdGhlIGNvcm5lcnMgb2YgdGhlIGludGVyc2VjdGluZyByZWN0YW5nbGVcclxuICAgICAgICovXG4gICAgICBjb25zdCBjb3JuZXJzID0gY29ybmVyc09mUmVjdGFuZ2xlKHJlY3QpO1xuICAgICAgY29uc3QgZGlzdGFuY2VzID0gY29ybmVycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjb3JuZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgZGlzdGFuY2VCZXR3ZWVuKHBvaW50ZXJDb29yZGluYXRlcywgY29ybmVyKTtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRGlzdGFuY2UgPSBOdW1iZXIoKGRpc3RhbmNlcyAvIDQpLnRvRml4ZWQoNCkpO1xuICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgdmFsdWU6IGVmZmVjdGl2ZURpc3RhbmNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNBc2MpO1xufTtcblxuZnVuY3Rpb24gYWRqdXN0U2NhbGUodHJhbnNmb3JtLCByZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIHsgLi4udHJhbnNmb3JtLFxuICAgIHNjYWxlWDogcmVjdDEgJiYgcmVjdDIgPyByZWN0MS53aWR0aCAvIHJlY3QyLndpZHRoIDogMSxcbiAgICBzY2FsZVk6IHJlY3QxICYmIHJlY3QyID8gcmVjdDEuaGVpZ2h0IC8gcmVjdDIuaGVpZ2h0IDogMVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0RGVsdGEocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiByZWN0MSAmJiByZWN0MiA/IHtcbiAgICB4OiByZWN0MS5sZWZ0IC0gcmVjdDIubGVmdCxcbiAgICB5OiByZWN0MS50b3AgLSByZWN0Mi50b3BcbiAgfSA6IGRlZmF1bHRDb29yZGluYXRlcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVjdEFkanVzdG1lbnRGbihtb2RpZmllcikge1xuICByZXR1cm4gZnVuY3Rpb24gYWRqdXN0Q2xpZW50UmVjdChyZWN0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFkanVzdG1lbnRzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFkanVzdG1lbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRqdXN0bWVudHMucmVkdWNlKChhY2MsIGFkanVzdG1lbnQpID0+ICh7IC4uLmFjYyxcbiAgICAgIHRvcDogYWNjLnRvcCArIG1vZGlmaWVyICogYWRqdXN0bWVudC55LFxuICAgICAgYm90dG9tOiBhY2MuYm90dG9tICsgbW9kaWZpZXIgKiBhZGp1c3RtZW50LnksXG4gICAgICBsZWZ0OiBhY2MubGVmdCArIG1vZGlmaWVyICogYWRqdXN0bWVudC54LFxuICAgICAgcmlnaHQ6IGFjYy5yaWdodCArIG1vZGlmaWVyICogYWRqdXN0bWVudC54XG4gICAgfSksIHsgLi4ucmVjdFxuICAgIH0pO1xuICB9O1xufVxuY29uc3QgZ2V0QWRqdXN0ZWRSZWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZVJlY3RBZGp1c3RtZW50Rm4oMSk7XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICBpZiAodHJhbnNmb3JtLnN0YXJ0c1dpdGgoJ21hdHJpeDNkKCcpKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQXJyYXkgPSB0cmFuc2Zvcm0uc2xpY2UoOSwgLTEpLnNwbGl0KC8sIC8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiArdHJhbnNmb3JtQXJyYXlbMTJdLFxuICAgICAgeTogK3RyYW5zZm9ybUFycmF5WzEzXSxcbiAgICAgIHNjYWxlWDogK3RyYW5zZm9ybUFycmF5WzBdLFxuICAgICAgc2NhbGVZOiArdHJhbnNmb3JtQXJyYXlbNV1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHRyYW5zZm9ybS5zdGFydHNXaXRoKCdtYXRyaXgoJykpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1BcnJheSA9IHRyYW5zZm9ybS5zbGljZSg3LCAtMSkuc3BsaXQoLywgLyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICt0cmFuc2Zvcm1BcnJheVs0XSxcbiAgICAgIHk6ICt0cmFuc2Zvcm1BcnJheVs1XSxcbiAgICAgIHNjYWxlWDogK3RyYW5zZm9ybUFycmF5WzBdLFxuICAgICAgc2NhbGVZOiArdHJhbnNmb3JtQXJyYXlbM11cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm0ocmVjdCwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICBpZiAoIXBhcnNlZFRyYW5zZm9ybSkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHNjYWxlWCxcbiAgICBzY2FsZVksXG4gICAgeDogdHJhbnNsYXRlWCxcbiAgICB5OiB0cmFuc2xhdGVZXG4gIH0gPSBwYXJzZWRUcmFuc2Zvcm07XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgLSB0cmFuc2xhdGVYIC0gKDEgLSBzY2FsZVgpICogcGFyc2VGbG9hdCh0cmFuc2Zvcm1PcmlnaW4pO1xuICBjb25zdCB5ID0gcmVjdC50b3AgLSB0cmFuc2xhdGVZIC0gKDEgLSBzY2FsZVkpICogcGFyc2VGbG9hdCh0cmFuc2Zvcm1PcmlnaW4uc2xpY2UodHJhbnNmb3JtT3JpZ2luLmluZGV4T2YoJyAnKSArIDEpKTtcbiAgY29uc3QgdyA9IHNjYWxlWCA/IHJlY3Qud2lkdGggLyBzY2FsZVggOiByZWN0LndpZHRoO1xuICBjb25zdCBoID0gc2NhbGVZID8gcmVjdC5oZWlnaHQgLyBzY2FsZVkgOiByZWN0LmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgdyxcbiAgICBib3R0b206IHkgKyBoLFxuICAgIGxlZnQ6IHhcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGlnbm9yZVRyYW5zZm9ybTogZmFsc2Vcbn07XG4vKipcclxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgfVxuXG4gIGxldCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBpZiAob3B0aW9ucy5pZ25vcmVUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW5cbiAgICB9ID0gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZWN0ID0gaW52ZXJzZVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICByaWdodFxuICB9O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgQ2xpZW50UmVjdCByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zXHJcbiAqIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgaXQgbWVhc3VyZXMuXHJcbiAqXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChlbGVtZW50LCB7XG4gICAgaWdub3JlVHJhbnNmb3JtOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmlubmVyV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuaW5uZXJIZWlnaHQ7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IHdpZHRoLFxuICAgIGJvdHRvbTogaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0ZpeGVkKG5vZGUsIGNvbXB1dGVkU3R5bGUpIHtcbiAgaWYgKGNvbXB1dGVkU3R5bGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXB1dGVkU3R5bGUgPSBnZXRXaW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnO1xufVxuXG5mdW5jdGlvbiBpc1Njcm9sbGFibGUoZWxlbWVudCwgY29tcHV0ZWRTdHlsZSkge1xuICBpZiAoY29tcHV0ZWRTdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgY29tcHV0ZWRTdHlsZSA9IGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB9XG5cbiAgY29uc3Qgb3ZlcmZsb3dSZWdleCA9IC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gWydvdmVyZmxvdycsICdvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ107XG4gIHJldHVybiBwcm9wZXJ0aWVzLnNvbWUocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBvdmVyZmxvd1JlZ2V4LnRlc3QodmFsdWUpIDogZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQsIGxpbWl0KSB7XG4gIGNvbnN0IHNjcm9sbFBhcmVudHMgPSBbXTtcblxuICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlKSB7XG4gICAgaWYgKGxpbWl0ICE9IG51bGwgJiYgc2Nyb2xsUGFyZW50cy5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5zY3JvbGxpbmdFbGVtZW50ICE9IG51bGwgJiYgIXNjcm9sbFBhcmVudHMuaW5jbHVkZXMobm9kZS5zY3JvbGxpbmdFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5wdXNoKG5vZGUuc2Nyb2xsaW5nRWxlbWVudCk7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQobm9kZSkgfHwgaXNTVkdFbGVtZW50KG5vZGUpKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsUGFyZW50cy5pbmNsdWRlcyhub2RlKSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgaWYgKG5vZGUgIT09IGVsZW1lbnQpIHtcbiAgICAgIGlmIChpc1Njcm9sbGFibGUobm9kZSwgY29tcHV0ZWRTdHlsZSkpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZpeGVkKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBbZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3JdID0gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlLCAxKTtcbiAgcmV0dXJuIGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yICE9IG51bGwgPyBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFjYW5Vc2VET00gfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0RvY3VtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQgPT09IGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCkuc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFhDb29yZGluYXRlKGVsZW1lbnQpIHtcbiAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsWDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxZQ29vcmRpbmF0ZShlbGVtZW50KSB7XG4gIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5zY3JvbGxUb3A7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxDb29yZGluYXRlcyhlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogZ2V0U2Nyb2xsWENvb3JkaW5hdGUoZWxlbWVudCksXG4gICAgeTogZ2V0U2Nyb2xsWUNvb3JkaW5hdGUoZWxlbWVudClcbiAgfTtcbn1cblxudmFyIERpcmVjdGlvbjtcblxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkZvcndhcmRcIl0gPSAxXSA9IFwiRm9yd2FyZFwiO1xuICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiQmFja3dhcmRcIl0gPSAtMV0gPSBcIkJhY2t3YXJkXCI7XG59KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5cbmZ1bmN0aW9uIGlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFjYW5Vc2VET00gfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudCA9PT0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsaW5nQ29udGFpbmVyKSB7XG4gIGNvbnN0IG1pblNjcm9sbCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KHNjcm9sbGluZ0NvbnRhaW5lcikgPyB7XG4gICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoXG4gIH0gOiB7XG4gICAgaGVpZ2h0OiBzY3JvbGxpbmdDb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgIHdpZHRoOiBzY3JvbGxpbmdDb250YWluZXIuY2xpZW50V2lkdGhcbiAgfTtcbiAgY29uc3QgbWF4U2Nyb2xsID0ge1xuICAgIHg6IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxXaWR0aCAtIGRpbWVuc2lvbnMud2lkdGgsXG4gICAgeTogc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbEhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0XG4gIH07XG4gIGNvbnN0IGlzVG9wID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA8PSBtaW5TY3JvbGwueTtcbiAgY29uc3QgaXNMZWZ0ID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbExlZnQgPD0gbWluU2Nyb2xsLng7XG4gIGNvbnN0IGlzQm90dG9tID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA+PSBtYXhTY3JvbGwueTtcbiAgY29uc3QgaXNSaWdodCA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxMZWZ0ID49IG1heFNjcm9sbC54O1xuICByZXR1cm4ge1xuICAgIGlzVG9wLFxuICAgIGlzTGVmdCxcbiAgICBpc0JvdHRvbSxcbiAgICBpc1JpZ2h0LFxuICAgIG1heFNjcm9sbCxcbiAgICBtaW5TY3JvbGxcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdFRocmVzaG9sZCA9IHtcbiAgeDogMC4yLFxuICB5OiAwLjJcbn07XG5mdW5jdGlvbiBnZXRTY3JvbGxEaXJlY3Rpb25BbmRTcGVlZChzY3JvbGxDb250YWluZXIsIHNjcm9sbENvbnRhaW5lclJlY3QsIF9yZWYsIGFjY2VsZXJhdGlvbiwgdGhyZXNob2xkUGVyY2VudGFnZSkge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9ID0gX3JlZjtcblxuICBpZiAoYWNjZWxlcmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBhY2NlbGVyYXRpb24gPSAxMDtcbiAgfVxuXG4gIGlmICh0aHJlc2hvbGRQZXJjZW50YWdlID09PSB2b2lkIDApIHtcbiAgICB0aHJlc2hvbGRQZXJjZW50YWdlID0gZGVmYXVsdFRocmVzaG9sZDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpc1RvcCxcbiAgICBpc0JvdHRvbSxcbiAgICBpc0xlZnQsXG4gICAgaXNSaWdodFxuICB9ID0gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsQ29udGFpbmVyKTtcbiAgY29uc3QgZGlyZWN0aW9uID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBjb25zdCBzcGVlZCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgY29uc3QgdGhyZXNob2xkID0ge1xuICAgIGhlaWdodDogc2Nyb2xsQ29udGFpbmVyUmVjdC5oZWlnaHQgKiB0aHJlc2hvbGRQZXJjZW50YWdlLnksXG4gICAgd2lkdGg6IHNjcm9sbENvbnRhaW5lclJlY3Qud2lkdGggKiB0aHJlc2hvbGRQZXJjZW50YWdlLnhcbiAgfTtcblxuICBpZiAoIWlzVG9wICYmIHRvcCA8PSBzY3JvbGxDb250YWluZXJSZWN0LnRvcCArIHRocmVzaG9sZC5oZWlnaHQpIHtcbiAgICAvLyBTY3JvbGwgVXBcbiAgICBkaXJlY3Rpb24ueSA9IERpcmVjdGlvbi5CYWNrd2FyZDtcbiAgICBzcGVlZC55ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QudG9wICsgdGhyZXNob2xkLmhlaWdodCAtIHRvcCkgLyB0aHJlc2hvbGQuaGVpZ2h0KTtcbiAgfSBlbHNlIGlmICghaXNCb3R0b20gJiYgYm90dG9tID49IHNjcm9sbENvbnRhaW5lclJlY3QuYm90dG9tIC0gdGhyZXNob2xkLmhlaWdodCkge1xuICAgIC8vIFNjcm9sbCBEb3duXG4gICAgZGlyZWN0aW9uLnkgPSBEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICBzcGVlZC55ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QuYm90dG9tIC0gdGhyZXNob2xkLmhlaWdodCAtIGJvdHRvbSkgLyB0aHJlc2hvbGQuaGVpZ2h0KTtcbiAgfVxuXG4gIGlmICghaXNSaWdodCAmJiByaWdodCA+PSBzY3JvbGxDb250YWluZXJSZWN0LnJpZ2h0IC0gdGhyZXNob2xkLndpZHRoKSB7XG4gICAgLy8gU2Nyb2xsIFJpZ2h0XG4gICAgZGlyZWN0aW9uLnggPSBEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICBzcGVlZC54ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QucmlnaHQgLSB0aHJlc2hvbGQud2lkdGggLSByaWdodCkgLyB0aHJlc2hvbGQud2lkdGgpO1xuICB9IGVsc2UgaWYgKCFpc0xlZnQgJiYgbGVmdCA8PSBzY3JvbGxDb250YWluZXJSZWN0LmxlZnQgKyB0aHJlc2hvbGQud2lkdGgpIHtcbiAgICAvLyBTY3JvbGwgTGVmdFxuICAgIGRpcmVjdGlvbi54ID0gRGlyZWN0aW9uLkJhY2t3YXJkO1xuICAgIHNwZWVkLnggPSBhY2NlbGVyYXRpb24gKiBNYXRoLmFicygoc2Nyb2xsQ29udGFpbmVyUmVjdC5sZWZ0ICsgdGhyZXNob2xkLndpZHRoIC0gbGVmdCkgLyB0aHJlc2hvbGQud2lkdGgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaXJlY3Rpb24sXG4gICAgc3BlZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsRWxlbWVudFJlY3QoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlubmVyV2lkdGgsXG4gICAgICBpbm5lckhlaWdodFxuICAgIH0gPSB3aW5kb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogaW5uZXJXaWR0aCxcbiAgICAgIGJvdHRvbTogaW5uZXJIZWlnaHQsXG4gICAgICB3aWR0aDogaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b20sXG4gICAgd2lkdGg6IGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBlbGVtZW50LmNsaWVudEhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxPZmZzZXRzKHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgcmV0dXJuIHNjcm9sbGFibGVBbmNlc3RvcnMucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICByZXR1cm4gYWRkKGFjYywgZ2V0U2Nyb2xsQ29vcmRpbmF0ZXMobm9kZSkpO1xuICB9LCBkZWZhdWx0Q29vcmRpbmF0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsWE9mZnNldChzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlQW5jZXN0b3JzLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgcmV0dXJuIGFjYyArIGdldFNjcm9sbFhDb29yZGluYXRlKG5vZGUpO1xuICB9LCAwKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFlPZmZzZXQoc2Nyb2xsYWJsZUFuY2VzdG9ycykge1xuICByZXR1cm4gc2Nyb2xsYWJsZUFuY2VzdG9ycy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIHJldHVybiBhY2MgKyBnZXRTY3JvbGxZQ29vcmRpbmF0ZShub2RlKTtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWxlbWVudCwgbWVhc3VyZSkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGdldENsaWVudFJlY3Q7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH0gPSBtZWFzdXJlKGVsZW1lbnQpO1xuICBjb25zdCBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciA9IGdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKGVsZW1lbnQpO1xuXG4gIGlmICghZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYm90dG9tIDw9IDAgfHwgcmlnaHQgPD0gMCB8fCB0b3AgPj0gd2luZG93LmlubmVySGVpZ2h0IHx8IGxlZnQgPj0gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiAnY2VudGVyJyxcbiAgICAgIGlubGluZTogJ2NlbnRlcidcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBwcm9wZXJ0aWVzID0gW1sneCcsIFsnbGVmdCcsICdyaWdodCddLCBnZXRTY3JvbGxYT2Zmc2V0XSwgWyd5JywgWyd0b3AnLCAnYm90dG9tJ10sIGdldFNjcm9sbFlPZmZzZXRdXTtcbmNsYXNzIFJlY3Qge1xuICBjb25zdHJ1Y3RvcihyZWN0LCBlbGVtZW50KSB7XG4gICAgdGhpcy5yZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy50b3AgPSB2b2lkIDA7XG4gICAgdGhpcy5ib3R0b20gPSB2b2lkIDA7XG4gICAgdGhpcy5yaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZnQgPSB2b2lkIDA7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9ycyA9IGdldFNjcm9sbGFibGVBbmNlc3RvcnMoZWxlbWVudCk7XG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IGdldFNjcm9sbE9mZnNldHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7XG4gICAgdGhpcy5yZWN0ID0geyAuLi5yZWN0XG4gICAgfTtcbiAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yIChjb25zdCBbYXhpcywga2V5cywgZ2V0U2Nyb2xsT2Zmc2V0XSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXRzID0gZ2V0U2Nyb2xsT2Zmc2V0KHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0c0RlbHRsYSA9IHNjcm9sbE9mZnNldHNbYXhpc10gLSBjdXJyZW50T2Zmc2V0cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3Rba2V5XSArIHNjcm9sbE9mZnNldHNEZWx0bGE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVjdCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxufVxuXG5jbGFzcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuXG4gICAgdGhpcy5yZW1vdmVBbGwgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgdmFyIF90aGlzJHRhcmdldDtcblxuICAgICAgICByZXR1cm4gKF90aGlzJHRhcmdldCA9IHRoaXMudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoLi4ubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgYWRkKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyR0YXJnZXQyO1xuXG4gICAgKF90aGlzJHRhcmdldDIgPSB0aGlzLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2goW2V2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclRhcmdldCh0YXJnZXQpIHtcbiAgLy8gSWYgdGhlIGBldmVudC50YXJnZXRgIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudCBldmVudHMgd2lsbCBzdGlsbCBiZSB0YXJnZXRlZFxuICAvLyBhdCBpdCwgYW5kIGhlbmNlIHdvbid0IGFsd2F5cyBidWJibGUgdXAgdG8gdGhlIHdpbmRvdyBvciBkb2N1bWVudCBhbnltb3JlLlxuICAvLyBJZiB0aGVyZSBpcyBhbnkgcmlzayBvZiBhbiBlbGVtZW50IGJlaW5nIHJlbW92ZWQgd2hpbGUgaXQgaXMgYmVpbmcgZHJhZ2dlZCxcbiAgLy8gdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gYXR0YWNoIHRoZSBldmVudCBsaXN0ZW5lcnMgZGlyZWN0bHkgdG8gdGhlIHRhcmdldC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0XG4gIGNvbnN0IHtcbiAgICBFdmVudFRhcmdldFxuICB9ID0gZ2V0V2luZG93KHRhcmdldCk7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBFdmVudFRhcmdldCA/IHRhcmdldCA6IGdldE93bmVyRG9jdW1lbnQodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gaGFzRXhjZWVkZWREaXN0YW5jZShkZWx0YSwgbWVhc3VyZW1lbnQpIHtcbiAgY29uc3QgZHggPSBNYXRoLmFicyhkZWx0YS54KTtcbiAgY29uc3QgZHkgPSBNYXRoLmFicyhkZWx0YS55KTtcblxuICBpZiAodHlwZW9mIG1lYXN1cmVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiogMiArIGR5ICoqIDIpID4gbWVhc3VyZW1lbnQ7XG4gIH1cblxuICBpZiAoJ3gnIGluIG1lYXN1cmVtZW50ICYmICd5JyBpbiBtZWFzdXJlbWVudCkge1xuICAgIHJldHVybiBkeCA+IG1lYXN1cmVtZW50LnggJiYgZHkgPiBtZWFzdXJlbWVudC55O1xuICB9XG5cbiAgaWYgKCd4JyBpbiBtZWFzdXJlbWVudCkge1xuICAgIHJldHVybiBkeCA+IG1lYXN1cmVtZW50Lng7XG4gIH1cblxuICBpZiAoJ3knIGluIG1lYXN1cmVtZW50KSB7XG4gICAgcmV0dXJuIGR5ID4gbWVhc3VyZW1lbnQueTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIEV2ZW50TmFtZTtcblxuKGZ1bmN0aW9uIChFdmVudE5hbWUpIHtcbiAgRXZlbnROYW1lW1wiQ2xpY2tcIl0gPSBcImNsaWNrXCI7XG4gIEV2ZW50TmFtZVtcIkRyYWdTdGFydFwiXSA9IFwiZHJhZ3N0YXJ0XCI7XG4gIEV2ZW50TmFtZVtcIktleWRvd25cIl0gPSBcImtleWRvd25cIjtcbiAgRXZlbnROYW1lW1wiQ29udGV4dE1lbnVcIl0gPSBcImNvbnRleHRtZW51XCI7XG4gIEV2ZW50TmFtZVtcIlJlc2l6ZVwiXSA9IFwicmVzaXplXCI7XG4gIEV2ZW50TmFtZVtcIlNlbGVjdGlvbkNoYW5nZVwiXSA9IFwic2VsZWN0aW9uY2hhbmdlXCI7XG4gIEV2ZW50TmFtZVtcIlZpc2liaWxpdHlDaGFuZ2VcIl0gPSBcInZpc2liaWxpdHljaGFuZ2VcIjtcbn0pKEV2ZW50TmFtZSB8fCAoRXZlbnROYW1lID0ge30pKTtcblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxudmFyIEtleWJvYXJkQ29kZTtcblxuKGZ1bmN0aW9uIChLZXlib2FyZENvZGUpIHtcbiAgS2V5Ym9hcmRDb2RlW1wiU3BhY2VcIl0gPSBcIlNwYWNlXCI7XG4gIEtleWJvYXJkQ29kZVtcIkRvd25cIl0gPSBcIkFycm93RG93blwiO1xuICBLZXlib2FyZENvZGVbXCJSaWdodFwiXSA9IFwiQXJyb3dSaWdodFwiO1xuICBLZXlib2FyZENvZGVbXCJMZWZ0XCJdID0gXCJBcnJvd0xlZnRcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiVXBcIl0gPSBcIkFycm93VXBcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiRXNjXCJdID0gXCJFc2NhcGVcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiRW50ZXJcIl0gPSBcIkVudGVyXCI7XG4gIEtleWJvYXJkQ29kZVtcIlRhYlwiXSA9IFwiVGFiXCI7XG59KShLZXlib2FyZENvZGUgfHwgKEtleWJvYXJkQ29kZSA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRLZXlib2FyZENvZGVzID0ge1xuICBzdGFydDogW0tleWJvYXJkQ29kZS5TcGFjZSwgS2V5Ym9hcmRDb2RlLkVudGVyXSxcbiAgY2FuY2VsOiBbS2V5Ym9hcmRDb2RlLkVzY10sXG4gIGVuZDogW0tleWJvYXJkQ29kZS5TcGFjZSwgS2V5Ym9hcmRDb2RlLkVudGVyLCBLZXlib2FyZENvZGUuVGFiXVxufTtcbmNvbnN0IGRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIgPSAoZXZlbnQsIF9yZWYpID0+IHtcbiAgbGV0IHtcbiAgICBjdXJyZW50Q29vcmRpbmF0ZXNcbiAgfSA9IF9yZWY7XG5cbiAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgY2FzZSBLZXlib2FyZENvZGUuUmlnaHQ6XG4gICAgICByZXR1cm4geyAuLi5jdXJyZW50Q29vcmRpbmF0ZXMsXG4gICAgICAgIHg6IGN1cnJlbnRDb29yZGluYXRlcy54ICsgMjVcbiAgICAgIH07XG5cbiAgICBjYXNlIEtleWJvYXJkQ29kZS5MZWZ0OlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB4OiBjdXJyZW50Q29vcmRpbmF0ZXMueCAtIDI1XG4gICAgICB9O1xuXG4gICAgY2FzZSBLZXlib2FyZENvZGUuRG93bjpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeTogY3VycmVudENvb3JkaW5hdGVzLnkgKyAyNVxuICAgICAgfTtcblxuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlVwOlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB5OiBjdXJyZW50Q29vcmRpbmF0ZXMueSAtIDI1XG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNsYXNzIEtleWJvYXJkU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b1Njcm9sbEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzID0gdm9pZCAwO1xuICAgIHRoaXMubGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBldmVudDoge1xuICAgICAgICB0YXJnZXRcbiAgICAgIH1cbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhnZXRPd25lckRvY3VtZW50KHRhcmdldCkpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhnZXRXaW5kb3codGFyZ2V0KSk7XG4gICAgdGhpcy5oYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDYW5jZWwgPSB0aGlzLmhhbmRsZUNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXR0YWNoKCk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuUmVzaXplLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5WaXNpYmlsaXR5Q2hhbmdlLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmxpc3RlbmVycy5hZGQoRXZlbnROYW1lLktleWRvd24sIHRoaXMuaGFuZGxlS2V5RG93bikpO1xuICB9XG5cbiAgaGFuZGxlU3RhcnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIG9uU3RhcnRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBub2RlID0gYWN0aXZlTm9kZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChub2RlKTtcbiAgICB9XG5cbiAgICBvblN0YXJ0KGRlZmF1bHRDb29yZGluYXRlcyk7XG4gIH1cblxuICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGlzS2V5Ym9hcmRFdmVudChldmVudCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5Ym9hcmRDb2RlcyA9IGRlZmF1bHRLZXlib2FyZENvZGVzLFxuICAgICAgICBjb29yZGluYXRlR2V0dGVyID0gZGVmYXVsdEtleWJvYXJkQ29vcmRpbmF0ZUdldHRlcixcbiAgICAgICAgc2Nyb2xsQmVoYXZpb3IgPSAnc21vb3RoJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvZGVcbiAgICAgIH0gPSBldmVudDtcblxuICAgICAgaWYgKGtleWJvYXJkQ29kZXMuZW5kLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW5kKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Ym9hcmRDb2Rlcy5jYW5jZWwuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDYW5jZWwoZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGlzaW9uUmVjdFxuICAgICAgfSA9IGNvbnRleHQuY3VycmVudDtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb29yZGluYXRlcyA9IGNvbGxpc2lvblJlY3QgPyB7XG4gICAgICAgIHg6IGNvbGxpc2lvblJlY3QubGVmdCxcbiAgICAgICAgeTogY29sbGlzaW9uUmVjdC50b3BcbiAgICAgIH0gOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG5cbiAgICAgIGlmICghdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcykge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzID0gY3VycmVudENvb3JkaW5hdGVzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdDb29yZGluYXRlcyA9IGNvb3JkaW5hdGVHZXR0ZXIoZXZlbnQsIHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LmN1cnJlbnQsXG4gICAgICAgIGN1cnJlbnRDb29yZGluYXRlc1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXdDb29yZGluYXRlcykge1xuICAgICAgICBjb25zdCBjb29yZGluYXRlc0RlbHRhID0gc3VidHJhY3QobmV3Q29vcmRpbmF0ZXMsIGN1cnJlbnRDb29yZGluYXRlcyk7XG4gICAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9yc1xuICAgICAgICB9ID0gY29udGV4dC5jdXJyZW50O1xuXG4gICAgICAgIGZvciAoY29uc3Qgc2Nyb2xsQ29udGFpbmVyIG9mIHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5jb2RlO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzVG9wLFxuICAgICAgICAgICAgaXNSaWdodCxcbiAgICAgICAgICAgIGlzTGVmdCxcbiAgICAgICAgICAgIGlzQm90dG9tLFxuICAgICAgICAgICAgbWF4U2Nyb2xsLFxuICAgICAgICAgICAgbWluU2Nyb2xsXG4gICAgICAgICAgfSA9IGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbENvbnRhaW5lcik7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudFJlY3QgPSBnZXRTY3JvbGxFbGVtZW50UmVjdChzY3JvbGxDb250YWluZXIpO1xuICAgICAgICAgIGNvbnN0IGNsYW1wZWRDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIHg6IE1hdGgubWluKGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ID8gc2Nyb2xsRWxlbWVudFJlY3QucmlnaHQgLSBzY3JvbGxFbGVtZW50UmVjdC53aWR0aCAvIDIgOiBzY3JvbGxFbGVtZW50UmVjdC5yaWdodCwgTWF0aC5tYXgoZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgPyBzY3JvbGxFbGVtZW50UmVjdC5sZWZ0IDogc2Nyb2xsRWxlbWVudFJlY3QubGVmdCArIHNjcm9sbEVsZW1lbnRSZWN0LndpZHRoIC8gMiwgbmV3Q29vcmRpbmF0ZXMueCkpLFxuICAgICAgICAgICAgeTogTWF0aC5taW4oZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuRG93biA/IHNjcm9sbEVsZW1lbnRSZWN0LmJvdHRvbSAtIHNjcm9sbEVsZW1lbnRSZWN0LmhlaWdodCAvIDIgOiBzY3JvbGxFbGVtZW50UmVjdC5ib3R0b20sIE1hdGgubWF4KGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gPyBzY3JvbGxFbGVtZW50UmVjdC50b3AgOiBzY3JvbGxFbGVtZW50UmVjdC50b3AgKyBzY3JvbGxFbGVtZW50UmVjdC5oZWlnaHQgLyAyLCBuZXdDb29yZGluYXRlcy55KSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFggPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCAmJiAhaXNSaWdodCB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5MZWZ0ICYmICFpc0xlZnQ7XG4gICAgICAgICAgY29uc3QgY2FuU2Nyb2xsWSA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gJiYgIWlzQm90dG9tIHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlVwICYmICFpc1RvcDtcblxuICAgICAgICAgIGlmIChjYW5TY3JvbGxYICYmIGNsYW1wZWRDb29yZGluYXRlcy54ICE9PSBuZXdDb29yZGluYXRlcy54KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxDb29yZGluYXRlcyA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICsgY29vcmRpbmF0ZXNEZWx0YS54O1xuICAgICAgICAgICAgY29uc3QgY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzIDw9IG1heFNjcm9sbC54IHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkxlZnQgJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPj0gbWluU2Nyb2xsLng7XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzICYmICFjb29yZGluYXRlc0RlbHRhLnkpIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgY29vcmRpbmF0ZXMsIHRoZSBzY3JvbGwgYWRqdXN0bWVudCBhbG9uZSB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgLy8gbG9naWMgdG8gYXV0by1kZXRlY3QgdGhlIG5ldyBjb250YWluZXIgd2UgYXJlIG92ZXJcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBuZXdTY3JvbGxDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC0gbmV3U2Nyb2xsQ29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY3JvbGxEZWx0YS54ID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgPyBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCAtIG1heFNjcm9sbC54IDogc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgLSBtaW5TY3JvbGwueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjcm9sbERlbHRhLngpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAtc2Nyb2xsRGVsdGEueCxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2FuU2Nyb2xsWSAmJiBjbGFtcGVkQ29vcmRpbmF0ZXMueSAhPT0gbmV3Q29vcmRpbmF0ZXMueSkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wICsgY29vcmRpbmF0ZXNEZWx0YS55O1xuICAgICAgICAgICAgY29uc3QgY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPD0gbWF4U2Nyb2xsLnkgfHwgZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuVXAgJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPj0gbWluU2Nyb2xsLnk7XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzICYmICFjb29yZGluYXRlc0RlbHRhLngpIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgY29vcmRpbmF0ZXMsIHRoZSBzY3JvbGwgYWRqdXN0bWVudCBhbG9uZSB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgLy8gbG9naWMgdG8gYXV0by1kZXRlY3QgdGhlIG5ldyBjb250YWluZXIgd2UgYXJlIG92ZXJcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICB0b3A6IG5ld1Njcm9sbENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcykge1xuICAgICAgICAgICAgICBzY3JvbGxEZWx0YS55ID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIG5ld1Njcm9sbENvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueSA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gPyBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC0gbWF4U2Nyb2xsLnkgOiBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC0gbWluU2Nyb2xsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxEZWx0YS55KSB7XG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeSh7XG4gICAgICAgICAgICAgICAgdG9wOiAtc2Nyb2xsRGVsdGEueSxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZShldmVudCwgYWRkKHN1YnRyYWN0KG5ld0Nvb3JkaW5hdGVzLCB0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzKSwgc2Nyb2xsRGVsdGEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVNb3ZlKGV2ZW50LCBjb29yZGluYXRlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTW92ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgb25Nb3ZlKGNvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGhhbmRsZUVuZChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRW5kXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIG9uRW5kKCk7XG4gIH1cblxuICBoYW5kbGVDYW5jZWwoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkNhbmNlbFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBvbkNhbmNlbCgpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICB9XG5cbn1cbktleWJvYXJkU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvbktleURvd24nLFxuICBoYW5kbGVyOiAoZXZlbnQsIF9yZWYsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleWJvYXJkQ29kZXMgPSBkZWZhdWx0S2V5Ym9hcmRDb2RlcyxcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB7XG4gICAgICBhY3RpdmVcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3Qge1xuICAgICAgY29kZVxuICAgIH0gPSBldmVudC5uYXRpdmVFdmVudDtcblxuICAgIGlmIChrZXlib2FyZENvZGVzLnN0YXJ0LmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICBjb25zdCBhY3RpdmF0b3IgPSBhY3RpdmUuYWN0aXZhdG9yTm9kZS5jdXJyZW50O1xuXG4gICAgICBpZiAoYWN0aXZhdG9yICYmIGV2ZW50LnRhcmdldCAhPT0gYWN0aXZhdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50Lm5hdGl2ZUV2ZW50XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufV07XG5cbmZ1bmN0aW9uIGlzRGlzdGFuY2VDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oY29uc3RyYWludCAmJiAnZGlzdGFuY2UnIGluIGNvbnN0cmFpbnQpO1xufVxuXG5mdW5jdGlvbiBpc0RlbGF5Q29uc3RyYWludChjb25zdHJhaW50KSB7XG4gIHJldHVybiBCb29sZWFuKGNvbnN0cmFpbnQgJiYgJ2RlbGF5JyBpbiBjb25zdHJhaW50KTtcbn1cblxuY2xhc3MgQWJzdHJhY3RQb2ludGVyU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMsIGV2ZW50cywgbGlzdGVuZXJUYXJnZXQpIHtcbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXM7XG5cbiAgICBpZiAobGlzdGVuZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdGVuZXJUYXJnZXQgPSBnZXRFdmVudExpc3RlbmVyVGFyZ2V0KHByb3BzLmV2ZW50LnRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLmV2ZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9TY3JvbGxFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRvY3VtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsQ29vcmRpbmF0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50XG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5kb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQodGFyZ2V0KTtcbiAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyh0aGlzLmRvY3VtZW50KTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMobGlzdGVuZXJUYXJnZXQpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhnZXRXaW5kb3codGFyZ2V0KSk7XG4gICAgdGhpcy5pbml0aWFsQ29vcmRpbmF0ZXMgPSAoX2dldEV2ZW50Q29vcmRpbmF0ZXMgPSBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSkgIT0gbnVsbCA/IF9nZXRFdmVudENvb3JkaW5hdGVzIDogZGVmYXVsdENvb3JkaW5hdGVzO1xuICAgIHRoaXMuaGFuZGxlU3RhcnQgPSB0aGlzLmhhbmRsZVN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVNb3ZlID0gdGhpcy5oYW5kbGVNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVFbmQgPSB0aGlzLmhhbmRsZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ2FuY2VsID0gdGhpcy5oYW5kbGVDYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUtleWRvd24gPSB0aGlzLmhhbmRsZUtleWRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24gPSB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmF0dGFjaCgpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50cyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhY3RpdmF0aW9uQ29uc3RyYWludCxcbiAgICAgICAgICBieXBhc3NBY3RpdmF0aW9uQ29uc3RyYWludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGV2ZW50cy5tb3ZlLm5hbWUsIHRoaXMuaGFuZGxlTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoZXZlbnRzLmVuZC5uYW1lLCB0aGlzLmhhbmRsZUVuZCk7XG5cbiAgICBpZiAoZXZlbnRzLmNhbmNlbCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuYWRkKGV2ZW50cy5jYW5jZWwubmFtZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIH1cblxuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuUmVzaXplLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5EcmFnU3RhcnQsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLlZpc2liaWxpdHlDaGFuZ2UsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLkNvbnRleHRNZW51LCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgdGhpcy5kb2N1bWVudExpc3RlbmVycy5hZGQoRXZlbnROYW1lLktleWRvd24sIHRoaXMuaGFuZGxlS2V5ZG93bik7XG5cbiAgICBpZiAoYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChieXBhc3NBY3RpdmF0aW9uQ29uc3RyYWludCAhPSBudWxsICYmIGJ5cGFzc0FjdGl2YXRpb25Db25zdHJhaW50KHtcbiAgICAgICAgZXZlbnQ6IHRoaXMucHJvcHMuZXZlbnQsXG4gICAgICAgIGFjdGl2ZU5vZGU6IHRoaXMucHJvcHMuYWN0aXZlTm9kZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5wcm9wcy5vcHRpb25zXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWxheUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLmhhbmRsZVN0YXJ0LCBhY3RpdmF0aW9uQ29uc3RyYWludC5kZWxheSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGVuZGluZyhhY3RpdmF0aW9uQ29uc3RyYWludCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzdGFuY2VDb25zdHJhaW50KGFjdGl2YXRpb25Db25zdHJhaW50KSkge1xuICAgICAgICB0aGlzLmhhbmRsZVBlbmRpbmcoYWN0aXZhdGlvbkNvbnN0cmFpbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVTdGFydCgpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLnJlbW92ZUFsbCgpOyAvLyBXYWl0IHVudGlsIHRoZSBuZXh0IGV2ZW50IGxvb3AgYmVmb3JlIHJlbW92aW5nIGRvY3VtZW50IGxpc3RlbmVyc1xuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbGlzdGVuIGZvciBgY2xpY2tgIGFuZCBgc2VsZWN0aW9uYCBldmVudHMgb24gdGhlIGRvY3VtZW50XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMucmVtb3ZlQWxsLCA1MCk7XG5cbiAgICBpZiAodGhpcy50aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUGVuZGluZyhjb25zdHJhaW50LCBvZmZzZXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBvblBlbmRpbmdcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBvblBlbmRpbmcoYWN0aXZlLCBjb25zdHJhaW50LCB0aGlzLmluaXRpYWxDb29yZGluYXRlcywgb2Zmc2V0KTtcbiAgfVxuXG4gIGhhbmRsZVN0YXJ0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluaXRpYWxDb29yZGluYXRlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uU3RhcnRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChpbml0aWFsQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGVkID0gdHJ1ZTsgLy8gU3RvcCBwcm9wYWdhdGlvbiBvZiBjbGljayBldmVudHMgb25jZSBhY3RpdmF0aW9uIGNvbnN0cmFpbnRzIGFyZSBtZXRcblxuICAgICAgdGhpcy5kb2N1bWVudExpc3RlbmVycy5hZGQoRXZlbnROYW1lLkNsaWNrLCBzdG9wUHJvcGFnYXRpb24sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7IC8vIFJlbW92ZSBhbnkgdGV4dCBzZWxlY3Rpb24gZnJvbSB0aGUgZG9jdW1lbnRcblxuICAgICAgdGhpcy5yZW1vdmVUZXh0U2VsZWN0aW9uKCk7IC8vIFByZXZlbnQgZnVydGhlciB0ZXh0IHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZ1xuXG4gICAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuU2VsZWN0aW9uQ2hhbmdlLCB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24pO1xuICAgICAgb25TdGFydChpbml0aWFsQ29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXMyO1xuXG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZhdGVkLFxuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzLFxuICAgICAgcHJvcHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvbk1vdmUsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFjdGl2YXRpb25Db25zdHJhaW50XG4gICAgICB9XG4gICAgfSA9IHByb3BzO1xuXG4gICAgaWYgKCFpbml0aWFsQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb29yZGluYXRlcyA9IChfZ2V0RXZlbnRDb29yZGluYXRlczIgPSBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSkgIT0gbnVsbCA/IF9nZXRFdmVudENvb3JkaW5hdGVzMiA6IGRlZmF1bHRDb29yZGluYXRlcztcbiAgICBjb25zdCBkZWx0YSA9IHN1YnRyYWN0KGluaXRpYWxDb29yZGluYXRlcywgY29vcmRpbmF0ZXMpOyAvLyBDb25zdHJhaW50IHZhbGlkYXRpb25cblxuICAgIGlmICghYWN0aXZhdGVkICYmIGFjdGl2YXRpb25Db25zdHJhaW50KSB7XG4gICAgICBpZiAoaXNEaXN0YW5jZUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uQ29uc3RyYWludC50b2xlcmFuY2UgIT0gbnVsbCAmJiBoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBhY3RpdmF0aW9uQ29uc3RyYWludC50b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2FuY2VsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzRXhjZWVkZWREaXN0YW5jZShkZWx0YSwgYWN0aXZhdGlvbkNvbnN0cmFpbnQuZGlzdGFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWxheUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIGlmIChoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBhY3RpdmF0aW9uQ29uc3RyYWludC50b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5oYW5kbGVQZW5kaW5nKGFjdGl2YXRpb25Db25zdHJhaW50LCBkZWx0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGNvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGhhbmRsZUVuZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkFib3J0LFxuICAgICAgb25FbmRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgaWYgKCF0aGlzLmFjdGl2YXRlZCkge1xuICAgICAgb25BYm9ydCh0aGlzLnByb3BzLmFjdGl2ZSk7XG4gICAgfVxuXG4gICAgb25FbmQoKTtcbiAgfVxuXG4gIGhhbmRsZUNhbmNlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkFib3J0LFxuICAgICAgb25DYW5jZWxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgaWYgKCF0aGlzLmFjdGl2YXRlZCkge1xuICAgICAgb25BYm9ydCh0aGlzLnByb3BzLmFjdGl2ZSk7XG4gICAgfVxuXG4gICAgb25DYW5jZWwoKTtcbiAgfVxuXG4gIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gS2V5Ym9hcmRDb2RlLkVzYykge1xuICAgICAgdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHZhciBfdGhpcyRkb2N1bWVudCRnZXRTZWw7XG5cbiAgICAoX3RoaXMkZG9jdW1lbnQkZ2V0U2VsID0gdGhpcy5kb2N1bWVudC5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGRvY3VtZW50JGdldFNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgfVxuXG59XG5cbmNvbnN0IGV2ZW50cyA9IHtcbiAgY2FuY2VsOiB7XG4gICAgbmFtZTogJ3BvaW50ZXJjYW5jZWwnXG4gIH0sXG4gIG1vdmU6IHtcbiAgICBuYW1lOiAncG9pbnRlcm1vdmUnXG4gIH0sXG4gIGVuZDoge1xuICAgIG5hbWU6ICdwb2ludGVydXAnXG4gIH1cbn07XG5jbGFzcyBQb2ludGVyU2Vuc29yIGV4dGVuZHMgQWJzdHJhY3RQb2ludGVyU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudFxuICAgIH0gPSBwcm9wczsgLy8gUG9pbnRlciBldmVudHMgc3RvcCBmaXJpbmcgaWYgdGhlIHRhcmdldCBpcyB1bm1vdW50ZWQgd2hpbGUgZHJhZ2dpbmdcbiAgICAvLyBUaGVyZWZvcmUgd2UgYXR0YWNoIGxpc3RlbmVycyB0byB0aGUgb3duZXIgZG9jdW1lbnQgaW5zdGVhZFxuXG4gICAgY29uc3QgbGlzdGVuZXJUYXJnZXQgPSBnZXRPd25lckRvY3VtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgc3VwZXIocHJvcHMsIGV2ZW50cywgbGlzdGVuZXJUYXJnZXQpO1xuICB9XG5cbn1cblBvaW50ZXJTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uUG9pbnRlckRvd24nLFxuICBoYW5kbGVyOiAoX3JlZiwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IHtcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmMjtcblxuICAgIGlmICghZXZlbnQuaXNQcmltYXJ5IHx8IGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG5jb25zdCBldmVudHMkMSA9IHtcbiAgbW92ZToge1xuICAgIG5hbWU6ICdtb3VzZW1vdmUnXG4gIH0sXG4gIGVuZDoge1xuICAgIG5hbWU6ICdtb3VzZXVwJ1xuICB9XG59O1xudmFyIE1vdXNlQnV0dG9uO1xuXG4oZnVuY3Rpb24gKE1vdXNlQnV0dG9uKSB7XG4gIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1wiUmlnaHRDbGlja1wiXSA9IDJdID0gXCJSaWdodENsaWNrXCI7XG59KShNb3VzZUJ1dHRvbiB8fCAoTW91c2VCdXR0b24gPSB7fSkpO1xuXG5jbGFzcyBNb3VzZVNlbnNvciBleHRlbmRzIEFic3RyYWN0UG9pbnRlclNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMsIGV2ZW50cyQxLCBnZXRPd25lckRvY3VtZW50KHByb3BzLmV2ZW50LnRhcmdldCkpO1xuICB9XG5cbn1cbk1vdXNlU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvbk1vdXNlRG93bicsXG4gIGhhbmRsZXI6IChfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWYyO1xuXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gTW91c2VCdXR0b24uUmlnaHRDbGljaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG5jb25zdCBldmVudHMkMiA9IHtcbiAgY2FuY2VsOiB7XG4gICAgbmFtZTogJ3RvdWNoY2FuY2VsJ1xuICB9LFxuICBtb3ZlOiB7XG4gICAgbmFtZTogJ3RvdWNobW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ3RvdWNoZW5kJ1xuICB9XG59O1xuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzLCBldmVudHMkMik7XG4gIH1cblxuICBzdGF0aWMgc2V0dXAoKSB7XG4gICAgLy8gQWRkaW5nIGEgbm9uLWNhcHR1cmUgYW5kIG5vbi1wYXNzaXZlIGB0b3VjaG1vdmVgIGxpc3RlbmVyIGluIG9yZGVyXG4gICAgLy8gdG8gZm9yY2UgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGNhbGxzIHRvIHdvcmsgaW4gZHluYW1pY2FsbHkgYWRkZWRcbiAgICAvLyB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlcnMuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGlPUyBTYWZhcmkuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzJDIubW92ZS5uYW1lLCBub29wLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzJDIubW92ZS5uYW1lLCBub29wKTtcbiAgICB9OyAvLyBXZSBjcmVhdGUgYSBuZXcgaGFuZGxlciBiZWNhdXNlIHRoZSB0ZWFyZG93biBmdW5jdGlvbiBvZiBhbm90aGVyIHNlbnNvclxuICAgIC8vIGNvdWxkIHJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXIgaWYgd2UgdXNlIGEgcmVmZXJlbnRpYWxseSBlcXVhbCBsaXN0ZW5lci5cblxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICB9XG5cbn1cblRvdWNoU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvblRvdWNoU3RhcnQnLFxuICBoYW5kbGVyOiAoX3JlZiwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IHtcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaGVzXG4gICAgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG52YXIgQXV0b1Njcm9sbEFjdGl2YXRvcjtcblxuKGZ1bmN0aW9uIChBdXRvU2Nyb2xsQWN0aXZhdG9yKSB7XG4gIEF1dG9TY3JvbGxBY3RpdmF0b3JbQXV0b1Njcm9sbEFjdGl2YXRvcltcIlBvaW50ZXJcIl0gPSAwXSA9IFwiUG9pbnRlclwiO1xuICBBdXRvU2Nyb2xsQWN0aXZhdG9yW0F1dG9TY3JvbGxBY3RpdmF0b3JbXCJEcmFnZ2FibGVSZWN0XCJdID0gMV0gPSBcIkRyYWdnYWJsZVJlY3RcIjtcbn0pKEF1dG9TY3JvbGxBY3RpdmF0b3IgfHwgKEF1dG9TY3JvbGxBY3RpdmF0b3IgPSB7fSkpO1xuXG52YXIgVHJhdmVyc2FsT3JkZXI7XG5cbihmdW5jdGlvbiAoVHJhdmVyc2FsT3JkZXIpIHtcbiAgVHJhdmVyc2FsT3JkZXJbVHJhdmVyc2FsT3JkZXJbXCJUcmVlT3JkZXJcIl0gPSAwXSA9IFwiVHJlZU9yZGVyXCI7XG4gIFRyYXZlcnNhbE9yZGVyW1RyYXZlcnNhbE9yZGVyW1wiUmV2ZXJzZWRUcmVlT3JkZXJcIl0gPSAxXSA9IFwiUmV2ZXJzZWRUcmVlT3JkZXJcIjtcbn0pKFRyYXZlcnNhbE9yZGVyIHx8IChUcmF2ZXJzYWxPcmRlciA9IHt9KSk7XG5cbmZ1bmN0aW9uIHVzZUF1dG9TY3JvbGxlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYWNjZWxlcmF0aW9uLFxuICAgIGFjdGl2YXRvciA9IEF1dG9TY3JvbGxBY3RpdmF0b3IuUG9pbnRlcixcbiAgICBjYW5TY3JvbGwsXG4gICAgZHJhZ2dpbmdSZWN0LFxuICAgIGVuYWJsZWQsXG4gICAgaW50ZXJ2YWwgPSA1LFxuICAgIG9yZGVyID0gVHJhdmVyc2FsT3JkZXIuVHJlZU9yZGVyLFxuICAgIHBvaW50ZXJDb29yZGluYXRlcyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgIGRlbHRhLFxuICAgIHRocmVzaG9sZFxuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2Nyb2xsSW50ZW50ID0gdXNlU2Nyb2xsSW50ZW50KHtcbiAgICBkZWx0YSxcbiAgICBkaXNhYmxlZDogIWVuYWJsZWRcbiAgfSk7XG4gIGNvbnN0IFtzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwsIGNsZWFyQXV0b1Njcm9sbEludGVydmFsXSA9IHVzZUludGVydmFsKCk7XG4gIGNvbnN0IHNjcm9sbFNwZWVkID0gdXNlUmVmKHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbERpcmVjdGlvbiA9IHVzZVJlZih7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pO1xuICBjb25zdCByZWN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgc3dpdGNoIChhY3RpdmF0b3IpIHtcbiAgICAgIGNhc2UgQXV0b1Njcm9sbEFjdGl2YXRvci5Qb2ludGVyOlxuICAgICAgICByZXR1cm4gcG9pbnRlckNvb3JkaW5hdGVzID8ge1xuICAgICAgICAgIHRvcDogcG9pbnRlckNvb3JkaW5hdGVzLnksXG4gICAgICAgICAgYm90dG9tOiBwb2ludGVyQ29vcmRpbmF0ZXMueSxcbiAgICAgICAgICBsZWZ0OiBwb2ludGVyQ29vcmRpbmF0ZXMueCxcbiAgICAgICAgICByaWdodDogcG9pbnRlckNvb3JkaW5hdGVzLnhcbiAgICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGNhc2UgQXV0b1Njcm9sbEFjdGl2YXRvci5EcmFnZ2FibGVSZWN0OlxuICAgICAgICByZXR1cm4gZHJhZ2dpbmdSZWN0O1xuICAgIH1cbiAgfSwgW2FjdGl2YXRvciwgZHJhZ2dpbmdSZWN0LCBwb2ludGVyQ29vcmRpbmF0ZXNdKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhdXRvU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gc2Nyb2xsU3BlZWQuY3VycmVudC54ICogc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQueDtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxTcGVlZC5jdXJyZW50LnkgKiBzY3JvbGxEaXJlY3Rpb24uY3VycmVudC55O1xuICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeShzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMgPSB1c2VNZW1vKCgpID0+IG9yZGVyID09PSBUcmF2ZXJzYWxPcmRlci5UcmVlT3JkZXIgPyBbLi4uc2Nyb2xsYWJsZUFuY2VzdG9yc10ucmV2ZXJzZSgpIDogc2Nyb2xsYWJsZUFuY2VzdG9ycywgW29yZGVyLCBzY3JvbGxhYmxlQW5jZXN0b3JzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFzY3JvbGxhYmxlQW5jZXN0b3JzLmxlbmd0aCB8fCAhcmVjdCkge1xuICAgICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHNjcm9sbENvbnRhaW5lciBvZiBzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gICAgICBpZiAoKGNhblNjcm9sbCA9PSBudWxsID8gdm9pZCAwIDogY2FuU2Nyb2xsKHNjcm9sbENvbnRhaW5lcikpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBzY3JvbGxhYmxlQW5jZXN0b3JzLmluZGV4T2Yoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclJlY3QgPSBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0c1tpbmRleF07XG5cbiAgICAgIGlmICghc2Nyb2xsQ29udGFpbmVyUmVjdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNwZWVkXG4gICAgICB9ID0gZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQoc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXJSZWN0LCByZWN0LCBhY2NlbGVyYXRpb24sIHRocmVzaG9sZCk7XG5cbiAgICAgIGZvciAoY29uc3QgYXhpcyBvZiBbJ3gnLCAneSddKSB7XG4gICAgICAgIGlmICghc2Nyb2xsSW50ZW50W2F4aXNdW2RpcmVjdGlvbltheGlzXV0pIHtcbiAgICAgICAgICBzcGVlZFtheGlzXSA9IDA7XG4gICAgICAgICAgZGlyZWN0aW9uW2F4aXNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQueCA+IDAgfHwgc3BlZWQueSA+IDApIHtcbiAgICAgICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBzY3JvbGxDb250YWluZXI7XG4gICAgICAgIHNldEF1dG9TY3JvbGxJbnRlcnZhbChhdXRvU2Nyb2xsLCBpbnRlcnZhbCk7XG4gICAgICAgIHNjcm9sbFNwZWVkLmN1cnJlbnQgPSBzcGVlZDtcbiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQgPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JvbGxTcGVlZC5jdXJyZW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIHNjcm9sbERpcmVjdGlvbi5jdXJyZW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIGNsZWFyQXV0b1Njcm9sbEludGVydmFsKCk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2FjY2VsZXJhdGlvbiwgYXV0b1Njcm9sbCwgY2FuU2Nyb2xsLCBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCwgZW5hYmxlZCwgaW50ZXJ2YWwsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgSlNPTi5zdHJpbmdpZnkocmVjdCksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgSlNPTi5zdHJpbmdpZnkoc2Nyb2xsSW50ZW50KSwgc2V0QXV0b1Njcm9sbEludGVydmFsLCBzY3JvbGxhYmxlQW5jZXN0b3JzLCBzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzLCBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeSh0aHJlc2hvbGQpXSk7XG59XG5jb25zdCBkZWZhdWx0U2Nyb2xsSW50ZW50ID0ge1xuICB4OiB7XG4gICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IGZhbHNlLFxuICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IGZhbHNlXG4gIH0sXG4gIHk6IHtcbiAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogZmFsc2UsXG4gICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gdXNlU2Nyb2xsSW50ZW50KF9yZWYyKSB7XG4gIGxldCB7XG4gICAgZGVsdGEsXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBwcmV2aW91c0RlbHRhID0gdXNlUHJldmlvdXMoZGVsdGEpO1xuICByZXR1cm4gdXNlTGF6eU1lbW8ocHJldmlvdXNJbnRlbnQgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcHJldmlvdXNEZWx0YSB8fCAhcHJldmlvdXNJbnRlbnQpIHtcbiAgICAgIC8vIFJlc2V0IHNjcm9sbCBpbnRlbnQgdHJhY2tpbmcgd2hlbiBhdXRvLXNjcm9sbGluZyBpcyBkaXNhYmxlZFxuICAgICAgcmV0dXJuIGRlZmF1bHRTY3JvbGxJbnRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0ge1xuICAgICAgeDogTWF0aC5zaWduKGRlbHRhLnggLSBwcmV2aW91c0RlbHRhLngpLFxuICAgICAgeTogTWF0aC5zaWduKGRlbHRhLnkgLSBwcmV2aW91c0RlbHRhLnkpXG4gICAgfTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgdXNlciBpbnRlbnQgdG8gc2Nyb2xsIGluIGVhY2ggZGlyZWN0aW9uIGZvciBib3RoIGF4aXNcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIFtEaXJlY3Rpb24uQmFja3dhcmRdOiBwcmV2aW91c0ludGVudC54W0RpcmVjdGlvbi5CYWNrd2FyZF0gfHwgZGlyZWN0aW9uLnggPT09IC0xLFxuICAgICAgICBbRGlyZWN0aW9uLkZvcndhcmRdOiBwcmV2aW91c0ludGVudC54W0RpcmVjdGlvbi5Gb3J3YXJkXSB8fCBkaXJlY3Rpb24ueCA9PT0gMVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IHByZXZpb3VzSW50ZW50LnlbRGlyZWN0aW9uLkJhY2t3YXJkXSB8fCBkaXJlY3Rpb24ueSA9PT0gLTEsXG4gICAgICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IHByZXZpb3VzSW50ZW50LnlbRGlyZWN0aW9uLkZvcndhcmRdIHx8IGRpcmVjdGlvbi55ID09PSAxXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkZWx0YSwgcHJldmlvdXNEZWx0YV0pO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZWROb2RlKGRyYWdnYWJsZU5vZGVzLCBpZCkge1xuICBjb25zdCBkcmFnZ2FibGVOb2RlID0gaWQgIT0gbnVsbCA/IGRyYWdnYWJsZU5vZGVzLmdldChpZCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5vZGUgPSBkcmFnZ2FibGVOb2RlID8gZHJhZ2dhYmxlTm9kZS5ub2RlLmN1cnJlbnQgOiBudWxsO1xuICByZXR1cm4gdXNlTGF6eU1lbW8oY2FjaGVkTm9kZSA9PiB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBJbiBzb21lIGNhc2VzLCB0aGUgZHJhZ2dhYmxlIG5vZGUgY2FuIHVubW91bnQgd2hpbGUgZHJhZ2dpbmdcbiAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIGZvciB2aXJ0dWFsaXplZCBsaXN0cy4gSW4gdGhvc2Ugc2l0dWF0aW9ucyxcbiAgICAvLyB3ZSBmYWxsIGJhY2sgdG8gdGhlIGxhc3Qga25vd24gdmFsdWUgZm9yIHRoYXQgbm9kZS5cblxuXG4gICAgcmV0dXJuIChfcmVmID0gbm9kZSAhPSBudWxsID8gbm9kZSA6IGNhY2hlZE5vZGUpICE9IG51bGwgPyBfcmVmIDogbnVsbDtcbiAgfSwgW25vZGUsIGlkXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbWJpbmVBY3RpdmF0b3JzKHNlbnNvcnMsIGdldFN5bnRoZXRpY0hhbmRsZXIpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gc2Vuc29ycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBzZW5zb3IpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzZW5zb3I6IFNlbnNvclxuICAgIH0gPSBzZW5zb3I7XG4gICAgY29uc3Qgc2Vuc29yQWN0aXZhdG9ycyA9IFNlbnNvci5hY3RpdmF0b3JzLm1hcChhY3RpdmF0b3IgPT4gKHtcbiAgICAgIGV2ZW50TmFtZTogYWN0aXZhdG9yLmV2ZW50TmFtZSxcbiAgICAgIGhhbmRsZXI6IGdldFN5bnRoZXRpY0hhbmRsZXIoYWN0aXZhdG9yLmhhbmRsZXIsIHNlbnNvcilcbiAgICB9KSk7XG4gICAgcmV0dXJuIFsuLi5hY2N1bXVsYXRvciwgLi4uc2Vuc29yQWN0aXZhdG9yc107XG4gIH0sIFtdKSwgW3NlbnNvcnMsIGdldFN5bnRoZXRpY0hhbmRsZXJdKTtcbn1cblxudmFyIE1lYXN1cmluZ1N0cmF0ZWd5O1xuXG4oZnVuY3Rpb24gKE1lYXN1cmluZ1N0cmF0ZWd5KSB7XG4gIE1lYXN1cmluZ1N0cmF0ZWd5W01lYXN1cmluZ1N0cmF0ZWd5W1wiQWx3YXlzXCJdID0gMF0gPSBcIkFsd2F5c1wiO1xuICBNZWFzdXJpbmdTdHJhdGVneVtNZWFzdXJpbmdTdHJhdGVneVtcIkJlZm9yZURyYWdnaW5nXCJdID0gMV0gPSBcIkJlZm9yZURyYWdnaW5nXCI7XG4gIE1lYXN1cmluZ1N0cmF0ZWd5W01lYXN1cmluZ1N0cmF0ZWd5W1wiV2hpbGVEcmFnZ2luZ1wiXSA9IDJdID0gXCJXaGlsZURyYWdnaW5nXCI7XG59KShNZWFzdXJpbmdTdHJhdGVneSB8fCAoTWVhc3VyaW5nU3RyYXRlZ3kgPSB7fSkpO1xuXG52YXIgTWVhc3VyaW5nRnJlcXVlbmN5O1xuXG4oZnVuY3Rpb24gKE1lYXN1cmluZ0ZyZXF1ZW5jeSkge1xuICBNZWFzdXJpbmdGcmVxdWVuY3lbXCJPcHRpbWl6ZWRcIl0gPSBcIm9wdGltaXplZFwiO1xufSkoTWVhc3VyaW5nRnJlcXVlbmN5IHx8IChNZWFzdXJpbmdGcmVxdWVuY3kgPSB7fSkpO1xuXG5jb25zdCBkZWZhdWx0VmFsdWUgPSAvKiNfX1BVUkVfXyovbmV3IE1hcCgpO1xuZnVuY3Rpb24gdXNlRHJvcHBhYmxlTWVhc3VyaW5nKGNvbnRhaW5lcnMsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkcmFnZ2luZyxcbiAgICBkZXBlbmRlbmNpZXMsXG4gICAgY29uZmlnXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbcXVldWUsIHNldFF1ZXVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCB7XG4gICAgZnJlcXVlbmN5LFxuICAgIG1lYXN1cmUsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgY29udGFpbmVyc1JlZiA9IHVzZVJlZihjb250YWluZXJzKTtcbiAgY29uc3QgZGlzYWJsZWQgPSBpc0Rpc2FibGVkKCk7XG4gIGNvbnN0IGRpc2FibGVkUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGlzYWJsZWQpO1xuICBjb25zdCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpZHMpIHtcbiAgICBpZiAoaWRzID09PSB2b2lkIDApIHtcbiAgICAgIGlkcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UXVldWUodmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZS5jb25jYXQoaWRzLmZpbHRlcihpZCA9PiAhdmFsdWUuaW5jbHVkZXMoaWQpKSk7XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZFJlZl0pO1xuICBjb25zdCB0aW1lb3V0SWQgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRyb3BwYWJsZVJlY3RzID0gdXNlTGF6eU1lbW8ocHJldmlvdXNWYWx1ZSA9PiB7XG4gICAgaWYgKGRpc2FibGVkICYmICFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXByZXZpb3VzVmFsdWUgfHwgcHJldmlvdXNWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlIHx8IGNvbnRhaW5lcnNSZWYuY3VycmVudCAhPT0gY29udGFpbmVycyB8fCBxdWV1ZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAgIGZvciAobGV0IGNvbnRhaW5lciBvZiBjb250YWluZXJzKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVldWUgJiYgcXVldWUubGVuZ3RoID4gMCAmJiAhcXVldWUuaW5jbHVkZXMoY29udGFpbmVyLmlkKSAmJiBjb250YWluZXIucmVjdC5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gVGhpcyBjb250YWluZXIgZG9lcyBub3QgbmVlZCB0byBiZSByZS1tZWFzdXJlZFxuICAgICAgICAgIG1hcC5zZXQoY29udGFpbmVyLmlkLCBjb250YWluZXIucmVjdC5jdXJyZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250YWluZXIubm9kZS5jdXJyZW50O1xuICAgICAgICBjb25zdCByZWN0ID0gbm9kZSA/IG5ldyBSZWN0KG1lYXN1cmUobm9kZSksIG5vZGUpIDogbnVsbDtcbiAgICAgICAgY29udGFpbmVyLnJlY3QuY3VycmVudCA9IHJlY3Q7XG5cbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICBtYXAuc2V0KGNvbnRhaW5lci5pZCwgcmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgfSwgW2NvbnRhaW5lcnMsIHF1ZXVlLCBkcmFnZ2luZywgZGlzYWJsZWQsIG1lYXN1cmVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb250YWluZXJzUmVmLmN1cnJlbnQgPSBjb250YWluZXJzO1xuICB9LCBbY29udGFpbmVyc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzKCk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2RyYWdnaW5nLCBkaXNhYmxlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChxdWV1ZSAmJiBxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRRdWV1ZShudWxsKTtcbiAgICB9XG4gIH0sIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbSlNPTi5zdHJpbmdpZnkocXVldWUpXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHR5cGVvZiBmcmVxdWVuY3kgIT09ICdudW1iZXInIHx8IHRpbWVvdXRJZC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltZW91dElkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzKCk7XG4gICAgICB0aW1lb3V0SWQuY3VycmVudCA9IG51bGw7XG4gICAgfSwgZnJlcXVlbmN5KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZnJlcXVlbmN5LCBkaXNhYmxlZCwgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsIC4uLmRlcGVuZGVuY2llc10pO1xuICByZXR1cm4ge1xuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ1NjaGVkdWxlZDogcXVldWUgIT0gbnVsbFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgY2FzZSBNZWFzdXJpbmdTdHJhdGVneS5BbHdheXM6XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSBNZWFzdXJpbmdTdHJhdGVneS5CZWZvcmVEcmFnZ2luZzpcbiAgICAgICAgcmV0dXJuIGRyYWdnaW5nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gIWRyYWdnaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VJbml0aWFsVmFsdWUodmFsdWUsIGNvbXB1dGVGbikge1xuICByZXR1cm4gdXNlTGF6eU1lbW8ocHJldmlvdXNWYWx1ZSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgY29tcHV0ZUZuID09PSAnZnVuY3Rpb24nID8gY29tcHV0ZUZuKHZhbHVlKSA6IHZhbHVlO1xuICB9LCBbY29tcHV0ZUZuLCB2YWx1ZV0pO1xufVxuXG5mdW5jdGlvbiB1c2VJbml0aWFsUmVjdChub2RlLCBtZWFzdXJlKSB7XG4gIHJldHVybiB1c2VJbml0aWFsVmFsdWUobm9kZSwgbWVhc3VyZSk7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IE11dGF0aW9uT2JzZXJ2ZXIgaW5zdGFuY2UuXHJcbiAqIElmIGBNdXRhdGlvbk9ic2VydmVyYCBpcyB1bmRlZmluZWQgaW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICovXG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoX3JlZikge1xuICBsZXQge1xuICAgIGNhbGxiYWNrLFxuICAgIGRpc2FibGVkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBoYW5kbGVNdXRhdGlvbnMgPSB1c2VFdmVudChjYWxsYmFjayk7XG4gIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBNdXRhdGlvbk9ic2VydmVyXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zKTtcbiAgfSwgW2hhbmRsZU11dGF0aW9ucywgZGlzYWJsZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFttdXRhdGlvbk9ic2VydmVyXSk7XG4gIHJldHVybiBtdXRhdGlvbk9ic2VydmVyO1xufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSBib3VuZCB0byB0aGUgYG9uUmVzaXplYCBjYWxsYmFjay5cclxuICogSWYgYFJlc2l6ZU9ic2VydmVyYCBpcyB1bmRlZmluZWQgaW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICovXG5cbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjYWxsYmFjayxcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjtcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gdXNlRXZlbnQoY2FsbGJhY2spO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LlJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBSZXNpemVPYnNlcnZlclxuICAgIH0gPSB3aW5kb3c7XG4gICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcihoYW5kbGVSZXNpemUpO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtkaXNhYmxlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbcmVzaXplT2JzZXJ2ZXJdKTtcbiAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0TWVhc3VyZShlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgUmVjdChnZXRDbGllbnRSZWN0KGVsZW1lbnQpLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjdChlbGVtZW50LCBtZWFzdXJlLCBmYWxsYmFja1JlY3QpIHtcbiAgaWYgKG1lYXN1cmUgPT09IHZvaWQgMCkge1xuICAgIG1lYXN1cmUgPSBkZWZhdWx0TWVhc3VyZTtcbiAgfVxuXG4gIGNvbnN0IFtyZWN0LCBzZXRSZWN0XSA9IHVzZVN0YXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIG1lYXN1cmVSZWN0KCkge1xuICAgIHNldFJlY3QoY3VycmVudFJlY3QgPT4ge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIF9yZWY7XG5cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGxhc3QgcmVjdCB3ZSBtZWFzdXJlZCBpZiB0aGUgZWxlbWVudCBpc1xuICAgICAgICAvLyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBET00uXG4gICAgICAgIHJldHVybiAoX3JlZiA9IGN1cnJlbnRSZWN0ICE9IG51bGwgPyBjdXJyZW50UmVjdCA6IGZhbGxiYWNrUmVjdCkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdSZWN0ID0gbWVhc3VyZShlbGVtZW50KTtcblxuICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGN1cnJlbnRSZWN0KSA9PT0gSlNPTi5zdHJpbmdpZnkobmV3UmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZWN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3UmVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSB1c2VNdXRhdGlvbk9ic2VydmVyKHtcbiAgICBjYWxsYmFjayhyZWNvcmRzKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9ID0gcmVjb3JkO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hpbGRMaXN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgICBtZWFzdXJlUmVjdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogbWVhc3VyZVJlY3RcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1lYXN1cmVSZWN0KCk7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9LCBbZWxlbWVudF0pO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gdXNlUmVjdERlbHRhKHJlY3QpIHtcbiAgY29uc3QgaW5pdGlhbFJlY3QgPSB1c2VJbml0aWFsVmFsdWUocmVjdCk7XG4gIHJldHVybiBnZXRSZWN0RGVsdGEocmVjdCwgaW5pdGlhbFJlY3QpO1xufVxuXG5jb25zdCBkZWZhdWx0VmFsdWUkMSA9IFtdO1xuZnVuY3Rpb24gdXNlU2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IHVzZVJlZihub2RlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gdXNlTGF6eU1lbW8ocHJldmlvdXNWYWx1ZSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlJDE7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZSAhPT0gZGVmYXVsdFZhbHVlJDEgJiYgbm9kZSAmJiBwcmV2aW91c05vZGUuY3VycmVudCAmJiBub2RlLnBhcmVudE5vZGUgPT09IHByZXZpb3VzTm9kZS5jdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpO1xuICB9LCBbbm9kZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZpb3VzTm9kZS5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW25vZGVdKTtcbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gdXNlU2Nyb2xsT2Zmc2V0cyhlbGVtZW50cykge1xuICBjb25zdCBbc2Nyb2xsQ29vcmRpbmF0ZXMsIHNldFNjcm9sbENvb3JkaW5hdGVzXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBwcmV2RWxlbWVudHMgPSB1c2VSZWYoZWxlbWVudHMpOyAvLyBUby1kbzogVGhyb3R0bGUgdGhlIGhhbmRsZVNjcm9sbCBjYWxsYmFja1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBjb25zdCBzY3JvbGxpbmdFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcblxuICAgIGlmICghc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbENvb3JkaW5hdGVzID0+IHtcbiAgICAgIGlmICghc2Nyb2xsQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNjcm9sbENvb3JkaW5hdGVzLnNldChzY3JvbGxpbmdFbGVtZW50LCBnZXRTY3JvbGxDb29yZGluYXRlcyhzY3JvbGxpbmdFbGVtZW50KSk7XG4gICAgICByZXR1cm4gbmV3IE1hcChzY3JvbGxDb29yZGluYXRlcyk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c0VsZW1lbnRzID0gcHJldkVsZW1lbnRzLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWxlbWVudHMgIT09IHByZXZpb3VzRWxlbWVudHMpIHtcbiAgICAgIGNsZWFudXAocHJldmlvdXNFbGVtZW50cyk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgICAgICAgIHNjcm9sbGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBbc2Nyb2xsYWJsZUVsZW1lbnQsIGdldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbGFibGVFbGVtZW50KV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pLmZpbHRlcihlbnRyeSA9PiBlbnRyeSAhPSBudWxsKTtcbiAgICAgIHNldFNjcm9sbENvb3JkaW5hdGVzKGVudHJpZXMubGVuZ3RoID8gbmV3IE1hcChlbnRyaWVzKSA6IG51bGwpO1xuICAgICAgcHJldkVsZW1lbnRzLmN1cnJlbnQgPSBlbGVtZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChlbGVtZW50cyk7XG4gICAgICBjbGVhbnVwKHByZXZpb3VzRWxlbWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsYWJsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2hhbmRsZVNjcm9sbCwgZWxlbWVudHNdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzY3JvbGxDb29yZGluYXRlcyA/IEFycmF5LmZyb20oc2Nyb2xsQ29vcmRpbmF0ZXMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBjb29yZGluYXRlcykgPT4gYWRkKGFjYywgY29vcmRpbmF0ZXMpLCBkZWZhdWx0Q29vcmRpbmF0ZXMpIDogZ2V0U2Nyb2xsT2Zmc2V0cyhlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRDb29yZGluYXRlcztcbiAgfSwgW2VsZW1lbnRzLCBzY3JvbGxDb29yZGluYXRlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JvbGxPZmZzZXRzRGVsdGEoc2Nyb2xsT2Zmc2V0cywgZGVwZW5kZW5jaWVzKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICB9XG5cbiAgY29uc3QgaW5pdGlhbFNjcm9sbE9mZnNldHMgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCA9IG51bGw7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwZW5kZW5jaWVzKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYXNTY3JvbGxPZmZzZXRzID0gc2Nyb2xsT2Zmc2V0cyAhPT0gZGVmYXVsdENvb3JkaW5hdGVzO1xuXG4gICAgaWYgKGhhc1Njcm9sbE9mZnNldHMgJiYgIWluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPSBzY3JvbGxPZmZzZXRzO1xuICAgIH1cblxuICAgIGlmICghaGFzU2Nyb2xsT2Zmc2V0cyAmJiBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzY3JvbGxPZmZzZXRzXSk7XG4gIHJldHVybiBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID8gc3VidHJhY3Qoc2Nyb2xsT2Zmc2V0cywgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCkgOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG59XG5cbmZ1bmN0aW9uIHVzZVNlbnNvclNldHVwKHNlbnNvcnMpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhblVzZURPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRlYXJkb3duRm5zID0gc2Vuc29ycy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBzZW5zb3JcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHNlbnNvci5zZXR1cCA9PSBudWxsID8gdm9pZCAwIDogc2Vuc29yLnNldHVwKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdGVhcmRvd24gb2YgdGVhcmRvd25GbnMpIHtcbiAgICAgICAgdGVhcmRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IHRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gVE8tRE86IFNlbnNvcnMgbGVuZ3RoIGNvdWxkIHRoZW9yZXRpY2FsbHkgY2hhbmdlIHdoaWNoIHdvdWxkIG5vdCBiZSBhIHZhbGlkIGRlcGVuZGVuY3lcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBzZW5zb3JzLm1hcChfcmVmMiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNlbnNvclxuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4gc2Vuc29yO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bnRoZXRpY0xpc3RlbmVycyhsaXN0ZW5lcnMsIGlkKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gbGlzdGVuZXJzLnJlZHVjZSgoYWNjLCBfcmVmKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIGhhbmRsZXJcbiAgICAgIH0gPSBfcmVmO1xuXG4gICAgICBhY2NbZXZlbnROYW1lXSA9IGV2ZW50ID0+IHtcbiAgICAgICAgaGFuZGxlcihldmVudCwgaWQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH0sIFtsaXN0ZW5lcnMsIGlkXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1JlY3QoZWxlbWVudCkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBlbGVtZW50ID8gZ2V0V2luZG93Q2xpZW50UmVjdChlbGVtZW50KSA6IG51bGwsIFtlbGVtZW50XSk7XG59XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSQyID0gW107XG5mdW5jdGlvbiB1c2VSZWN0cyhlbGVtZW50cywgbWVhc3VyZSkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGdldENsaWVudFJlY3Q7XG4gIH1cblxuICBjb25zdCBbZmlyc3RFbGVtZW50XSA9IGVsZW1lbnRzO1xuICBjb25zdCB3aW5kb3dSZWN0ID0gdXNlV2luZG93UmVjdChmaXJzdEVsZW1lbnQgPyBnZXRXaW5kb3coZmlyc3RFbGVtZW50KSA6IG51bGwpO1xuICBjb25zdCBbcmVjdHMsIHNldFJlY3RzXSA9IHVzZVN0YXRlKGRlZmF1bHRWYWx1ZSQyKTtcblxuICBmdW5jdGlvbiBtZWFzdXJlUmVjdHMoKSB7XG4gICAgc2V0UmVjdHMoKCkgPT4ge1xuICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSQyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gaXNEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCkgPyB3aW5kb3dSZWN0IDogbmV3IFJlY3QobWVhc3VyZShlbGVtZW50KSwgZWxlbWVudCkpO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IG1lYXN1cmVSZWN0c1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBtZWFzdXJlUmVjdHMoKTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCkpO1xuICB9LCBbZWxlbWVudHNdKTtcbiAgcmV0dXJuIHJlY3RzO1xufVxuXG5mdW5jdGlvbiBnZXRNZWFzdXJhYmxlTm9kZShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGZpcnN0Q2hpbGQpID8gZmlyc3RDaGlsZCA6IG5vZGU7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdPdmVybGF5TWVhc3VyaW5nKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBtZWFzdXJlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbcmVjdCwgc2V0UmVjdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gdXNlQ2FsbGJhY2soZW50cmllcyA9PiB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9IG9mIGVudHJpZXMpIHtcbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgc2V0UmVjdChyZWN0ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdSZWN0ID0gbWVhc3VyZSh0YXJnZXQpO1xuICAgICAgICAgIHJldHVybiByZWN0ID8geyAuLi5yZWN0LFxuICAgICAgICAgICAgd2lkdGg6IG5ld1JlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5ld1JlY3QuaGVpZ2h0XG4gICAgICAgICAgfSA6IG5ld1JlY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIFttZWFzdXJlXSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrOiBoYW5kbGVSZXNpemVcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZU5vZGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhlbGVtZW50ID0+IHtcbiAgICBjb25zdCBub2RlID0gZ2V0TWVhc3VyYWJsZU5vZGUoZWxlbWVudCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShub2RlKTtcbiAgICB9XG5cbiAgICBzZXRSZWN0KG5vZGUgPyBtZWFzdXJlKG5vZGUpIDogbnVsbCk7XG4gIH0sIFttZWFzdXJlLCByZXNpemVPYnNlcnZlcl0pO1xuICBjb25zdCBbbm9kZVJlZiwgc2V0UmVmXSA9IHVzZU5vZGVSZWYoaGFuZGxlTm9kZUNoYW5nZSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgbm9kZVJlZixcbiAgICByZWN0LFxuICAgIHNldFJlZlxuICB9KSwgW3JlY3QsIG5vZGVSZWYsIHNldFJlZl0pO1xufVxuXG5jb25zdCBkZWZhdWx0U2Vuc29ycyA9IFt7XG4gIHNlbnNvcjogUG9pbnRlclNlbnNvcixcbiAgb3B0aW9uczoge31cbn0sIHtcbiAgc2Vuc29yOiBLZXlib2FyZFNlbnNvcixcbiAgb3B0aW9uczoge31cbn1dO1xuY29uc3QgZGVmYXVsdERhdGEgPSB7XG4gIGN1cnJlbnQ6IHt9XG59O1xuY29uc3QgZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24gPSB7XG4gIGRyYWdnYWJsZToge1xuICAgIG1lYXN1cmU6IGdldFRyYW5zZm9ybUFnbm9zdGljQ2xpZW50UmVjdFxuICB9LFxuICBkcm9wcGFibGU6IHtcbiAgICBtZWFzdXJlOiBnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QsXG4gICAgc3RyYXRlZ3k6IE1lYXN1cmluZ1N0cmF0ZWd5LldoaWxlRHJhZ2dpbmcsXG4gICAgZnJlcXVlbmN5OiBNZWFzdXJpbmdGcmVxdWVuY3kuT3B0aW1pemVkXG4gIH0sXG4gIGRyYWdPdmVybGF5OiB7XG4gICAgbWVhc3VyZTogZ2V0Q2xpZW50UmVjdFxuICB9XG59O1xuXG5jbGFzcyBEcm9wcGFibGVDb250YWluZXJzTWFwIGV4dGVuZHMgTWFwIHtcbiAgZ2V0KGlkKSB7XG4gICAgdmFyIF9zdXBlciRnZXQ7XG5cbiAgICByZXR1cm4gaWQgIT0gbnVsbCA/IChfc3VwZXIkZ2V0ID0gc3VwZXIuZ2V0KGlkKSkgIT0gbnVsbCA/IF9zdXBlciRnZXQgOiB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpO1xuICB9XG5cbiAgZ2V0RW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmlsdGVyKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZGlzYWJsZWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuICFkaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGdldE5vZGVGb3IoaWQpIHtcbiAgICB2YXIgX3RoaXMkZ2V0JG5vZGUkY3VycmVuLCBfdGhpcyRnZXQ7XG5cbiAgICByZXR1cm4gKF90aGlzJGdldCRub2RlJGN1cnJlbiA9IChfdGhpcyRnZXQgPSB0aGlzLmdldChpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXQubm9kZS5jdXJyZW50KSAhPSBudWxsID8gX3RoaXMkZ2V0JG5vZGUkY3VycmVuIDogdW5kZWZpbmVkO1xuICB9XG5cbn1cblxuY29uc3QgZGVmYXVsdFB1YmxpY0NvbnRleHQgPSB7XG4gIGFjdGl2YXRvckV2ZW50OiBudWxsLFxuICBhY3RpdmU6IG51bGwsXG4gIGFjdGl2ZU5vZGU6IG51bGwsXG4gIGFjdGl2ZU5vZGVSZWN0OiBudWxsLFxuICBjb2xsaXNpb25zOiBudWxsLFxuICBjb250YWluZXJOb2RlUmVjdDogbnVsbCxcbiAgZHJhZ2dhYmxlTm9kZXM6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGRyb3BwYWJsZVJlY3RzOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBkcm9wcGFibGVDb250YWluZXJzOiAvKiNfX1BVUkVfXyovbmV3IERyb3BwYWJsZUNvbnRhaW5lcnNNYXAoKSxcbiAgb3ZlcjogbnVsbCxcbiAgZHJhZ092ZXJsYXk6IHtcbiAgICBub2RlUmVmOiB7XG4gICAgICBjdXJyZW50OiBudWxsXG4gICAgfSxcbiAgICByZWN0OiBudWxsLFxuICAgIHNldFJlZjogbm9vcFxuICB9LFxuICBzY3JvbGxhYmxlQW5jZXN0b3JzOiBbXSxcbiAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHM6IFtdLFxuICBtZWFzdXJpbmdDb25maWd1cmF0aW9uOiBkZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnM6IG5vb3AsXG4gIHdpbmRvd1JlY3Q6IG51bGwsXG4gIG1lYXN1cmluZ1NjaGVkdWxlZDogZmFsc2Vcbn07XG5jb25zdCBkZWZhdWx0SW50ZXJuYWxDb250ZXh0ID0ge1xuICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgYWN0aXZhdG9yczogW10sXG4gIGFjdGl2ZTogbnVsbCxcbiAgYWN0aXZlTm9kZVJlY3Q6IG51bGwsXG4gIGFyaWFEZXNjcmliZWRCeUlkOiB7XG4gICAgZHJhZ2dhYmxlOiAnJ1xuICB9LFxuICBkaXNwYXRjaDogbm9vcCxcbiAgZHJhZ2dhYmxlTm9kZXM6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIG92ZXI6IG51bGwsXG4gIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzOiBub29wXG59O1xuY29uc3QgSW50ZXJuYWxDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZGVmYXVsdEludGVybmFsQ29udGV4dCk7XG5jb25zdCBQdWJsaWNDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZGVmYXVsdFB1YmxpY0NvbnRleHQpO1xuXG5mdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiB7XG4gICAgICBhY3RpdmU6IG51bGwsXG4gICAgICBpbml0aWFsQ29vcmRpbmF0ZXM6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIG5vZGVzOiBuZXcgTWFwKCksXG4gICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcHBhYmxlOiB7XG4gICAgICBjb250YWluZXJzOiBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcCgpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIEFjdGlvbi5EcmFnU3RhcnQ6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXM6IGFjdGlvbi5pbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgYWN0aXZlOiBhY3Rpb24uYWN0aXZlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIEFjdGlvbi5EcmFnTW92ZTpcbiAgICAgIGlmIChzdGF0ZS5kcmFnZ2FibGUuYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi5jb29yZGluYXRlcy54IC0gc3RhdGUuZHJhZ2dhYmxlLmluaXRpYWxDb29yZGluYXRlcy54LFxuICAgICAgICAgICAgeTogYWN0aW9uLmNvb3JkaW5hdGVzLnkgLSBzdGF0ZS5kcmFnZ2FibGUuaW5pdGlhbENvb3JkaW5hdGVzLnlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIEFjdGlvbi5EcmFnRW5kOlxuICAgIGNhc2UgQWN0aW9uLkRyYWdDYW5jZWw6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICBhY3RpdmU6IG51bGwsXG4gICAgICAgICAgaW5pdGlhbENvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgQWN0aW9uLlJlZ2lzdGVyRHJvcHBhYmxlOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZWxlbWVudFxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuc2V0KGlkLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlIEFjdGlvbi5TZXREcm9wcGFibGVEaXNhYmxlZDpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZHJvcHBhYmxlLmNvbnRhaW5lcnMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwga2V5ICE9PSBlbGVtZW50LmtleSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuc2V0KGlkLCB7IC4uLmVsZW1lbnQsXG4gICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgIGRyb3BwYWJsZTogeyAuLi5zdGF0ZS5kcm9wcGFibGUsXG4gICAgICAgICAgICBjb250YWluZXJzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBBY3Rpb24uVW5yZWdpc3RlckRyb3BwYWJsZTpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGtleVxuICAgICAgICB9ID0gYWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZHJvcHBhYmxlLmNvbnRhaW5lcnMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwga2V5ICE9PSBlbGVtZW50LmtleSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcChzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycyk7XG4gICAgICAgIGNvbnRhaW5lcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVzdG9yZUZvY3VzKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBkcmFnZ2FibGVOb2Rlc1xuICB9ID0gdXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2YXRvckV2ZW50ID0gdXNlUHJldmlvdXMoYWN0aXZhdG9yRXZlbnQpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUlkID0gdXNlUHJldmlvdXMoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpOyAvLyBSZXN0b3JlIGtleWJvYXJkIGZvY3VzIG9uIHRoZSBhY3RpdmF0b3Igbm9kZVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmF0b3JFdmVudCAmJiBwcmV2aW91c0FjdGl2YXRvckV2ZW50ICYmIHByZXZpb3VzQWN0aXZlSWQgIT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0tleWJvYXJkRXZlbnQocHJldmlvdXNBY3RpdmF0b3JFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gcHJldmlvdXNBY3RpdmF0b3JFdmVudC50YXJnZXQpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byByZXN0b3JlIGZvY3VzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHJhZ2dhYmxlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChwcmV2aW91c0FjdGl2ZUlkKTtcblxuICAgICAgaWYgKCFkcmFnZ2FibGVOb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmF0b3JOb2RlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gZHJhZ2dhYmxlTm9kZTtcblxuICAgICAgaWYgKCFhY3RpdmF0b3JOb2RlLmN1cnJlbnQgJiYgIW5vZGUuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbYWN0aXZhdG9yTm9kZS5jdXJyZW50LCBub2RlLmN1cnJlbnRdKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmb2N1c2FibGVOb2RlID0gZmluZEZpcnN0Rm9jdXNhYmxlTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChmb2N1c2FibGVOb2RlKSB7XG4gICAgICAgICAgICBmb2N1c2FibGVOb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2FjdGl2YXRvckV2ZW50LCBkaXNhYmxlZCwgZHJhZ2dhYmxlTm9kZXMsIHByZXZpb3VzQWN0aXZlSWQsIHByZXZpb3VzQWN0aXZhdG9yRXZlbnRdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywgX3JlZikge1xuICBsZXQge1xuICAgIHRyYW5zZm9ybSxcbiAgICAuLi5hcmdzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gbW9kaWZpZXJzICE9IG51bGwgJiYgbW9kaWZpZXJzLmxlbmd0aCA/IG1vZGlmaWVycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBtb2RpZmllcikgPT4ge1xuICAgIHJldHVybiBtb2RpZmllcih7XG4gICAgICB0cmFuc2Zvcm06IGFjY3VtdWxhdG9yLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICB9LCB0cmFuc2Zvcm0pIDogdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiB1c2VNZWFzdXJpbmdDb25maWd1cmF0aW9uKGNvbmZpZykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnYWJsZTogeyAuLi5kZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUsXG4gICAgICAuLi4oY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJhZ2dhYmxlKVxuICAgIH0sXG4gICAgZHJvcHBhYmxlOiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyb3BwYWJsZSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcm9wcGFibGUpXG4gICAgfSxcbiAgICBkcmFnT3ZlcmxheTogeyAuLi5kZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnT3ZlcmxheSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnT3ZlcmxheSlcbiAgICB9XG4gIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnZ2FibGUsIGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyb3BwYWJsZSwgY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJhZ092ZXJsYXldKTtcbn1cblxuZnVuY3Rpb24gdXNlTGF5b3V0U2hpZnRTY3JvbGxDb21wZW5zYXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIGFjdGl2ZU5vZGUsXG4gICAgbWVhc3VyZSxcbiAgICBpbml0aWFsUmVjdCxcbiAgICBjb25maWcgPSB0cnVlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHR5cGVvZiBjb25maWcgPT09ICdib29sZWFuJyA/IHtcbiAgICB4OiBjb25maWcsXG4gICAgeTogY29uZmlnXG4gIH0gOiBjb25maWc7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGRpc2FibGVkID0gIXggJiYgIXk7XG5cbiAgICBpZiAoZGlzYWJsZWQgfHwgIWFjdGl2ZU5vZGUpIHtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCB8fCAhaW5pdGlhbFJlY3QpIHtcbiAgICAgIC8vIFJldHVybiBlYXJseSBpZiBsYXlvdXQgc2hpZnQgc2Nyb2xsIGNvbXBlbnNhdGlvbiB3YXMgYWxyZWFkeSBhdHRlbXB0ZWRcbiAgICAgIC8vIG9yIGlmIHRoZXJlIGlzIG5vIGluaXRpYWxSZWN0IHRvIGNvbXBhcmUgdG8uXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIG1vc3QgdXAgdG8gZGF0ZSBub2RlIHJlZiBmb3IgdGhlIGFjdGl2ZSBkcmFnZ2FibGVcblxuXG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZU5vZGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaXNDb25uZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgbm9kZSByZWYgb3IgaWYgdGhlIG5vZGUgaXNcbiAgICAgIC8vIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWN0ID0gbWVhc3VyZShub2RlKTtcbiAgICBjb25zdCByZWN0RGVsdGEgPSBnZXRSZWN0RGVsdGEocmVjdCwgaW5pdGlhbFJlY3QpO1xuXG4gICAgaWYgKCF4KSB7XG4gICAgICByZWN0RGVsdGEueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCF5KSB7XG4gICAgICByZWN0RGVsdGEueSA9IDA7XG4gICAgfSAvLyBPbmx5IHBlcmZvcm0gbGF5b3V0IHNoaWZ0IHNjcm9sbCBjb21wZW5zYXRpb24gb25jZVxuXG5cbiAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcblxuICAgIGlmIChNYXRoLmFicyhyZWN0RGVsdGEueCkgPiAwIHx8IE1hdGguYWJzKHJlY3REZWx0YS55KSA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3Iobm9kZSk7XG5cbiAgICAgIGlmIChmaXJzdFNjcm9sbGFibGVBbmNlc3Rvcikge1xuICAgICAgICBmaXJzdFNjcm9sbGFibGVBbmNlc3Rvci5zY3JvbGxCeSh7XG4gICAgICAgICAgdG9wOiByZWN0RGVsdGEueSxcbiAgICAgICAgICBsZWZ0OiByZWN0RGVsdGEueFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFthY3RpdmVOb2RlLCB4LCB5LCBpbml0aWFsUmVjdCwgbWVhc3VyZV0pO1xufVxuXG5jb25zdCBBY3RpdmVEcmFnZ2FibGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoeyAuLi5kZWZhdWx0Q29vcmRpbmF0ZXMsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59KTtcbnZhciBTdGF0dXM7XG5cbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gIFN0YXR1c1tTdGF0dXNbXCJVbmluaXRpYWxpemVkXCJdID0gMF0gPSBcIlVuaW5pdGlhbGl6ZWRcIjtcbiAgU3RhdHVzW1N0YXR1c1tcIkluaXRpYWxpemluZ1wiXSA9IDFdID0gXCJJbml0aWFsaXppbmdcIjtcbiAgU3RhdHVzW1N0YXR1c1tcIkluaXRpYWxpemVkXCJdID0gMl0gPSBcIkluaXRpYWxpemVkXCI7XG59KShTdGF0dXMgfHwgKFN0YXR1cyA9IHt9KSk7XG5cbmNvbnN0IERuZENvbnRleHQgPSAvKiNfX1BVUkVfXyovbWVtbyhmdW5jdGlvbiBEbmRDb250ZXh0KF9yZWYpIHtcbiAgdmFyIF9zZW5zb3JDb250ZXh0JGN1cnJlbiwgX2RyYWdPdmVybGF5JG5vZGVSZWYkLCBfZHJhZ092ZXJsYXkkcmVjdCwgX292ZXIkcmVjdDtcblxuICBsZXQge1xuICAgIGlkLFxuICAgIGFjY2Vzc2liaWxpdHksXG4gICAgYXV0b1Njcm9sbCA9IHRydWUsXG4gICAgY2hpbGRyZW4sXG4gICAgc2Vuc29ycyA9IGRlZmF1bHRTZW5zb3JzLFxuICAgIGNvbGxpc2lvbkRldGVjdGlvbiA9IHJlY3RJbnRlcnNlY3Rpb24sXG4gICAgbWVhc3VyaW5nLFxuICAgIG1vZGlmaWVycyxcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc3RvcmUgPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIHVuZGVmaW5lZCwgZ2V0SW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSBzdG9yZTtcbiAgY29uc3QgW2Rpc3BhdGNoTW9uaXRvckV2ZW50LCByZWdpc3Rlck1vbml0b3JMaXN0ZW5lcl0gPSB1c2VEbmRNb25pdG9yUHJvdmlkZXIoKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKFN0YXR1cy5VbmluaXRpYWxpemVkKTtcbiAgY29uc3QgaXNJbml0aWFsaXplZCA9IHN0YXR1cyA9PT0gU3RhdHVzLkluaXRpYWxpemVkO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlOiB7XG4gICAgICBhY3RpdmU6IGFjdGl2ZUlkLFxuICAgICAgbm9kZXM6IGRyYWdnYWJsZU5vZGVzLFxuICAgICAgdHJhbnNsYXRlXG4gICAgfSxcbiAgICBkcm9wcGFibGU6IHtcbiAgICAgIGNvbnRhaW5lcnM6IGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgICB9XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qgbm9kZSA9IGFjdGl2ZUlkICE9IG51bGwgPyBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlSWQpIDogbnVsbDtcbiAgY29uc3QgYWN0aXZlUmVjdHMgPSB1c2VSZWYoe1xuICAgIGluaXRpYWw6IG51bGwsXG4gICAgdHJhbnNsYXRlZDogbnVsbFxuICB9KTtcbiAgY29uc3QgYWN0aXZlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9ub2RlJGRhdGE7XG5cbiAgICByZXR1cm4gYWN0aXZlSWQgIT0gbnVsbCA/IHtcbiAgICAgIGlkOiBhY3RpdmVJZCxcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgZm9yIHRoZSBhY3RpdmUgbm9kZSB0byB1bm1vdW50IHdoaWxlIGRyYWdnaW5nXG4gICAgICBkYXRhOiAoX25vZGUkZGF0YSA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUuZGF0YSkgIT0gbnVsbCA/IF9ub2RlJGRhdGEgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHJlY3Q6IGFjdGl2ZVJlY3RzXG4gICAgfSA6IG51bGw7XG4gIH0sIFthY3RpdmVJZCwgbm9kZV0pO1xuICBjb25zdCBhY3RpdmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFthY3RpdmVTZW5zb3IsIHNldEFjdGl2ZVNlbnNvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2FjdGl2YXRvckV2ZW50LCBzZXRBY3RpdmF0b3JFdmVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgbGF0ZXN0UHJvcHMgPSB1c2VMYXRlc3RWYWx1ZShwcm9wcywgT2JqZWN0LnZhbHVlcyhwcm9wcykpO1xuICBjb25zdCBkcmFnZ2FibGVEZXNjcmliZWRCeUlkID0gdXNlVW5pcXVlSWQoXCJEbmREZXNjcmliZWRCeVwiLCBpZCk7XG4gIGNvbnN0IGVuYWJsZWREcm9wcGFibGVDb250YWluZXJzID0gdXNlTWVtbygoKSA9PiBkcm9wcGFibGVDb250YWluZXJzLmdldEVuYWJsZWQoKSwgW2Ryb3BwYWJsZUNvbnRhaW5lcnNdKTtcbiAgY29uc3QgbWVhc3VyaW5nQ29uZmlndXJhdGlvbiA9IHVzZU1lYXN1cmluZ0NvbmZpZ3VyYXRpb24obWVhc3VyaW5nKTtcbiAgY29uc3Qge1xuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ1NjaGVkdWxlZFxuICB9ID0gdXNlRHJvcHBhYmxlTWVhc3VyaW5nKGVuYWJsZWREcm9wcGFibGVDb250YWluZXJzLCB7XG4gICAgZHJhZ2dpbmc6IGlzSW5pdGlhbGl6ZWQsXG4gICAgZGVwZW5kZW5jaWVzOiBbdHJhbnNsYXRlLngsIHRyYW5zbGF0ZS55XSxcbiAgICBjb25maWc6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJvcHBhYmxlXG4gIH0pO1xuICBjb25zdCBhY3RpdmVOb2RlID0gdXNlQ2FjaGVkTm9kZShkcmFnZ2FibGVOb2RlcywgYWN0aXZlSWQpO1xuICBjb25zdCBhY3RpdmF0aW9uQ29vcmRpbmF0ZXMgPSB1c2VNZW1vKCgpID0+IGFjdGl2YXRvckV2ZW50ID8gZ2V0RXZlbnRDb29yZGluYXRlcyhhY3RpdmF0b3JFdmVudCkgOiBudWxsLCBbYWN0aXZhdG9yRXZlbnRdKTtcbiAgY29uc3QgYXV0b1Njcm9sbE9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IGluaXRpYWxBY3RpdmVOb2RlUmVjdCA9IHVzZUluaXRpYWxSZWN0KGFjdGl2ZU5vZGUsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUpO1xuICB1c2VMYXlvdXRTaGlmdFNjcm9sbENvbXBlbnNhdGlvbih7XG4gICAgYWN0aXZlTm9kZTogYWN0aXZlSWQgIT0gbnVsbCA/IGRyYWdnYWJsZU5vZGVzLmdldChhY3RpdmVJZCkgOiBudWxsLFxuICAgIGNvbmZpZzogYXV0b1Njcm9sbE9wdGlvbnMubGF5b3V0U2hpZnRDb21wZW5zYXRpb24sXG4gICAgaW5pdGlhbFJlY3Q6IGluaXRpYWxBY3RpdmVOb2RlUmVjdCxcbiAgICBtZWFzdXJlOiBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlXG4gIH0pO1xuICBjb25zdCBhY3RpdmVOb2RlUmVjdCA9IHVzZVJlY3QoYWN0aXZlTm9kZSwgbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUubWVhc3VyZSwgaW5pdGlhbEFjdGl2ZU5vZGVSZWN0KTtcbiAgY29uc3QgY29udGFpbmVyTm9kZVJlY3QgPSB1c2VSZWN0KGFjdGl2ZU5vZGUgPyBhY3RpdmVOb2RlLnBhcmVudEVsZW1lbnQgOiBudWxsKTtcbiAgY29uc3Qgc2Vuc29yQ29udGV4dCA9IHVzZVJlZih7XG4gICAgYWN0aXZhdG9yRXZlbnQ6IG51bGwsXG4gICAgYWN0aXZlOiBudWxsLFxuICAgIGFjdGl2ZU5vZGUsXG4gICAgY29sbGlzaW9uUmVjdDogbnVsbCxcbiAgICBjb2xsaXNpb25zOiBudWxsLFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyYWdnaW5nTm9kZTogbnVsbCxcbiAgICBkcmFnZ2luZ05vZGVSZWN0OiBudWxsLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgb3ZlcjogbnVsbCxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JzOiBbXSxcbiAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZTogbnVsbFxuICB9KTtcbiAgY29uc3Qgb3Zlck5vZGUgPSBkcm9wcGFibGVDb250YWluZXJzLmdldE5vZGVGb3IoKF9zZW5zb3JDb250ZXh0JGN1cnJlbiA9IHNlbnNvckNvbnRleHQuY3VycmVudC5vdmVyKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbnNvckNvbnRleHQkY3VycmVuLmlkKTtcbiAgY29uc3QgZHJhZ092ZXJsYXkgPSB1c2VEcmFnT3ZlcmxheU1lYXN1cmluZyh7XG4gICAgbWVhc3VyZTogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnT3ZlcmxheS5tZWFzdXJlXG4gIH0pOyAvLyBVc2UgdGhlIHJlY3Qgb2YgdGhlIGRyYWcgb3ZlcmxheSBpZiBpdCBpcyBtb3VudGVkXG5cbiAgY29uc3QgZHJhZ2dpbmdOb2RlID0gKF9kcmFnT3ZlcmxheSRub2RlUmVmJCA9IGRyYWdPdmVybGF5Lm5vZGVSZWYuY3VycmVudCkgIT0gbnVsbCA/IF9kcmFnT3ZlcmxheSRub2RlUmVmJCA6IGFjdGl2ZU5vZGU7XG4gIGNvbnN0IGRyYWdnaW5nTm9kZVJlY3QgPSBpc0luaXRpYWxpemVkID8gKF9kcmFnT3ZlcmxheSRyZWN0ID0gZHJhZ092ZXJsYXkucmVjdCkgIT0gbnVsbCA/IF9kcmFnT3ZlcmxheSRyZWN0IDogYWN0aXZlTm9kZVJlY3QgOiBudWxsO1xuICBjb25zdCB1c2VzRHJhZ092ZXJsYXkgPSBCb29sZWFuKGRyYWdPdmVybGF5Lm5vZGVSZWYuY3VycmVudCAmJiBkcmFnT3ZlcmxheS5yZWN0KTsgLy8gVGhlIGRlbHRhIGJldHdlZW4gdGhlIHByZXZpb3VzIGFuZCBuZXcgcG9zaXRpb24gb2YgdGhlIGRyYWdnYWJsZSBub2RlXG4gIC8vIGlzIG9ubHkgcmVsZXZhbnQgd2hlbiB0aGVyZSBpcyBubyBkcmFnIG92ZXJsYXlcblxuICBjb25zdCBub2RlUmVjdERlbHRhID0gdXNlUmVjdERlbHRhKHVzZXNEcmFnT3ZlcmxheSA/IG51bGwgOiBhY3RpdmVOb2RlUmVjdCk7IC8vIEdldCB0aGUgd2luZG93IHJlY3Qgb2YgdGhlIGRyYWdnaW5nIG5vZGVcblxuICBjb25zdCB3aW5kb3dSZWN0ID0gdXNlV2luZG93UmVjdChkcmFnZ2luZ05vZGUgPyBnZXRXaW5kb3coZHJhZ2dpbmdOb2RlKSA6IG51bGwpOyAvLyBHZXQgc2Nyb2xsYWJsZSBhbmNlc3RvcnMgb2YgdGhlIGRyYWdnaW5nIG5vZGVcblxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3JzID0gdXNlU2Nyb2xsYWJsZUFuY2VzdG9ycyhpc0luaXRpYWxpemVkID8gb3Zlck5vZGUgIT0gbnVsbCA/IG92ZXJOb2RlIDogYWN0aXZlTm9kZSA6IG51bGwpO1xuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyA9IHVzZVJlY3RzKHNjcm9sbGFibGVBbmNlc3RvcnMpOyAvLyBBcHBseSBtb2RpZmllcnNcblxuICBjb25zdCBtb2RpZmllZFRyYW5zbGF0ZSA9IGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywge1xuICAgIHRyYW5zZm9ybToge1xuICAgICAgeDogdHJhbnNsYXRlLnggLSBub2RlUmVjdERlbHRhLngsXG4gICAgICB5OiB0cmFuc2xhdGUueSAtIG5vZGVSZWN0RGVsdGEueSxcbiAgICAgIHNjYWxlWDogMSxcbiAgICAgIHNjYWxlWTogMVxuICAgIH0sXG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgIGRyYWdnaW5nTm9kZVJlY3QsXG4gICAgb3Zlcjogc2Vuc29yQ29udGV4dC5jdXJyZW50Lm92ZXIsXG4gICAgb3ZlcmxheU5vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgd2luZG93UmVjdFxuICB9KTtcbiAgY29uc3QgcG9pbnRlckNvb3JkaW5hdGVzID0gYWN0aXZhdGlvbkNvb3JkaW5hdGVzID8gYWRkKGFjdGl2YXRpb25Db29yZGluYXRlcywgdHJhbnNsYXRlKSA6IG51bGw7XG4gIGNvbnN0IHNjcm9sbE9mZnNldHMgPSB1c2VTY3JvbGxPZmZzZXRzKHNjcm9sbGFibGVBbmNlc3RvcnMpOyAvLyBSZXByZXNlbnRzIHRoZSBzY3JvbGwgZGVsdGEgc2luY2UgZHJhZ2dpbmcgd2FzIGluaXRpYXRlZFxuXG4gIGNvbnN0IHNjcm9sbEFkanVzdG1lbnQgPSB1c2VTY3JvbGxPZmZzZXRzRGVsdGEoc2Nyb2xsT2Zmc2V0cyk7IC8vIFJlcHJlc2VudHMgdGhlIHNjcm9sbCBkZWx0YSBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBhY3RpdmUgbm9kZSByZWN0IHdhcyBtZWFzdXJlZFxuXG4gIGNvbnN0IGFjdGl2ZU5vZGVTY3JvbGxEZWx0YSA9IHVzZVNjcm9sbE9mZnNldHNEZWx0YShzY3JvbGxPZmZzZXRzLCBbYWN0aXZlTm9kZVJlY3RdKTtcbiAgY29uc3Qgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUgPSBhZGQobW9kaWZpZWRUcmFuc2xhdGUsIHNjcm9sbEFkanVzdG1lbnQpO1xuICBjb25zdCBjb2xsaXNpb25SZWN0ID0gZHJhZ2dpbmdOb2RlUmVjdCA/IGdldEFkanVzdGVkUmVjdChkcmFnZ2luZ05vZGVSZWN0LCBtb2RpZmllZFRyYW5zbGF0ZSkgOiBudWxsO1xuICBjb25zdCBjb2xsaXNpb25zID0gYWN0aXZlICYmIGNvbGxpc2lvblJlY3QgPyBjb2xsaXNpb25EZXRlY3Rpb24oe1xuICAgIGFjdGl2ZSxcbiAgICBjb2xsaXNpb25SZWN0LFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnM6IGVuYWJsZWREcm9wcGFibGVDb250YWluZXJzLFxuICAgIHBvaW50ZXJDb29yZGluYXRlc1xuICB9KSA6IG51bGw7XG4gIGNvbnN0IG92ZXJJZCA9IGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpc2lvbnMsICdpZCcpO1xuICBjb25zdCBbb3Zlciwgc2V0T3Zlcl0gPSB1c2VTdGF0ZShudWxsKTsgLy8gV2hlbiB0aGVyZSBpcyBubyBkcmFnIG92ZXJsYXkgdXNlZCwgd2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGVcbiAgLy8gd2luZG93IHNjcm9sbCBkZWx0YVxuXG4gIGNvbnN0IGFwcGxpZWRUcmFuc2xhdGUgPSB1c2VzRHJhZ092ZXJsYXkgPyBtb2RpZmllZFRyYW5zbGF0ZSA6IGFkZChtb2RpZmllZFRyYW5zbGF0ZSwgYWN0aXZlTm9kZVNjcm9sbERlbHRhKTtcbiAgY29uc3QgdHJhbnNmb3JtID0gYWRqdXN0U2NhbGUoYXBwbGllZFRyYW5zbGF0ZSwgKF9vdmVyJHJlY3QgPSBvdmVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVyLnJlY3QpICE9IG51bGwgPyBfb3ZlciRyZWN0IDogbnVsbCwgYWN0aXZlTm9kZVJlY3QpO1xuICBjb25zdCBhY3RpdmVTZW5zb3JSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluc3RhbnRpYXRlU2Vuc29yID0gdXNlQ2FsbGJhY2soKGV2ZW50LCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBzZW5zb3I6IFNlbnNvcixcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoYWN0aXZlUmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlUmVmLmN1cnJlbnQpO1xuXG4gICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZhdG9yRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICBjb25zdCBzZW5zb3JJbnN0YW5jZSA9IG5ldyBTZW5zb3Ioe1xuICAgICAgYWN0aXZlOiBhY3RpdmVSZWYuY3VycmVudCxcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBldmVudDogYWN0aXZhdG9yRXZlbnQsXG4gICAgICBvcHRpb25zLFxuICAgICAgLy8gU2Vuc29ycyBuZWVkIHRvIGJlIGluc3RhbnRpYXRlZCB3aXRoIHJlZnMgZm9yIGFyZ3VtZW50cyB0aGF0IGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgIC8vIG90aGVyd2lzZSB0aGV5IGFyZSBmcm96ZW4gaW4gdGltZSB3aXRoIHRoZSBzdGFsZSBhcmd1bWVudHNcbiAgICAgIGNvbnRleHQ6IHNlbnNvckNvbnRleHQsXG5cbiAgICAgIG9uQWJvcnQoaWQpIHtcbiAgICAgICAgY29uc3QgZHJhZ2dhYmxlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFkcmFnZ2FibGVOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9uRHJhZ0Fib3J0XG4gICAgICAgIH0gPSBsYXRlc3RQcm9wcy5jdXJyZW50O1xuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9O1xuICAgICAgICBvbkRyYWdBYm9ydCA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnQWJvcnQoZXZlbnQpO1xuICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ29uRHJhZ0Fib3J0JyxcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIG9uUGVuZGluZyhpZCwgY29uc3RyYWludCwgaW5pdGlhbENvb3JkaW5hdGVzLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgZHJhZ2dhYmxlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFkcmFnZ2FibGVOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9uRHJhZ1BlbmRpbmdcbiAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbnN0cmFpbnQsXG4gICAgICAgICAgaW5pdGlhbENvb3JkaW5hdGVzLFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBvbkRyYWdQZW5kaW5nID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdQZW5kaW5nKGV2ZW50KTtcbiAgICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdvbkRyYWdQZW5kaW5nJyxcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIG9uU3RhcnQoaW5pdGlhbENvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYWN0aXZlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb25EcmFnU3RhcnRcbiAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBkcmFnZ2FibGVOb2RlLmRhdGEsXG4gICAgICAgICAgICByZWN0OiBhY3RpdmVSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIG9uRHJhZ1N0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgc2V0U3RhdHVzKFN0YXR1cy5Jbml0aWFsaXppbmcpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IEFjdGlvbi5EcmFnU3RhcnQsXG4gICAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBhY3RpdmU6IGlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ29uRHJhZ1N0YXJ0JyxcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0QWN0aXZlU2Vuc29yKGFjdGl2ZVNlbnNvclJlZi5jdXJyZW50KTtcbiAgICAgICAgICBzZXRBY3RpdmF0b3JFdmVudChhY3RpdmF0b3JFdmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgb25Nb3ZlKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBBY3Rpb24uRHJhZ01vdmUsXG4gICAgICAgICAgY29vcmRpbmF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvbkVuZDogY3JlYXRlSGFuZGxlcihBY3Rpb24uRHJhZ0VuZCksXG4gICAgICBvbkNhbmNlbDogY3JlYXRlSGFuZGxlcihBY3Rpb24uRHJhZ0NhbmNlbClcbiAgICB9KTtcbiAgICBhY3RpdmVTZW5zb3JSZWYuY3VycmVudCA9IHNlbnNvckluc3RhbmNlO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFuZGxlcih0eXBlKSB7XG4gICAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBjb2xsaXNpb25zLFxuICAgICAgICAgIG92ZXIsXG4gICAgICAgICAgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVcbiAgICAgICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoYWN0aXZlICYmIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2FuY2VsRHJvcFxuICAgICAgICAgIH0gPSBsYXRlc3RQcm9wcy5jdXJyZW50O1xuICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgICBkZWx0YTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUsXG4gICAgICAgICAgICBvdmVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlID09PSBBY3Rpb24uRHJhZ0VuZCAmJiB0eXBlb2YgY2FuY2VsRHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ2FuY2VsID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNhbmNlbERyb3AoZXZlbnQpKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZENhbmNlbCkge1xuICAgICAgICAgICAgICB0eXBlID0gQWN0aW9uLkRyYWdDYW5jZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFN0YXR1cyhTdGF0dXMuVW5pbml0aWFsaXplZCk7XG4gICAgICAgICAgc2V0T3ZlcihudWxsKTtcbiAgICAgICAgICBzZXRBY3RpdmVTZW5zb3IobnVsbCk7XG4gICAgICAgICAgc2V0QWN0aXZhdG9yRXZlbnQobnVsbCk7XG4gICAgICAgICAgYWN0aXZlU2Vuc29yUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IHR5cGUgPT09IEFjdGlvbi5EcmFnRW5kID8gJ29uRHJhZ0VuZCcgOiAnb25EcmFnQ2FuY2VsJztcblxuICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGxhdGVzdFByb3BzLmN1cnJlbnRbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGhhbmRsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2RyYWdnYWJsZU5vZGVzXSk7XG4gIGNvbnN0IGJpbmRBY3RpdmF0b3JUb1NlbnNvckluc3RhbnRpYXRvciA9IHVzZUNhbGxiYWNrKChoYW5kbGVyLCBzZW5zb3IpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50LCBhY3RpdmUpID0+IHtcbiAgICAgIGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG4gICAgICBjb25zdCBhY3RpdmVEcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGFjdGl2ZSk7XG5cbiAgICAgIGlmICggLy8gQW5vdGhlciBzZW5zb3IgaXMgYWxyZWFkeSBpbnN0YW50aWF0aW5nXG4gICAgICBhY3RpdmVSZWYuY3VycmVudCAhPT0gbnVsbCB8fCAvLyBObyBhY3RpdmUgZHJhZ2dhYmxlXG4gICAgICAhYWN0aXZlRHJhZ2dhYmxlTm9kZSB8fCAvLyBFdmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkXG4gICAgICBuYXRpdmVFdmVudC5kbmRLaXQgfHwgbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGl2YXRpb25Db250ZXh0ID0ge1xuICAgICAgICBhY3RpdmU6IGFjdGl2ZURyYWdnYWJsZU5vZGVcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG91bGRBY3RpdmF0ZSA9IGhhbmRsZXIoZXZlbnQsIHNlbnNvci5vcHRpb25zLCBhY3RpdmF0aW9uQ29udGV4dCk7XG5cbiAgICAgIGlmIChzaG91bGRBY3RpdmF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBuYXRpdmVFdmVudC5kbmRLaXQgPSB7XG4gICAgICAgICAgY2FwdHVyZWRCeTogc2Vuc29yLnNlbnNvclxuICAgICAgICB9O1xuICAgICAgICBhY3RpdmVSZWYuY3VycmVudCA9IGFjdGl2ZTtcbiAgICAgICAgaW5zdGFudGlhdGVTZW5zb3IoZXZlbnQsIHNlbnNvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2RyYWdnYWJsZU5vZGVzLCBpbnN0YW50aWF0ZVNlbnNvcl0pO1xuICBjb25zdCBhY3RpdmF0b3JzID0gdXNlQ29tYmluZUFjdGl2YXRvcnMoc2Vuc29ycywgYmluZEFjdGl2YXRvclRvU2Vuc29ySW5zdGFudGlhdG9yKTtcbiAgdXNlU2Vuc29yU2V0dXAoc2Vuc29ycyk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3RpdmVOb2RlUmVjdCAmJiBzdGF0dXMgPT09IFN0YXR1cy5Jbml0aWFsaXppbmcpIHtcbiAgICAgIHNldFN0YXR1cyhTdGF0dXMuSW5pdGlhbGl6ZWQpO1xuICAgIH1cbiAgfSwgW2FjdGl2ZU5vZGVSZWN0LCBzdGF0dXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdNb3ZlXG4gICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgb3ZlclxuICAgIH0gPSBzZW5zb3JDb250ZXh0LmN1cnJlbnQ7XG5cbiAgICBpZiAoIWFjdGl2ZSB8fCAhYWN0aXZhdG9yRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRlbHRhOiB7XG4gICAgICAgIHg6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLngsXG4gICAgICAgIHk6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLnlcbiAgICAgIH0sXG4gICAgICBvdmVyXG4gICAgfTtcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICBvbkRyYWdNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdNb3ZlKGV2ZW50KTtcbiAgICAgIGRpc3BhdGNoTW9uaXRvckV2ZW50KHtcbiAgICAgICAgdHlwZTogJ29uRHJhZ01vdmUnLFxuICAgICAgICBldmVudFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3Njcm9sbEFkanVzdGVkVHJhbnNsYXRlLngsIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLnldKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVcbiAgICB9ID0gc2Vuc29yQ29udGV4dC5jdXJyZW50O1xuXG4gICAgaWYgKCFhY3RpdmUgfHwgYWN0aXZlUmVmLmN1cnJlbnQgPT0gbnVsbCB8fCAhYWN0aXZhdG9yRXZlbnQgfHwgIXNjcm9sbEFkanVzdGVkVHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgb25EcmFnT3ZlclxuICAgIH0gPSBsYXRlc3RQcm9wcy5jdXJyZW50O1xuICAgIGNvbnN0IG92ZXJDb250YWluZXIgPSBkcm9wcGFibGVDb250YWluZXJzLmdldChvdmVySWQpO1xuICAgIGNvbnN0IG92ZXIgPSBvdmVyQ29udGFpbmVyICYmIG92ZXJDb250YWluZXIucmVjdC5jdXJyZW50ID8ge1xuICAgICAgaWQ6IG92ZXJDb250YWluZXIuaWQsXG4gICAgICByZWN0OiBvdmVyQ29udGFpbmVyLnJlY3QuY3VycmVudCxcbiAgICAgIGRhdGE6IG92ZXJDb250YWluZXIuZGF0YSxcbiAgICAgIGRpc2FibGVkOiBvdmVyQ29udGFpbmVyLmRpc2FibGVkXG4gICAgfSA6IG51bGw7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBkZWx0YToge1xuICAgICAgICB4OiBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZS54LFxuICAgICAgICB5OiBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZS55XG4gICAgICB9LFxuICAgICAgb3ZlclxuICAgIH07XG4gICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgc2V0T3ZlcihvdmVyKTtcbiAgICAgIG9uRHJhZ092ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ092ZXIoZXZlbnQpO1xuICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICB0eXBlOiAnb25EcmFnT3ZlcicsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbb3ZlcklkXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHNlbnNvckNvbnRleHQuY3VycmVudCA9IHtcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIGNvbGxpc2lvblJlY3QsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICAgIGRyYWdnaW5nTm9kZSxcbiAgICAgIGRyYWdnaW5nTm9kZVJlY3QsXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgb3ZlcixcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZVxuICAgIH07XG4gICAgYWN0aXZlUmVjdHMuY3VycmVudCA9IHtcbiAgICAgIGluaXRpYWw6IGRyYWdnaW5nTm9kZVJlY3QsXG4gICAgICB0cmFuc2xhdGVkOiBjb2xsaXNpb25SZWN0XG4gICAgfTtcbiAgfSwgW2FjdGl2ZSwgYWN0aXZlTm9kZSwgY29sbGlzaW9ucywgY29sbGlzaW9uUmVjdCwgZHJhZ2dhYmxlTm9kZXMsIGRyYWdnaW5nTm9kZSwgZHJhZ2dpbmdOb2RlUmVjdCwgZHJvcHBhYmxlUmVjdHMsIGRyb3BwYWJsZUNvbnRhaW5lcnMsIG92ZXIsIHNjcm9sbGFibGVBbmNlc3RvcnMsIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlXSk7XG4gIHVzZUF1dG9TY3JvbGxlcih7IC4uLmF1dG9TY3JvbGxPcHRpb25zLFxuICAgIGRlbHRhOiB0cmFuc2xhdGUsXG4gICAgZHJhZ2dpbmdSZWN0OiBjb2xsaXNpb25SZWN0LFxuICAgIHBvaW50ZXJDb29yZGluYXRlcyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzXG4gIH0pO1xuICBjb25zdCBwdWJsaWNDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBkcm9wcGFibGVSZWN0cyxcbiAgICAgIG92ZXIsXG4gICAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sXG4gICAgICBtZWFzdXJpbmdTY2hlZHVsZWQsXG4gICAgICB3aW5kb3dSZWN0XG4gICAgfTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSwgW2FjdGl2ZSwgYWN0aXZlTm9kZSwgYWN0aXZlTm9kZVJlY3QsIGFjdGl2YXRvckV2ZW50LCBjb2xsaXNpb25zLCBjb250YWluZXJOb2RlUmVjdCwgZHJhZ092ZXJsYXksIGRyYWdnYWJsZU5vZGVzLCBkcm9wcGFibGVDb250YWluZXJzLCBkcm9wcGFibGVSZWN0cywgb3ZlciwgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsIHNjcm9sbGFibGVBbmNlc3RvcnMsIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLCBtZWFzdXJpbmdTY2hlZHVsZWQsIHdpbmRvd1JlY3RdKTtcbiAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgYWN0aXZhdG9ycyxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgICAgYXJpYURlc2NyaWJlZEJ5SWQ6IHtcbiAgICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVEZXNjcmliZWRCeUlkXG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2gsXG4gICAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICAgIG92ZXIsXG4gICAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc1xuICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0sIFthY3RpdmF0b3JFdmVudCwgYWN0aXZhdG9ycywgYWN0aXZlLCBhY3RpdmVOb2RlUmVjdCwgZGlzcGF0Y2gsIGRyYWdnYWJsZURlc2NyaWJlZEJ5SWQsIGRyYWdnYWJsZU5vZGVzLCBvdmVyLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc10pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEbmRNb25pdG9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZWdpc3Rlck1vbml0b3JMaXN0ZW5lclxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVybmFsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBpbnRlcm5hbENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQdWJsaWNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHB1YmxpY0NvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChBY3RpdmVEcmFnZ2FibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRyYW5zZm9ybVxuICB9LCBjaGlsZHJlbikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJlc3RvcmVGb2N1cywge1xuICAgIGRpc2FibGVkOiAoYWNjZXNzaWJpbGl0eSA9PSBudWxsID8gdm9pZCAwIDogYWNjZXNzaWJpbGl0eS5yZXN0b3JlRm9jdXMpID09PSBmYWxzZVxuICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWNjZXNzaWJpbGl0eSwgeyAuLi5hY2Nlc3NpYmlsaXR5LFxuICAgIGhpZGRlblRleHREZXNjcmliZWRCeUlkOiBkcmFnZ2FibGVEZXNjcmliZWRCeUlkXG4gIH0pKTtcblxuICBmdW5jdGlvbiBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCkge1xuICAgIGNvbnN0IGFjdGl2ZVNlbnNvckRpc2FibGVzQXV0b3Njcm9sbCA9IChhY3RpdmVTZW5zb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZVNlbnNvci5hdXRvU2Nyb2xsRW5hYmxlZCkgPT09IGZhbHNlO1xuICAgIGNvbnN0IGF1dG9TY3JvbGxHbG9iYWxseURpc2FibGVkID0gdHlwZW9mIGF1dG9TY3JvbGwgPT09ICdvYmplY3QnID8gYXV0b1Njcm9sbC5lbmFibGVkID09PSBmYWxzZSA6IGF1dG9TY3JvbGwgPT09IGZhbHNlO1xuICAgIGNvbnN0IGVuYWJsZWQgPSBpc0luaXRpYWxpemVkICYmICFhY3RpdmVTZW5zb3JEaXNhYmxlc0F1dG9zY3JvbGwgJiYgIWF1dG9TY3JvbGxHbG9iYWxseURpc2FibGVkO1xuXG4gICAgaWYgKHR5cGVvZiBhdXRvU2Nyb2xsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHsgLi4uYXV0b1Njcm9sbCxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW5hYmxlZFxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBOdWxsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgZGVmYXVsdFJvbGUgPSAnYnV0dG9uJztcbmNvbnN0IElEX1BSRUZJWCA9ICdEcmFnZ2FibGUnO1xuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICBkYXRhLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgYXR0cmlidXRlc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qga2V5ID0gdXNlVW5pcXVlSWQoSURfUFJFRklYKTtcbiAgY29uc3Qge1xuICAgIGFjdGl2YXRvcnMsXG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGFyaWFEZXNjcmliZWRCeUlkLFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIG92ZXJcbiAgfSA9IHVzZUNvbnRleHQoSW50ZXJuYWxDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHJvbGUgPSBkZWZhdWx0Um9sZSxcbiAgICByb2xlRGVzY3JpcHRpb24gPSAnZHJhZ2dhYmxlJyxcbiAgICB0YWJJbmRleCA9IDBcbiAgfSA9IGF0dHJpYnV0ZXMgIT0gbnVsbCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IChhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5pZCkgPT09IGlkO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VDb250ZXh0KGlzRHJhZ2dpbmcgPyBBY3RpdmVEcmFnZ2FibGVDb250ZXh0IDogTnVsbENvbnRleHQpO1xuICBjb25zdCBbbm9kZSwgc2V0Tm9kZVJlZl0gPSB1c2VOb2RlUmVmKCk7XG4gIGNvbnN0IFthY3RpdmF0b3JOb2RlLCBzZXRBY3RpdmF0b3JOb2RlUmVmXSA9IHVzZU5vZGVSZWYoKTtcbiAgY29uc3QgbGlzdGVuZXJzID0gdXNlU3ludGhldGljTGlzdGVuZXJzKGFjdGl2YXRvcnMsIGlkKTtcbiAgY29uc3QgZGF0YVJlZiA9IHVzZUxhdGVzdFZhbHVlKGRhdGEpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBkcmFnZ2FibGVOb2Rlcy5zZXQoaWQsIHtcbiAgICAgIGlkLFxuICAgICAga2V5LFxuICAgICAgbm9kZSxcbiAgICAgIGFjdGl2YXRvck5vZGUsXG4gICAgICBkYXRhOiBkYXRhUmVmXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoaWQpO1xuXG4gICAgICBpZiAobm9kZSAmJiBub2RlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGRyYWdnYWJsZU5vZGVzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dhYmxlTm9kZXMsIGlkXSk7XG4gIGNvbnN0IG1lbW9pemVkQXR0cmlidXRlcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICByb2xlLFxuICAgIHRhYkluZGV4LFxuICAgICdhcmlhLWRpc2FibGVkJzogZGlzYWJsZWQsXG4gICAgJ2FyaWEtcHJlc3NlZCc6IGlzRHJhZ2dpbmcgJiYgcm9sZSA9PT0gZGVmYXVsdFJvbGUgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IHJvbGVEZXNjcmlwdGlvbixcbiAgICAnYXJpYS1kZXNjcmliZWRieSc6IGFyaWFEZXNjcmliZWRCeUlkLmRyYWdnYWJsZVxuICB9KSwgW2Rpc2FibGVkLCByb2xlLCB0YWJJbmRleCwgaXNEcmFnZ2luZywgcm9sZURlc2NyaXB0aW9uLCBhcmlhRGVzY3JpYmVkQnlJZC5kcmFnZ2FibGVdKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgYXR0cmlidXRlczogbWVtb2l6ZWRBdHRyaWJ1dGVzLFxuICAgIGlzRHJhZ2dpbmcsXG4gICAgbGlzdGVuZXJzOiBkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGxpc3RlbmVycyxcbiAgICBub2RlLFxuICAgIG92ZXIsXG4gICAgc2V0Tm9kZVJlZixcbiAgICBzZXRBY3RpdmF0b3JOb2RlUmVmLFxuICAgIHRyYW5zZm9ybVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEbmRDb250ZXh0KCkge1xuICByZXR1cm4gdXNlQ29udGV4dChQdWJsaWNDb250ZXh0KTtcbn1cblxuY29uc3QgSURfUFJFRklYJDEgPSAnRHJvcHBhYmxlJztcbmNvbnN0IGRlZmF1bHRSZXNpemVPYnNlcnZlckNvbmZpZyA9IHtcbiAgdGltZW91dDogMjVcbn07XG5mdW5jdGlvbiB1c2VEcm9wcGFibGUoX3JlZikge1xuICBsZXQge1xuICAgIGRhdGEsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBpZCxcbiAgICByZXNpemVPYnNlcnZlckNvbmZpZ1xuICB9ID0gX3JlZjtcbiAgY29uc3Qga2V5ID0gdXNlVW5pcXVlSWQoSURfUFJFRklYJDEpO1xuICBjb25zdCB7XG4gICAgYWN0aXZlLFxuICAgIGRpc3BhdGNoLFxuICAgIG92ZXIsXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnNcbiAgfSA9IHVzZUNvbnRleHQoSW50ZXJuYWxDb250ZXh0KTtcbiAgY29uc3QgcHJldmlvdXMgPSB1c2VSZWYoe1xuICAgIGRpc2FibGVkXG4gIH0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlckNvbm5lY3RlZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHJlY3QgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNhbGxiYWNrSWQgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBkaXNhYmxlZDogcmVzaXplT2JzZXJ2ZXJEaXNhYmxlZCxcbiAgICB1cGRhdGVNZWFzdXJlbWVudHNGb3IsXG4gICAgdGltZW91dDogcmVzaXplT2JzZXJ2ZXJUaW1lb3V0XG4gIH0gPSB7IC4uLmRlZmF1bHRSZXNpemVPYnNlcnZlckNvbmZpZyxcbiAgICAuLi5yZXNpemVPYnNlcnZlckNvbmZpZ1xuICB9O1xuICBjb25zdCBpZHMgPSB1c2VMYXRlc3RWYWx1ZSh1cGRhdGVNZWFzdXJlbWVudHNGb3IgIT0gbnVsbCA/IHVwZGF0ZU1lYXN1cmVtZW50c0ZvciA6IGlkKTtcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQuY3VycmVudCkge1xuICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgaW52b2tlcyB0aGUgYGhhbmRsZVJlc2l6ZWAgY2FsbGJhY2sgYXMgc29vbiBhcyBgb2JzZXJ2ZWAgaXMgY2FsbGVkLFxuICAgICAgLy8gYXNzdW1pbmcgdGhlIGVsZW1lbnQgaXMgcmVuZGVyZWQgYW5kIGRpc3BsYXllZC5cbiAgICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja0lkLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNhbGxiYWNrSWQuY3VycmVudCk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tJZC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyhBcnJheS5pc0FycmF5KGlkcy5jdXJyZW50KSA/IGlkcy5jdXJyZW50IDogW2lkcy5jdXJyZW50XSk7XG4gICAgICBjYWxsYmFja0lkLmN1cnJlbnQgPSBudWxsO1xuICAgIH0sIHJlc2l6ZU9ic2VydmVyVGltZW91dCk7XG4gIH0sIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbcmVzaXplT2JzZXJ2ZXJUaW1lb3V0XSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrOiBoYW5kbGVSZXNpemUsXG4gICAgZGlzYWJsZWQ6IHJlc2l6ZU9ic2VydmVyRGlzYWJsZWQgfHwgIWFjdGl2ZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlTm9kZUNoYW5nZSA9IHVzZUNhbGxiYWNrKChuZXdFbGVtZW50LCBwcmV2aW91c0VsZW1lbnQpID0+IHtcbiAgICBpZiAoIXJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzRWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHByZXZpb3VzRWxlbWVudCk7XG4gICAgICByZXNpemVPYnNlcnZlckNvbm5lY3RlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobmV3RWxlbWVudCk7XG4gICAgfVxuICB9LCBbcmVzaXplT2JzZXJ2ZXJdKTtcbiAgY29uc3QgW25vZGVSZWYsIHNldE5vZGVSZWZdID0gdXNlTm9kZVJlZihoYW5kbGVOb2RlQ2hhbmdlKTtcbiAgY29uc3QgZGF0YVJlZiA9IHVzZUxhdGVzdFZhbHVlKGRhdGEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcmVzaXplT2JzZXJ2ZXIgfHwgIW5vZGVSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlckNvbm5lY3RlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShub2RlUmVmLmN1cnJlbnQpO1xuICB9LCBbbm9kZVJlZiwgcmVzaXplT2JzZXJ2ZXJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb24uUmVnaXN0ZXJEcm9wcGFibGUsXG4gICAgICBlbGVtZW50OiB7XG4gICAgICAgIGlkLFxuICAgICAgICBrZXksXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBub2RlOiBub2RlUmVmLFxuICAgICAgICByZWN0LFxuICAgICAgICBkYXRhOiBkYXRhUmVmXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IEFjdGlvbi5VbnJlZ2lzdGVyRHJvcHBhYmxlLFxuICAgICAga2V5LFxuICAgICAgaWRcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbaWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgIT09IHByZXZpb3VzLmN1cnJlbnQuZGlzYWJsZWQpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogQWN0aW9uLlNldERyb3BwYWJsZURpc2FibGVkLFxuICAgICAgICBpZCxcbiAgICAgICAga2V5LFxuICAgICAgICBkaXNhYmxlZFxuICAgICAgfSk7XG4gICAgICBwcmV2aW91cy5jdXJyZW50LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9LCBbaWQsIGtleSwgZGlzYWJsZWQsIGRpc3BhdGNoXSk7XG4gIHJldHVybiB7XG4gICAgYWN0aXZlLFxuICAgIHJlY3QsXG4gICAgaXNPdmVyOiAob3ZlciA9PSBudWxsID8gdm9pZCAwIDogb3Zlci5pZCkgPT09IGlkLFxuICAgIG5vZGU6IG5vZGVSZWYsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmXG4gIH07XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbk1hbmFnZXIoX3JlZikge1xuICBsZXQge1xuICAgIGFuaW1hdGlvbixcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgY29uc3QgW2Nsb25lZENoaWxkcmVuLCBzZXRDbG9uZWRDaGlsZHJlbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzQ2hpbGRyZW4gPSB1c2VQcmV2aW91cyhjaGlsZHJlbik7XG5cbiAgaWYgKCFjaGlsZHJlbiAmJiAhY2xvbmVkQ2hpbGRyZW4gJiYgcHJldmlvdXNDaGlsZHJlbikge1xuICAgIHNldENsb25lZENoaWxkcmVuKHByZXZpb3VzQ2hpbGRyZW4pO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gY2xvbmVkQ2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNsb25lZENoaWxkcmVuLmtleTtcbiAgICBjb25zdCBpZCA9IGNsb25lZENoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjbG9uZWRDaGlsZHJlbi5wcm9wcy5pZDtcblxuICAgIGlmIChrZXkgPT0gbnVsbCB8fCBpZCA9PSBudWxsKSB7XG4gICAgICBzZXRDbG9uZWRDaGlsZHJlbihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBQcm9taXNlLnJlc29sdmUoYW5pbWF0aW9uKGlkLCBlbGVtZW50KSkudGhlbigoKSA9PiB7XG4gICAgICBzZXRDbG9uZWRDaGlsZHJlbihudWxsKTtcbiAgICB9KTtcbiAgfSwgW2FuaW1hdGlvbiwgY2xvbmVkQ2hpbGRyZW4sIGVsZW1lbnRdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCBjbG9uZWRDaGlsZHJlbiA/IGNsb25lRWxlbWVudChjbG9uZWRDaGlsZHJlbiwge1xuICAgIHJlZjogc2V0RWxlbWVudFxuICB9KSA6IG51bGwpO1xufVxuXG5jb25zdCBkZWZhdWx0VHJhbnNmb3JtID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbmZ1bmN0aW9uIE51bGxpZmllZENvbnRleHRQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVybmFsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWZhdWx0SW50ZXJuYWxDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWN0aXZlRHJhZ2dhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWZhdWx0VHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSk7XG59XG5cbmNvbnN0IGJhc2VTdHlsZXMgPSB7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB0b3VjaEFjdGlvbjogJ25vbmUnXG59O1xuXG5jb25zdCBkZWZhdWx0VHJhbnNpdGlvbiA9IGFjdGl2YXRvckV2ZW50ID0+IHtcbiAgY29uc3QgaXNLZXlib2FyZEFjdGl2YXRvciA9IGlzS2V5Ym9hcmRFdmVudChhY3RpdmF0b3JFdmVudCk7XG4gIHJldHVybiBpc0tleWJvYXJkQWN0aXZhdG9yID8gJ3RyYW5zZm9ybSAyNTBtcyBlYXNlJyA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IFBvc2l0aW9uZWRPdmVybGF5ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIGFzLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFkanVzdFNjYWxlLFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSxcbiAgICByZWN0LFxuICAgIHN0eWxlLFxuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uID0gZGVmYXVsdFRyYW5zaXRpb25cbiAgfSA9IF9yZWY7XG5cbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBzY2FsZUFkanVzdGVkVHJhbnNmb3JtID0gYWRqdXN0U2NhbGUgPyB0cmFuc2Zvcm0gOiB7IC4uLnRyYW5zZm9ybSxcbiAgICBzY2FsZVg6IDEsXG4gICAgc2NhbGVZOiAxXG4gIH07XG4gIGNvbnN0IHN0eWxlcyA9IHsgLi4uYmFzZVN0eWxlcyxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRyYW5zZm9ybTogQ1NTLlRyYW5zZm9ybS50b1N0cmluZyhzY2FsZUFkanVzdGVkVHJhbnNmb3JtKSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IGFkanVzdFNjYWxlICYmIGFjdGl2YXRvckV2ZW50ID8gZ2V0UmVsYXRpdmVUcmFuc2Zvcm1PcmlnaW4oYWN0aXZhdG9yRXZlbnQsIHJlY3QpIDogdW5kZWZpbmVkLFxuICAgIHRyYW5zaXRpb246IHR5cGVvZiB0cmFuc2l0aW9uID09PSAnZnVuY3Rpb24nID8gdHJhbnNpdGlvbihhY3RpdmF0b3JFdmVudCkgOiB0cmFuc2l0aW9uLFxuICAgIC4uLnN0eWxlXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGFzLCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZXMsXG4gICAgcmVmXG4gIH0sIGNoaWxkcmVuKTtcbn0pO1xuXG5jb25zdCBkZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzID0gb3B0aW9ucyA9PiBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhY3RpdmUsXG4gICAgZHJhZ092ZXJsYXlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9yaWdpbmFsU3R5bGVzID0ge307XG4gIGNvbnN0IHtcbiAgICBzdHlsZXMsXG4gICAgY2xhc3NOYW1lXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChzdHlsZXMgIT0gbnVsbCAmJiBzdHlsZXMuYWN0aXZlKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzLmFjdGl2ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbFN0eWxlc1trZXldID0gYWN0aXZlLm5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpO1xuICAgICAgYWN0aXZlLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlcyAhPSBudWxsICYmIHN0eWxlcy5kcmFnT3ZlcmxheSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcy5kcmFnT3ZlcmxheSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkcmFnT3ZlcmxheS5ub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjbGFzc05hbWUgIT0gbnVsbCAmJiBjbGFzc05hbWUuYWN0aXZlKSB7XG4gICAgYWN0aXZlLm5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuYWN0aXZlKTtcbiAgfVxuXG4gIGlmIChjbGFzc05hbWUgIT0gbnVsbCAmJiBjbGFzc05hbWUuZHJhZ092ZXJsYXkpIHtcbiAgICBkcmFnT3ZlcmxheS5ub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLmRyYWdPdmVybGF5KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9yaWdpbmFsU3R5bGVzKSkge1xuICAgICAgYWN0aXZlLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZS5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLmFjdGl2ZSk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgZGVmYXVsdEtleWZyYW1lUmVzb2x2ZXIgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICBpbml0aWFsLFxuICAgICAgZmluYWxcbiAgICB9XG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIFt7XG4gICAgdHJhbnNmb3JtOiBDU1MuVHJhbnNmb3JtLnRvU3RyaW5nKGluaXRpYWwpXG4gIH0sIHtcbiAgICB0cmFuc2Zvcm06IENTUy5UcmFuc2Zvcm0udG9TdHJpbmcoZmluYWwpXG4gIH1dO1xufTtcblxuY29uc3QgZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uID0ge1xuICBkdXJhdGlvbjogMjUwLFxuICBlYXNpbmc6ICdlYXNlJyxcbiAga2V5ZnJhbWVzOiBkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlcixcbiAgc2lkZUVmZmVjdHM6IC8qI19fUFVSRV9fKi9kZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzKHtcbiAgICBzdHlsZXM6IHtcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBvcGFjaXR5OiAnMCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59O1xuZnVuY3Rpb24gdXNlRHJvcEFuaW1hdGlvbihfcmVmMykge1xuICBsZXQge1xuICAgIGNvbmZpZyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb25cbiAgfSA9IF9yZWYzO1xuICByZXR1cm4gdXNlRXZlbnQoKGlkLCBub2RlKSA9PiB7XG4gICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZURyYWdnYWJsZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICBpZiAoIWFjdGl2ZURyYWdnYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSBhY3RpdmVEcmFnZ2FibGUubm9kZS5jdXJyZW50O1xuXG4gICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVhc3VyYWJsZU5vZGUgPSBnZXRNZWFzdXJhYmxlTm9kZShub2RlKTtcblxuICAgIGlmICghbWVhc3VyYWJsZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm1cbiAgICB9ID0gZ2V0V2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgIGlmICghcGFyc2VkVHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uID0gdHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZyA6IGNyZWF0ZURlZmF1bHREcm9wQW5pbWF0aW9uKGNvbmZpZyk7XG4gICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uKHtcbiAgICAgIGFjdGl2ZToge1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YTogYWN0aXZlRHJhZ2dhYmxlLmRhdGEsXG4gICAgICAgIG5vZGU6IGFjdGl2ZU5vZGUsXG4gICAgICAgIHJlY3Q6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUoYWN0aXZlTm9kZSlcbiAgICAgIH0sXG4gICAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICAgIGRyYWdPdmVybGF5OiB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIHJlY3Q6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ092ZXJsYXkubWVhc3VyZShtZWFzdXJhYmxlTm9kZSlcbiAgICAgIH0sXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgICAgIHRyYW5zZm9ybTogcGFyc2VkVHJhbnNmb3JtXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbixcbiAgICBlYXNpbmcsXG4gICAgc2lkZUVmZmVjdHMsXG4gICAga2V5ZnJhbWVzXG4gIH0gPSB7IC4uLmRlZmF1bHREcm9wQW5pbWF0aW9uQ29uZmlndXJhdGlvbixcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiBfcmVmNCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBfcmVmNDtcblxuICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgIC8vIERvIG5vdCBhbmltYXRlIGlmIGFuaW1hdGlvbiBkdXJhdGlvbiBpcyB6ZXJvLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgeDogZHJhZ092ZXJsYXkucmVjdC5sZWZ0IC0gYWN0aXZlLnJlY3QubGVmdCxcbiAgICAgIHk6IGRyYWdPdmVybGF5LnJlY3QudG9wIC0gYWN0aXZlLnJlY3QudG9wXG4gICAgfTtcbiAgICBjb25zdCBzY2FsZSA9IHtcbiAgICAgIHNjYWxlWDogdHJhbnNmb3JtLnNjYWxlWCAhPT0gMSA/IGFjdGl2ZS5yZWN0LndpZHRoICogdHJhbnNmb3JtLnNjYWxlWCAvIGRyYWdPdmVybGF5LnJlY3Qud2lkdGggOiAxLFxuICAgICAgc2NhbGVZOiB0cmFuc2Zvcm0uc2NhbGVZICE9PSAxID8gYWN0aXZlLnJlY3QuaGVpZ2h0ICogdHJhbnNmb3JtLnNjYWxlWSAvIGRyYWdPdmVybGF5LnJlY3QuaGVpZ2h0IDogMVxuICAgIH07XG4gICAgY29uc3QgZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICB4OiB0cmFuc2Zvcm0ueCAtIGRlbHRhLngsXG4gICAgICB5OiB0cmFuc2Zvcm0ueSAtIGRlbHRhLnksXG4gICAgICAuLi5zY2FsZVxuICAgIH07XG4gICAgY29uc3QgYW5pbWF0aW9uS2V5ZnJhbWVzID0ga2V5ZnJhbWVzKHsgLi4ucmVzdCxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIGluaXRpYWw6IHRyYW5zZm9ybSxcbiAgICAgICAgZmluYWw6IGZpbmFsVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgW2ZpcnN0S2V5ZnJhbWVdID0gYW5pbWF0aW9uS2V5ZnJhbWVzO1xuICAgIGNvbnN0IGxhc3RLZXlmcmFtZSA9IGFuaW1hdGlvbktleWZyYW1lc1thbmltYXRpb25LZXlmcmFtZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZmlyc3RLZXlmcmFtZSkgPT09IEpTT04uc3RyaW5naWZ5KGxhc3RLZXlmcmFtZSkpIHtcbiAgICAgIC8vIFRoZSBzdGFydCBhbmQgZW5kIGtleWZyYW1lcyBhcmUgdGhlIHNhbWUsIGluZmVyIHRoYXQgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIG5lZWRlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhbnVwID0gc2lkZUVmZmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZGVFZmZlY3RzKHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgLi4ucmVzdFxuICAgIH0pO1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGRyYWdPdmVybGF5Lm5vZGUuYW5pbWF0ZShhbmltYXRpb25LZXlmcmFtZXMsIHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZWFzaW5nLFxuICAgICAgZmlsbDogJ2ZvcndhcmRzJ1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCA9PSBudWxsID8gdm9pZCAwIDogY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuXG5sZXQga2V5ID0gMDtcbmZ1bmN0aW9uIHVzZUtleShpZCkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBrZXkrKztcbiAgICByZXR1cm4ga2V5O1xuICB9LCBbaWRdKTtcbn1cblxuY29uc3QgRHJhZ092ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhZGp1c3RTY2FsZSA9IGZhbHNlLFxuICAgIGNoaWxkcmVuLFxuICAgIGRyb3BBbmltYXRpb246IGRyb3BBbmltYXRpb25Db25maWcsXG4gICAgc3R5bGUsXG4gICAgdHJhbnNpdGlvbixcbiAgICBtb2RpZmllcnMsXG4gICAgd3JhcHBlckVsZW1lbnQgPSAnZGl2JyxcbiAgICBjbGFzc05hbWUsXG4gICAgekluZGV4ID0gOTk5XG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgZHJhZ092ZXJsYXksXG4gICAgb3ZlcixcbiAgICBtZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgd2luZG93UmVjdFxuICB9ID0gdXNlRG5kQ29udGV4dCgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VDb250ZXh0KEFjdGl2ZURyYWdnYWJsZUNvbnRleHQpO1xuICBjb25zdCBrZXkgPSB1c2VLZXkoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpO1xuICBjb25zdCBtb2RpZmllZFRyYW5zZm9ybSA9IGFwcGx5TW9kaWZpZXJzKG1vZGlmaWVycywge1xuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBjb250YWluZXJOb2RlUmVjdCxcbiAgICBkcmFnZ2luZ05vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIG92ZXIsXG4gICAgb3ZlcmxheU5vZGVSZWN0OiBkcmFnT3ZlcmxheS5yZWN0LFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgdHJhbnNmb3JtLFxuICAgIHdpbmRvd1JlY3RcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWN0ID0gdXNlSW5pdGlhbFZhbHVlKGFjdGl2ZU5vZGVSZWN0KTtcbiAgY29uc3QgZHJvcEFuaW1hdGlvbiA9IHVzZURyb3BBbmltYXRpb24oe1xuICAgIGNvbmZpZzogZHJvcEFuaW1hdGlvbkNvbmZpZyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb25cbiAgfSk7IC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGFjdGl2ZSBub2RlIHRvIGJlIG1lYXN1cmVkIGJlZm9yZSBjb25uZWN0aW5nIHRoZSBkcmFnIG92ZXJsYXkgcmVmXG4gIC8vIG90aGVyd2lzZSBjb2xsaXNpb25zIGNhbiBiZSBjb21wdXRlZCBhZ2FpbnN0IGEgbWlzcG9zaXRpb25lZCBkcmFnIG92ZXJsYXlcblxuICBjb25zdCByZWYgPSBpbml0aWFsUmVjdCA/IGRyYWdPdmVybGF5LnNldFJlZiA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTnVsbGlmaWVkQ29udGV4dFByb3ZpZGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGlvbk1hbmFnZXIsIHtcbiAgICBhbmltYXRpb246IGRyb3BBbmltYXRpb25cbiAgfSwgYWN0aXZlICYmIGtleSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9zaXRpb25lZE92ZXJsYXksIHtcbiAgICBrZXk6IGtleSxcbiAgICBpZDogYWN0aXZlLmlkLFxuICAgIHJlZjogcmVmLFxuICAgIGFzOiB3cmFwcGVyRWxlbWVudCxcbiAgICBhY3RpdmF0b3JFdmVudDogYWN0aXZhdG9yRXZlbnQsXG4gICAgYWRqdXN0U2NhbGU6IGFkanVzdFNjYWxlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgcmVjdDogaW5pdGlhbFJlY3QsXG4gICAgc3R5bGU6IHtcbiAgICAgIHpJbmRleCxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IG1vZGlmaWVkVHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSA6IG51bGwpKTtcbn0pO1xuXG5leHBvcnQgeyBBdXRvU2Nyb2xsQWN0aXZhdG9yLCBEbmRDb250ZXh0LCBEcmFnT3ZlcmxheSwgS2V5Ym9hcmRDb2RlLCBLZXlib2FyZFNlbnNvciwgTWVhc3VyaW5nRnJlcXVlbmN5LCBNZWFzdXJpbmdTdHJhdGVneSwgTW91c2VTZW5zb3IsIFBvaW50ZXJTZW5zb3IsIFRvdWNoU2Vuc29yLCBUcmF2ZXJzYWxPcmRlciwgYXBwbHlNb2RpZmllcnMsIGNsb3Nlc3RDZW50ZXIsIGNsb3Nlc3RDb3JuZXJzLCBkZWZhdWx0QW5ub3VuY2VtZW50cywgZGVmYXVsdENvb3JkaW5hdGVzLCBkZWZhdWx0RHJvcEFuaW1hdGlvbkNvbmZpZ3VyYXRpb24gYXMgZGVmYXVsdERyb3BBbmltYXRpb24sIGRlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMsIGRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIsIGRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMsIGdldENsaWVudFJlY3QsIGdldEZpcnN0Q29sbGlzaW9uLCBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzLCBwb2ludGVyV2l0aGluLCByZWN0SW50ZXJzZWN0aW9uLCB1c2VEbmRDb250ZXh0LCB1c2VEbmRNb25pdG9yLCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSwgdXNlU2Vuc29yLCB1c2VTZW5zb3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VSZWYiLCJtZW1vIiwidXNlUmVkdWNlciIsImNsb25lRWxlbWVudCIsImZvcndhcmRSZWYiLCJjcmVhdGVQb3J0YWwiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVzZVVuaXF1ZUlkIiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsImdldFdpbmRvdyIsImlzRG9jdW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNTVkdFbGVtZW50IiwiY2FuVXNlRE9NIiwiaXNXaW5kb3ciLCJpc05vZGUiLCJnZXRPd25lckRvY3VtZW50IiwiYWRkIiwiaXNLZXlib2FyZEV2ZW50Iiwic3VidHJhY3QiLCJ1c2VMYXp5TWVtbyIsInVzZUludGVydmFsIiwidXNlUHJldmlvdXMiLCJ1c2VMYXRlc3RWYWx1ZSIsInVzZUV2ZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZU5vZGVSZWYiLCJmaW5kRmlyc3RGb2N1c2FibGVOb2RlIiwiQ1NTIiwidXNlQW5ub3VuY2VtZW50IiwiSGlkZGVuVGV4dCIsIkxpdmVSZWdpb24iLCJEbmRNb25pdG9yQ29udGV4dCIsInVzZURuZE1vbml0b3IiLCJsaXN0ZW5lciIsInJlZ2lzdGVyTGlzdGVuZXIiLCJFcnJvciIsInVuc3Vic2NyaWJlIiwidXNlRG5kTW9uaXRvclByb3ZpZGVyIiwibGlzdGVuZXJzIiwiU2V0IiwiZGVsZXRlIiwiZGlzcGF0Y2giLCJfcmVmIiwidHlwZSIsImV2ZW50IiwiZm9yRWFjaCIsIl9saXN0ZW5lciR0eXBlIiwiY2FsbCIsImRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJkcmFnZ2FibGUiLCJkZWZhdWx0QW5ub3VuY2VtZW50cyIsIm9uRHJhZ1N0YXJ0IiwiYWN0aXZlIiwiaWQiLCJvbkRyYWdPdmVyIiwiX3JlZjIiLCJvdmVyIiwib25EcmFnRW5kIiwiX3JlZjMiLCJvbkRyYWdDYW5jZWwiLCJfcmVmNCIsIkFjY2Vzc2liaWxpdHkiLCJhbm5vdW5jZW1lbnRzIiwiY29udGFpbmVyIiwiaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQiLCJzY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJhbm5vdW5jZSIsImFubm91bmNlbWVudCIsImxpdmVSZWdpb25JZCIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwib25EcmFnTW92ZSIsIl9yZWY1IiwiX3JlZjYiLCJtYXJrdXAiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJ2YWx1ZSIsIkFjdGlvbiIsIm5vb3AiLCJ1c2VTZW5zb3IiLCJzZW5zb3IiLCJvcHRpb25zIiwidXNlU2Vuc29ycyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZW5zb3JzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiZGVmYXVsdENvb3JkaW5hdGVzIiwiT2JqZWN0IiwiZnJlZXplIiwieCIsInkiLCJkaXN0YW5jZUJldHdlZW4iLCJwMSIsInAyIiwiTWF0aCIsInNxcnQiLCJwb3ciLCJnZXRSZWxhdGl2ZVRyYW5zZm9ybU9yaWdpbiIsInJlY3QiLCJldmVudENvb3JkaW5hdGVzIiwidHJhbnNmb3JtT3JpZ2luIiwibGVmdCIsIndpZHRoIiwidG9wIiwiaGVpZ2h0Iiwic29ydENvbGxpc2lvbnNBc2MiLCJkYXRhIiwiYSIsImIiLCJzb3J0Q29sbGlzaW9uc0Rlc2MiLCJjb3JuZXJzT2ZSZWN0YW5nbGUiLCJnZXRGaXJzdENvbGxpc2lvbiIsImNvbGxpc2lvbnMiLCJwcm9wZXJ0eSIsImZpcnN0Q29sbGlzaW9uIiwiY2VudGVyT2ZSZWN0YW5nbGUiLCJjbG9zZXN0Q2VudGVyIiwiY29sbGlzaW9uUmVjdCIsImRyb3BwYWJsZVJlY3RzIiwiZHJvcHBhYmxlQ29udGFpbmVycyIsImNlbnRlclJlY3QiLCJkcm9wcGFibGVDb250YWluZXIiLCJnZXQiLCJkaXN0QmV0d2VlbiIsInB1c2giLCJzb3J0IiwiY2xvc2VzdENvcm5lcnMiLCJjb3JuZXJzIiwicmVjdENvcm5lcnMiLCJkaXN0YW5jZXMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImNvcm5lciIsImluZGV4IiwiZWZmZWN0aXZlRGlzdGFuY2UiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZ2V0SW50ZXJzZWN0aW9uUmF0aW8iLCJlbnRyeSIsInRhcmdldCIsIm1heCIsInJpZ2h0IiwibWluIiwiYm90dG9tIiwidGFyZ2V0QXJlYSIsImVudHJ5QXJlYSIsImludGVyc2VjdGlvbkFyZWEiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInJlY3RJbnRlcnNlY3Rpb24iLCJpc1BvaW50V2l0aGluUmVjdCIsInBvaW50IiwicG9pbnRlcldpdGhpbiIsInBvaW50ZXJDb29yZGluYXRlcyIsImFkanVzdFNjYWxlIiwidHJhbnNmb3JtIiwicmVjdDEiLCJyZWN0MiIsInNjYWxlWCIsInNjYWxlWSIsImdldFJlY3REZWx0YSIsImNyZWF0ZVJlY3RBZGp1c3RtZW50Rm4iLCJtb2RpZmllciIsImFkanVzdENsaWVudFJlY3QiLCJhZGp1c3RtZW50cyIsImFjYyIsImFkanVzdG1lbnQiLCJnZXRBZGp1c3RlZFJlY3QiLCJwYXJzZVRyYW5zZm9ybSIsInN0YXJ0c1dpdGgiLCJ0cmFuc2Zvcm1BcnJheSIsInNsaWNlIiwic3BsaXQiLCJpbnZlcnNlVHJhbnNmb3JtIiwicGFyc2VkVHJhbnNmb3JtIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJwYXJzZUZsb2F0IiwiaW5kZXhPZiIsInciLCJoIiwiZGVmYXVsdE9wdGlvbnMiLCJpZ25vcmVUcmFuc2Zvcm0iLCJnZXRDbGllbnRSZWN0IiwiZWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QiLCJnZXRXaW5kb3dDbGllbnRSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiaXNGaXhlZCIsIm5vZGUiLCJjb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJpc1Njcm9sbGFibGUiLCJvdmVyZmxvd1JlZ2V4IiwicHJvcGVydGllcyIsInNvbWUiLCJ0ZXN0IiwiZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyIsImxpbWl0Iiwic2Nyb2xsUGFyZW50cyIsImZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzIiwic2Nyb2xsaW5nRWxlbWVudCIsImluY2x1ZGVzIiwicGFyZW50Tm9kZSIsImdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yIiwiZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IiLCJnZXRTY3JvbGxhYmxlRWxlbWVudCIsIndpbmRvdyIsImdldFNjcm9sbFhDb29yZGluYXRlIiwic2Nyb2xsWCIsInNjcm9sbExlZnQiLCJnZXRTY3JvbGxZQ29vcmRpbmF0ZSIsInNjcm9sbFkiLCJzY3JvbGxUb3AiLCJnZXRTY3JvbGxDb29yZGluYXRlcyIsIkRpcmVjdGlvbiIsImlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNjcm9sbGluZ0NvbnRhaW5lciIsIm1pblNjcm9sbCIsImRpbWVuc2lvbnMiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsIm1heFNjcm9sbCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiaXNUb3AiLCJpc0xlZnQiLCJpc0JvdHRvbSIsImlzUmlnaHQiLCJkZWZhdWx0VGhyZXNob2xkIiwiZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQiLCJzY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXJSZWN0IiwiYWNjZWxlcmF0aW9uIiwidGhyZXNob2xkUGVyY2VudGFnZSIsImRpcmVjdGlvbiIsInNwZWVkIiwidGhyZXNob2xkIiwiQmFja3dhcmQiLCJhYnMiLCJGb3J3YXJkIiwiZ2V0U2Nyb2xsRWxlbWVudFJlY3QiLCJnZXRTY3JvbGxPZmZzZXRzIiwic2Nyb2xsYWJsZUFuY2VzdG9ycyIsImdldFNjcm9sbFhPZmZzZXQiLCJnZXRTY3JvbGxZT2Zmc2V0Iiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsIm1lYXN1cmUiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiaW5saW5lIiwiUmVjdCIsImNvbnN0cnVjdG9yIiwic2Nyb2xsT2Zmc2V0cyIsImF4aXMiLCJrZXlzIiwiZ2V0U2Nyb2xsT2Zmc2V0Iiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjdXJyZW50T2Zmc2V0cyIsInNjcm9sbE9mZnNldHNEZWx0bGEiLCJlbnVtZXJhYmxlIiwiTGlzdGVuZXJzIiwicmVtb3ZlQWxsIiwiX3RoaXMkdGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJfdGhpcyR0YXJnZXQyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldEV2ZW50TGlzdGVuZXJUYXJnZXQiLCJFdmVudFRhcmdldCIsImhhc0V4Y2VlZGVkRGlzdGFuY2UiLCJkZWx0YSIsIm1lYXN1cmVtZW50IiwiZHgiLCJkeSIsIkV2ZW50TmFtZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiS2V5Ym9hcmRDb2RlIiwiZGVmYXVsdEtleWJvYXJkQ29kZXMiLCJzdGFydCIsIlNwYWNlIiwiRW50ZXIiLCJjYW5jZWwiLCJFc2MiLCJlbmQiLCJUYWIiLCJkZWZhdWx0S2V5Ym9hcmRDb29yZGluYXRlR2V0dGVyIiwiY3VycmVudENvb3JkaW5hdGVzIiwiY29kZSIsIlJpZ2h0IiwiTGVmdCIsIkRvd24iLCJVcCIsInVuZGVmaW5lZCIsIktleWJvYXJkU2Vuc29yIiwicHJvcHMiLCJhdXRvU2Nyb2xsRW5hYmxlZCIsInJlZmVyZW5jZUNvb3JkaW5hdGVzIiwid2luZG93TGlzdGVuZXJzIiwiaGFuZGxlS2V5RG93biIsImJpbmQiLCJoYW5kbGVDYW5jZWwiLCJhdHRhY2giLCJoYW5kbGVTdGFydCIsIlJlc2l6ZSIsIlZpc2liaWxpdHlDaGFuZ2UiLCJzZXRUaW1lb3V0IiwiS2V5ZG93biIsImFjdGl2ZU5vZGUiLCJvblN0YXJ0IiwiY3VycmVudCIsImNvbnRleHQiLCJrZXlib2FyZENvZGVzIiwiY29vcmRpbmF0ZUdldHRlciIsInNjcm9sbEJlaGF2aW9yIiwiaGFuZGxlRW5kIiwibmV3Q29vcmRpbmF0ZXMiLCJjb29yZGluYXRlc0RlbHRhIiwic2Nyb2xsRGVsdGEiLCJzY3JvbGxFbGVtZW50UmVjdCIsImNsYW1wZWRDb29yZGluYXRlcyIsImNhblNjcm9sbFgiLCJjYW5TY3JvbGxZIiwibmV3U2Nyb2xsQ29vcmRpbmF0ZXMiLCJjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsInNjcm9sbEJ5IiwiaGFuZGxlTW92ZSIsImNvb3JkaW5hdGVzIiwib25Nb3ZlIiwib25FbmQiLCJkZXRhY2giLCJvbkNhbmNlbCIsImFjdGl2YXRvcnMiLCJvbkFjdGl2YXRpb24iLCJuYXRpdmVFdmVudCIsImFjdGl2YXRvciIsImFjdGl2YXRvck5vZGUiLCJpc0Rpc3RhbmNlQ29uc3RyYWludCIsImNvbnN0cmFpbnQiLCJCb29sZWFuIiwiaXNEZWxheUNvbnN0cmFpbnQiLCJBYnN0cmFjdFBvaW50ZXJTZW5zb3IiLCJldmVudHMiLCJsaXN0ZW5lclRhcmdldCIsIl9nZXRFdmVudENvb3JkaW5hdGVzIiwiYWN0aXZhdGVkIiwiaW5pdGlhbENvb3JkaW5hdGVzIiwidGltZW91dElkIiwiZG9jdW1lbnRMaXN0ZW5lcnMiLCJoYW5kbGVLZXlkb3duIiwicmVtb3ZlVGV4dFNlbGVjdGlvbiIsImFjdGl2YXRpb25Db25zdHJhaW50IiwiYnlwYXNzQWN0aXZhdGlvbkNvbnN0cmFpbnQiLCJtb3ZlIiwibmFtZSIsInBhc3NpdmUiLCJEcmFnU3RhcnQiLCJDb250ZXh0TWVudSIsImRlbGF5IiwiaGFuZGxlUGVuZGluZyIsImNsZWFyVGltZW91dCIsIm9mZnNldCIsIm9uUGVuZGluZyIsIkNsaWNrIiwiY2FwdHVyZSIsIlNlbGVjdGlvbkNoYW5nZSIsIl9nZXRFdmVudENvb3JkaW5hdGVzMiIsInRvbGVyYW5jZSIsImRpc3RhbmNlIiwiY2FuY2VsYWJsZSIsIm9uQWJvcnQiLCJfdGhpcyRkb2N1bWVudCRnZXRTZWwiLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJQb2ludGVyU2Vuc29yIiwiaXNQcmltYXJ5IiwiYnV0dG9uIiwiZXZlbnRzJDEiLCJNb3VzZUJ1dHRvbiIsIk1vdXNlU2Vuc29yIiwiUmlnaHRDbGljayIsImV2ZW50cyQyIiwiVG91Y2hTZW5zb3IiLCJzZXR1cCIsInRlYXJkb3duIiwidG91Y2hlcyIsIkF1dG9TY3JvbGxBY3RpdmF0b3IiLCJUcmF2ZXJzYWxPcmRlciIsInVzZUF1dG9TY3JvbGxlciIsIlBvaW50ZXIiLCJjYW5TY3JvbGwiLCJkcmFnZ2luZ1JlY3QiLCJlbmFibGVkIiwiaW50ZXJ2YWwiLCJvcmRlciIsIlRyZWVPcmRlciIsInNjcm9sbGFibGVBbmNlc3RvclJlY3RzIiwic2Nyb2xsSW50ZW50IiwidXNlU2Nyb2xsSW50ZW50IiwiZGlzYWJsZWQiLCJzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwiLCJjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCIsInNjcm9sbFNwZWVkIiwic2Nyb2xsRGlyZWN0aW9uIiwiRHJhZ2dhYmxlUmVjdCIsInNjcm9sbENvbnRhaW5lclJlZiIsImF1dG9TY3JvbGwiLCJzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzIiwicmV2ZXJzZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWZhdWx0U2Nyb2xsSW50ZW50IiwicHJldmlvdXNEZWx0YSIsInByZXZpb3VzSW50ZW50Iiwic2lnbiIsInVzZUNhY2hlZE5vZGUiLCJkcmFnZ2FibGVOb2RlcyIsImRyYWdnYWJsZU5vZGUiLCJjYWNoZWROb2RlIiwidXNlQ29tYmluZUFjdGl2YXRvcnMiLCJnZXRTeW50aGV0aWNIYW5kbGVyIiwiU2Vuc29yIiwic2Vuc29yQWN0aXZhdG9ycyIsIm1hcCIsIk1lYXN1cmluZ1N0cmF0ZWd5IiwiTWVhc3VyaW5nRnJlcXVlbmN5IiwiZGVmYXVsdFZhbHVlIiwiTWFwIiwidXNlRHJvcHBhYmxlTWVhc3VyaW5nIiwiY29udGFpbmVycyIsImRyYWdnaW5nIiwiZGVwZW5kZW5jaWVzIiwiY29uZmlnIiwicXVldWUiLCJzZXRRdWV1ZSIsImZyZXF1ZW5jeSIsInN0cmF0ZWd5IiwiY29udGFpbmVyc1JlZiIsImlzRGlzYWJsZWQiLCJkaXNhYmxlZFJlZiIsIm1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzIiwiaWRzIiwiY29uY2F0IiwicHJldmlvdXNWYWx1ZSIsInNldCIsIm1lYXN1cmluZ1NjaGVkdWxlZCIsIkFsd2F5cyIsIkJlZm9yZURyYWdnaW5nIiwidXNlSW5pdGlhbFZhbHVlIiwiY29tcHV0ZUZuIiwidXNlSW5pdGlhbFJlY3QiLCJ1c2VNdXRhdGlvbk9ic2VydmVyIiwiY2FsbGJhY2siLCJoYW5kbGVNdXRhdGlvbnMiLCJtdXRhdGlvbk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJ1c2VSZXNpemVPYnNlcnZlciIsImhhbmRsZVJlc2l6ZSIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJkZWZhdWx0TWVhc3VyZSIsInVzZVJlY3QiLCJmYWxsYmFja1JlY3QiLCJzZXRSZWN0IiwibWVhc3VyZVJlY3QiLCJjdXJyZW50UmVjdCIsImlzQ29ubmVjdGVkIiwibmV3UmVjdCIsInJlY29yZHMiLCJyZWNvcmQiLCJIVE1MRWxlbWVudCIsImNvbnRhaW5zIiwib2JzZXJ2ZSIsImJvZHkiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwidXNlUmVjdERlbHRhIiwiaW5pdGlhbFJlY3QiLCJkZWZhdWx0VmFsdWUkMSIsInVzZVNjcm9sbGFibGVBbmNlc3RvcnMiLCJwcmV2aW91c05vZGUiLCJhbmNlc3RvcnMiLCJ1c2VTY3JvbGxPZmZzZXRzIiwiZWxlbWVudHMiLCJzY3JvbGxDb29yZGluYXRlcyIsInNldFNjcm9sbENvb3JkaW5hdGVzIiwicHJldkVsZW1lbnRzIiwiaGFuZGxlU2Nyb2xsIiwicHJldmlvdXNFbGVtZW50cyIsImNsZWFudXAiLCJlbnRyaWVzIiwic2Nyb2xsYWJsZUVsZW1lbnQiLCJmcm9tIiwidmFsdWVzIiwidXNlU2Nyb2xsT2Zmc2V0c0RlbHRhIiwiaW5pdGlhbFNjcm9sbE9mZnNldHMiLCJoYXNTY3JvbGxPZmZzZXRzIiwidXNlU2Vuc29yU2V0dXAiLCJ0ZWFyZG93bkZucyIsInVzZVN5bnRoZXRpY0xpc3RlbmVycyIsInVzZVdpbmRvd1JlY3QiLCJkZWZhdWx0VmFsdWUkMiIsInVzZVJlY3RzIiwiZmlyc3RFbGVtZW50Iiwid2luZG93UmVjdCIsInJlY3RzIiwic2V0UmVjdHMiLCJtZWFzdXJlUmVjdHMiLCJnZXRNZWFzdXJhYmxlTm9kZSIsImNoaWxkcmVuIiwiZmlyc3RDaGlsZCIsInVzZURyYWdPdmVybGF5TWVhc3VyaW5nIiwiaGFuZGxlTm9kZUNoYW5nZSIsIm5vZGVSZWYiLCJzZXRSZWYiLCJkZWZhdWx0U2Vuc29ycyIsImRlZmF1bHREYXRhIiwiZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJkcm9wcGFibGUiLCJXaGlsZURyYWdnaW5nIiwiT3B0aW1pemVkIiwiZHJhZ092ZXJsYXkiLCJEcm9wcGFibGVDb250YWluZXJzTWFwIiwiX3N1cGVyJGdldCIsInRvQXJyYXkiLCJnZXRFbmFibGVkIiwiZ2V0Tm9kZUZvciIsIl90aGlzJGdldCRub2RlJGN1cnJlbiIsIl90aGlzJGdldCIsImRlZmF1bHRQdWJsaWNDb250ZXh0IiwiYWN0aXZhdG9yRXZlbnQiLCJhY3RpdmVOb2RlUmVjdCIsImNvbnRhaW5lck5vZGVSZWN0IiwibWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsImRlZmF1bHRJbnRlcm5hbENvbnRleHQiLCJhcmlhRGVzY3JpYmVkQnlJZCIsIkludGVybmFsQ29udGV4dCIsIlB1YmxpY0NvbnRleHQiLCJnZXRJbml0aWFsU3RhdGUiLCJub2RlcyIsInRyYW5zbGF0ZSIsInJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsIkRyYWdNb3ZlIiwiRHJhZ0VuZCIsIkRyYWdDYW5jZWwiLCJSZWdpc3RlckRyb3BwYWJsZSIsIlNldERyb3BwYWJsZURpc2FibGVkIiwiVW5yZWdpc3RlckRyb3BwYWJsZSIsIlJlc3RvcmVGb2N1cyIsInByZXZpb3VzQWN0aXZhdG9yRXZlbnQiLCJwcmV2aW91c0FjdGl2ZUlkIiwiYWN0aXZlRWxlbWVudCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImZvY3VzYWJsZU5vZGUiLCJmb2N1cyIsImFwcGx5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiYXJncyIsInVzZU1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJ1c2VMYXlvdXRTaGlmdFNjcm9sbENvbXBlbnNhdGlvbiIsImluaXRpYWxpemVkIiwicmVjdERlbHRhIiwiQWN0aXZlRHJhZ2dhYmxlQ29udGV4dCIsIlN0YXR1cyIsIkRuZENvbnRleHQiLCJfc2Vuc29yQ29udGV4dCRjdXJyZW4iLCJfZHJhZ092ZXJsYXkkbm9kZVJlZiQiLCJfZHJhZ092ZXJsYXkkcmVjdCIsIl9vdmVyJHJlY3QiLCJhY2Nlc3NpYmlsaXR5IiwiY29sbGlzaW9uRGV0ZWN0aW9uIiwibWVhc3VyaW5nIiwic3RvcmUiLCJkaXNwYXRjaE1vbml0b3JFdmVudCIsInJlZ2lzdGVyTW9uaXRvckxpc3RlbmVyIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiVW5pbml0aWFsaXplZCIsImlzSW5pdGlhbGl6ZWQiLCJJbml0aWFsaXplZCIsImFjdGl2ZUlkIiwiYWN0aXZlUmVjdHMiLCJpbml0aWFsIiwidHJhbnNsYXRlZCIsIl9ub2RlJGRhdGEiLCJhY3RpdmVSZWYiLCJhY3RpdmVTZW5zb3IiLCJzZXRBY3RpdmVTZW5zb3IiLCJzZXRBY3RpdmF0b3JFdmVudCIsImxhdGVzdFByb3BzIiwiZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZCIsImVuYWJsZWREcm9wcGFibGVDb250YWluZXJzIiwiYWN0aXZhdGlvbkNvb3JkaW5hdGVzIiwiYXV0b1Njcm9sbE9wdGlvbnMiLCJnZXRBdXRvU2Nyb2xsZXJPcHRpb25zIiwiaW5pdGlhbEFjdGl2ZU5vZGVSZWN0IiwibGF5b3V0U2hpZnRDb21wZW5zYXRpb24iLCJwYXJlbnRFbGVtZW50Iiwic2Vuc29yQ29udGV4dCIsImRyYWdnaW5nTm9kZSIsImRyYWdnaW5nTm9kZVJlY3QiLCJzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSIsIm92ZXJOb2RlIiwidXNlc0RyYWdPdmVybGF5Iiwibm9kZVJlY3REZWx0YSIsIm1vZGlmaWVkVHJhbnNsYXRlIiwib3ZlcmxheU5vZGVSZWN0Iiwic2Nyb2xsQWRqdXN0bWVudCIsImFjdGl2ZU5vZGVTY3JvbGxEZWx0YSIsIm92ZXJJZCIsInNldE92ZXIiLCJhcHBsaWVkVHJhbnNsYXRlIiwiYWN0aXZlU2Vuc29yUmVmIiwiaW5zdGFudGlhdGVTZW5zb3IiLCJzZW5zb3JJbnN0YW5jZSIsIm9uRHJhZ0Fib3J0Iiwib25EcmFnUGVuZGluZyIsIkluaXRpYWxpemluZyIsImNyZWF0ZUhhbmRsZXIiLCJjYW5jZWxEcm9wIiwic2hvdWxkQ2FuY2VsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJiaW5kQWN0aXZhdG9yVG9TZW5zb3JJbnN0YW50aWF0b3IiLCJhY3RpdmVEcmFnZ2FibGVOb2RlIiwiZG5kS2l0IiwiZGVmYXVsdFByZXZlbnRlZCIsImFjdGl2YXRpb25Db250ZXh0Iiwic2hvdWxkQWN0aXZhdGUiLCJjYXB0dXJlZEJ5Iiwib3ZlckNvbnRhaW5lciIsInB1YmxpY0NvbnRleHQiLCJpbnRlcm5hbENvbnRleHQiLCJQcm92aWRlciIsInJlc3RvcmVGb2N1cyIsImFjdGl2ZVNlbnNvckRpc2FibGVzQXV0b3Njcm9sbCIsImF1dG9TY3JvbGxHbG9iYWxseURpc2FibGVkIiwiTnVsbENvbnRleHQiLCJkZWZhdWx0Um9sZSIsIklEX1BSRUZJWCIsInVzZURyYWdnYWJsZSIsImF0dHJpYnV0ZXMiLCJyb2xlIiwicm9sZURlc2NyaXB0aW9uIiwidGFiSW5kZXgiLCJpc0RyYWdnaW5nIiwic2V0Tm9kZVJlZiIsInNldEFjdGl2YXRvck5vZGVSZWYiLCJkYXRhUmVmIiwibWVtb2l6ZWRBdHRyaWJ1dGVzIiwidXNlRG5kQ29udGV4dCIsIklEX1BSRUZJWCQxIiwiZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnIiwidGltZW91dCIsInVzZURyb3BwYWJsZSIsInJlc2l6ZU9ic2VydmVyQ29uZmlnIiwicHJldmlvdXMiLCJyZXNpemVPYnNlcnZlckNvbm5lY3RlZCIsImNhbGxiYWNrSWQiLCJyZXNpemVPYnNlcnZlckRpc2FibGVkIiwidXBkYXRlTWVhc3VyZW1lbnRzRm9yIiwicmVzaXplT2JzZXJ2ZXJUaW1lb3V0IiwiaXNBcnJheSIsIm5ld0VsZW1lbnQiLCJwcmV2aW91c0VsZW1lbnQiLCJ1bm9ic2VydmUiLCJpc092ZXIiLCJBbmltYXRpb25NYW5hZ2VyIiwiYW5pbWF0aW9uIiwiY2xvbmVkQ2hpbGRyZW4iLCJzZXRDbG9uZWRDaGlsZHJlbiIsInNldEVsZW1lbnQiLCJwcmV2aW91c0NoaWxkcmVuIiwidGhlbiIsInJlZiIsImRlZmF1bHRUcmFuc2Zvcm0iLCJOdWxsaWZpZWRDb250ZXh0UHJvdmlkZXIiLCJiYXNlU3R5bGVzIiwidG91Y2hBY3Rpb24iLCJkZWZhdWx0VHJhbnNpdGlvbiIsImlzS2V5Ym9hcmRBY3RpdmF0b3IiLCJQb3NpdGlvbmVkT3ZlcmxheSIsImFzIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwic2NhbGVBZGp1c3RlZFRyYW5zZm9ybSIsInN0eWxlcyIsIlRyYW5zZm9ybSIsInRvU3RyaW5nIiwiZGVmYXVsdERyb3BBbmltYXRpb25TaWRlRWZmZWN0cyIsIm9yaWdpbmFsU3R5bGVzIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInNldFByb3BlcnR5IiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiZGVmYXVsdEtleWZyYW1lUmVzb2x2ZXIiLCJmaW5hbCIsImRlZmF1bHREcm9wQW5pbWF0aW9uQ29uZmlndXJhdGlvbiIsImR1cmF0aW9uIiwiZWFzaW5nIiwia2V5ZnJhbWVzIiwic2lkZUVmZmVjdHMiLCJvcGFjaXR5IiwidXNlRHJvcEFuaW1hdGlvbiIsImFjdGl2ZURyYWdnYWJsZSIsIm1lYXN1cmFibGVOb2RlIiwiY3JlYXRlRGVmYXVsdERyb3BBbmltYXRpb24iLCJyZXN0Iiwic2NhbGUiLCJmaW5hbFRyYW5zZm9ybSIsImFuaW1hdGlvbktleWZyYW1lcyIsImZpcnN0S2V5ZnJhbWUiLCJsYXN0S2V5ZnJhbWUiLCJhbmltYXRlIiwiZmlsbCIsIm9uZmluaXNoIiwidXNlS2V5IiwiRHJhZ092ZXJsYXkiLCJkcm9wQW5pbWF0aW9uIiwiZHJvcEFuaW1hdGlvbkNvbmZpZyIsIndyYXBwZXJFbGVtZW50IiwiekluZGV4IiwibW9kaWZpZWRUcmFuc2Zvcm0iLCJkZWZhdWx0RHJvcEFuaW1hdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/core/dist/core.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@dnd-kit/sortable/dist/sortable.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dnd-kit/sortable/dist/sortable.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SortableContext: () => (/* binding */ SortableContext),\n/* harmony export */   arrayMove: () => (/* binding */ arrayMove),\n/* harmony export */   arraySwap: () => (/* binding */ arraySwap),\n/* harmony export */   defaultAnimateLayoutChanges: () => (/* binding */ defaultAnimateLayoutChanges),\n/* harmony export */   defaultNewIndexGetter: () => (/* binding */ defaultNewIndexGetter),\n/* harmony export */   hasSortableData: () => (/* binding */ hasSortableData),\n/* harmony export */   horizontalListSortingStrategy: () => (/* binding */ horizontalListSortingStrategy),\n/* harmony export */   rectSortingStrategy: () => (/* binding */ rectSortingStrategy),\n/* harmony export */   rectSwappingStrategy: () => (/* binding */ rectSwappingStrategy),\n/* harmony export */   sortableKeyboardCoordinates: () => (/* binding */ sortableKeyboardCoordinates),\n/* harmony export */   useSortable: () => (/* binding */ useSortable),\n/* harmony export */   verticalListSortingStrategy: () => (/* binding */ verticalListSortingStrategy)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/core */ \"(ssr)/./node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n\n\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */ function arrayMove(array, from, to) {\n    const newArray = array.slice();\n    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n    return newArray;\n}\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */ function arraySwap(array, from, to) {\n    const newArray = array.slice();\n    newArray[from] = array[to];\n    newArray[to] = array[from];\n    return newArray;\n}\nfunction getSortedRects(items, rects) {\n    return items.reduce((accumulator, id, index)=>{\n        const rect = rects.get(id);\n        if (rect) {\n            accumulator[index] = rect;\n        }\n        return accumulator;\n    }, Array(items.length));\n}\nfunction isValidIndex(index) {\n    return index !== null && index >= 0;\n}\nfunction itemsEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction normalizeDisabled(disabled) {\n    if (typeof disabled === \"boolean\") {\n        return {\n            draggable: disabled,\n            droppable: disabled\n        };\n    }\n    return disabled;\n}\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst horizontalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { rects, activeNodeRect: fallbackActiveRect, activeIndex, overIndex, index } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    const itemGap = getItemGap(rects, index, activeIndex);\n    if (index === activeIndex) {\n        const newIndexRect = rects[overIndex];\n        if (!newIndexRect) {\n            return null;\n        }\n        return {\n            x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: -activeNodeRect.width - itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: activeNodeRect.width + itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale\n    };\n};\nfunction getItemGap(rects, index, activeIndex) {\n    const currentRect = rects[index];\n    const previousRect = rects[index - 1];\n    const nextRect = rects[index + 1];\n    if (!currentRect || !previousRect && !nextRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n    }\n    return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\nconst rectSortingStrategy = (_ref)=>{\n    let { rects, activeIndex, overIndex, index } = _ref;\n    const newRects = arrayMove(rects, overIndex, activeIndex);\n    const oldRect = rects[index];\n    const newRect = newRects[index];\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\nconst rectSwappingStrategy = (_ref)=>{\n    let { activeIndex, index, rects, overIndex } = _ref;\n    let oldRect;\n    let newRect;\n    if (index === activeIndex) {\n        oldRect = rects[index];\n        newRect = rects[overIndex];\n    }\n    if (index === overIndex) {\n        oldRect = rects[index];\n        newRect = rects[activeIndex];\n    }\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst verticalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { activeIndex, activeNodeRect: fallbackActiveRect, index, rects, overIndex } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    if (index === activeIndex) {\n        const overIndexRect = rects[overIndex];\n        if (!overIndexRect) {\n            return null;\n        }\n        return {\n            x: 0,\n            y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n            ...defaultScale$1\n        };\n    }\n    const itemGap = getItemGap$1(rects, index, activeIndex);\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: 0,\n            y: -activeNodeRect.height - itemGap,\n            ...defaultScale$1\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: 0,\n            y: activeNodeRect.height + itemGap,\n            ...defaultScale$1\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale$1\n    };\n};\nfunction getItemGap$1(clientRects, index, activeIndex) {\n    const currentRect = clientRects[index];\n    const previousRect = clientRects[index - 1];\n    const nextRect = clientRects[index + 1];\n    if (!currentRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n    }\n    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\nconst ID_PREFIX = \"Sortable\";\nconst Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    activeIndex: -1,\n    containerId: ID_PREFIX,\n    disableTransforms: false,\n    items: [],\n    overIndex: -1,\n    useDragOverlay: false,\n    sortedRects: [],\n    strategy: rectSortingStrategy,\n    disabled: {\n        draggable: false,\n        droppable: false\n    }\n});\nfunction SortableContext(_ref) {\n    let { children, id, items: userDefinedItems, strategy = rectSortingStrategy, disabled: disabledProp = false } = _ref;\n    const { active, dragOverlay, droppableRects, over, measureDroppableContainers } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDndContext)();\n    const containerId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX, id);\n    const useDragOverlay = Boolean(dragOverlay.rect !== null);\n    const items = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>userDefinedItems.map((item)=>typeof item === \"object\" && \"id\" in item ? item.id : item), [\n        userDefinedItems\n    ]);\n    const isDragging = active != null;\n    const activeIndex = active ? items.indexOf(active.id) : -1;\n    const overIndex = over ? items.indexOf(over.id) : -1;\n    const previousItemsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(items);\n    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n    const disabled = normalizeDisabled(disabledProp);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (itemsHaveChanged && isDragging) {\n            measureDroppableContainers(items);\n        }\n    }, [\n        itemsHaveChanged,\n        items,\n        isDragging,\n        measureDroppableContainers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousItemsRef.current = items;\n    }, [\n        items\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            activeIndex,\n            containerId,\n            disabled,\n            disableTransforms,\n            items,\n            overIndex,\n            useDragOverlay,\n            sortedRects: getSortedRects(items, droppableRects),\n            strategy\n        }), [\n        activeIndex,\n        containerId,\n        disabled.draggable,\n        disabled.droppable,\n        disableTransforms,\n        items,\n        overIndex,\n        droppableRects,\n        useDragOverlay,\n        strategy\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nconst defaultNewIndexGetter = (_ref)=>{\n    let { id, items, activeIndex, overIndex } = _ref;\n    return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nconst defaultAnimateLayoutChanges = (_ref2)=>{\n    let { containerId, isSorting, wasDragging, index, items, newIndex, previousItems, previousContainerId, transition } = _ref2;\n    if (!transition || !wasDragging) {\n        return false;\n    }\n    if (previousItems !== items && index === newIndex) {\n        return false;\n    }\n    if (isSorting) {\n        return true;\n    }\n    return newIndex !== index && containerId === previousContainerId;\n};\nconst defaultTransition = {\n    duration: 200,\n    easing: \"ease\"\n};\nconst transitionProperty = \"transform\";\nconst disabledTransition = /*#__PURE__*/ _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n    property: transitionProperty,\n    duration: 0,\n    easing: \"linear\"\n});\nconst defaultAttributes = {\n    roleDescription: \"sortable\"\n};\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */ function useDerivedTransform(_ref) {\n    let { disabled, index, node, rect } = _ref;\n    const [derivedTransform, setDerivedtransform] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(index);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!disabled && index !== previousIndex.current && node.current) {\n            const initial = rect.current;\n            if (initial) {\n                const current = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getClientRect)(node.current, {\n                    ignoreTransform: true\n                });\n                const delta = {\n                    x: initial.left - current.left,\n                    y: initial.top - current.top,\n                    scaleX: initial.width / current.width,\n                    scaleY: initial.height / current.height\n                };\n                if (delta.x || delta.y) {\n                    setDerivedtransform(delta);\n                }\n            }\n        }\n        if (index !== previousIndex.current) {\n            previousIndex.current = index;\n        }\n    }, [\n        disabled,\n        index,\n        node,\n        rect\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (derivedTransform) {\n            setDerivedtransform(null);\n        }\n    }, [\n        derivedTransform\n    ]);\n    return derivedTransform;\n}\nfunction useSortable(_ref) {\n    let { animateLayoutChanges = defaultAnimateLayoutChanges, attributes: userDefinedAttributes, disabled: localDisabled, data: customData, getNewIndex = defaultNewIndexGetter, id, strategy: localStrategy, resizeObserverConfig, transition = defaultTransition } = _ref;\n    const { items, containerId, activeIndex, disabled: globalDisabled, disableTransforms, sortedRects, overIndex, useDragOverlay, strategy: globalStrategy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n    const index = items.indexOf(id);\n    const data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sortable: {\n                containerId,\n                index,\n                items\n            },\n            ...customData\n        }), [\n        containerId,\n        customData,\n        index,\n        items\n    ]);\n    const itemsAfterCurrentSortable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>items.slice(items.indexOf(id)), [\n        items,\n        id\n    ]);\n    const { rect, node, isOver, setNodeRef: setDroppableNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDroppable)({\n        id,\n        data,\n        disabled: disabled.droppable,\n        resizeObserverConfig: {\n            updateMeasurementsFor: itemsAfterCurrentSortable,\n            ...resizeObserverConfig\n        }\n    });\n    const { active, activatorEvent, activeNodeRect, attributes, setNodeRef: setDraggableNodeRef, listeners, isDragging, over, setActivatorNodeRef, transform } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({\n        id,\n        data,\n        attributes: {\n            ...defaultAttributes,\n            ...userDefinedAttributes\n        },\n        disabled: disabled.draggable\n    });\n    const setNodeRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useCombinedRefs)(setDroppableNodeRef, setDraggableNodeRef);\n    const isSorting = Boolean(active);\n    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n    const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n    const strategy = localStrategy != null ? localStrategy : globalStrategy;\n    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index\n    }) : null;\n    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n        id,\n        items,\n        activeIndex,\n        overIndex\n    }) : index;\n    const activeId = active == null ? void 0 : active.id;\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activeId,\n        items,\n        newIndex,\n        containerId\n    });\n    const itemsHaveChanged = items !== previous.current.items;\n    const shouldAnimateLayoutChanges = animateLayoutChanges({\n        active,\n        containerId,\n        isDragging,\n        isSorting,\n        id,\n        index,\n        items,\n        newIndex: previous.current.newIndex,\n        previousItems: previous.current.items,\n        previousContainerId: previous.current.containerId,\n        transition,\n        wasDragging: previous.current.activeId != null\n    });\n    const derivedTransform = useDerivedTransform({\n        disabled: !shouldAnimateLayoutChanges,\n        index,\n        node,\n        rect\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isSorting && previous.current.newIndex !== newIndex) {\n            previous.current.newIndex = newIndex;\n        }\n        if (containerId !== previous.current.containerId) {\n            previous.current.containerId = containerId;\n        }\n        if (items !== previous.current.items) {\n            previous.current.items = items;\n        }\n    }, [\n        isSorting,\n        newIndex,\n        containerId,\n        items\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (activeId === previous.current.activeId) {\n            return;\n        }\n        if (activeId && !previous.current.activeId) {\n            previous.current.activeId = activeId;\n            return;\n        }\n        const timeoutId = setTimeout(()=>{\n            previous.current.activeId = activeId;\n        }, 50);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        activeId\n    ]);\n    return {\n        active,\n        activeIndex,\n        attributes,\n        data,\n        rect,\n        index,\n        newIndex,\n        items,\n        isOver,\n        isSorting,\n        isDragging,\n        listeners,\n        node,\n        overIndex,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        setDroppableNodeRef,\n        setDraggableNodeRef,\n        transform: derivedTransform != null ? derivedTransform : finalTransform,\n        transition: getTransition()\n    };\n    function getTransition() {\n        if (derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n        itemsHaveChanged && previous.current.newIndex === index) {\n            return disabledTransition;\n        }\n        if (shouldDisplaceDragSource && !(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent) || !transition) {\n            return undefined;\n        }\n        if (isSorting || shouldAnimateLayoutChanges) {\n            return _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n                ...transition,\n                property: transitionProperty\n            });\n        }\n        return undefined;\n    }\n}\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n    var _localDisabled$dragga, _localDisabled$droppa;\n    if (typeof localDisabled === \"boolean\") {\n        return {\n            draggable: localDisabled,\n            // Backwards compatibility\n            droppable: false\n        };\n    }\n    return {\n        draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n        droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n    };\n}\nfunction hasSortableData(entry) {\n    if (!entry) {\n        return false;\n    }\n    const data = entry.data.current;\n    if (data && \"sortable\" in data && typeof data.sortable === \"object\" && \"containerId\" in data.sortable && \"items\" in data.sortable && \"index\" in data.sortable) {\n        return true;\n    }\n    return false;\n}\nconst directions = [\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left\n];\nconst sortableKeyboardCoordinates = (event, _ref)=>{\n    let { context: { active, collisionRect, droppableRects, droppableContainers, over, scrollableAncestors } } = _ref;\n    if (directions.includes(event.code)) {\n        event.preventDefault();\n        if (!active || !collisionRect) {\n            return;\n        }\n        const filteredContainers = [];\n        droppableContainers.getEnabled().forEach((entry)=>{\n            if (!entry || entry != null && entry.disabled) {\n                return;\n            }\n            const rect = droppableRects.get(entry.id);\n            if (!rect) {\n                return;\n            }\n            switch(event.code){\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down:\n                    if (collisionRect.top < rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up:\n                    if (collisionRect.top > rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left:\n                    if (collisionRect.left > rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right:\n                    if (collisionRect.left < rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n            }\n        });\n        const collisions = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.closestCorners)({\n            active,\n            collisionRect: collisionRect,\n            droppableRects,\n            droppableContainers: filteredContainers,\n            pointerCoordinates: null\n        });\n        let closestId = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getFirstCollision)(collisions, \"id\");\n        if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n            closestId = collisions[1].id;\n        }\n        if (closestId != null) {\n            const activeDroppable = droppableContainers.get(active.id);\n            const newDroppable = droppableContainers.get(closestId);\n            const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n            const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n            if (newNode && newRect && activeDroppable && newDroppable) {\n                const newScrollAncestors = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(newNode);\n                const hasDifferentScrollAncestors = newScrollAncestors.some((element, index)=>scrollableAncestors[index] !== element);\n                const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n                const isAfterActive = isAfter(activeDroppable, newDroppable);\n                const offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n                    x: 0,\n                    y: 0\n                } : {\n                    x: isAfterActive ? collisionRect.width - newRect.width : 0,\n                    y: isAfterActive ? collisionRect.height - newRect.height : 0\n                };\n                const rectCoordinates = {\n                    x: newRect.left,\n                    y: newRect.top\n                };\n                const newCoordinates = offset.x && offset.y ? rectCoordinates : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(rectCoordinates, offset);\n                return newCoordinates;\n            }\n        }\n    }\n    return undefined;\n};\nfunction isSameContainer(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\nfunction isAfter(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    if (!isSameContainer(a, b)) {\n        return false;\n    }\n    return a.data.current.sortable.index < b.data.current.sortable.index;\n}\n //# sourceMappingURL=sortable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvc29ydGFibGUvZGlzdC9zb3J0YWJsZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRjtBQUNrRjtBQUNyQztBQUU3SDs7Q0FFQyxHQUNELFNBQVNvQixVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRTtJQUNoQyxNQUFNQyxXQUFXSCxNQUFNSSxLQUFLO0lBQzVCRCxTQUFTRSxNQUFNLENBQUNILEtBQUssSUFBSUMsU0FBU0csTUFBTSxHQUFHSixLQUFLQSxJQUFJLEdBQUdDLFNBQVNFLE1BQU0sQ0FBQ0osTUFBTSxFQUFFLENBQUMsRUFBRTtJQUNsRixPQUFPRTtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTSSxVQUFVUCxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRTtJQUNoQyxNQUFNQyxXQUFXSCxNQUFNSSxLQUFLO0lBQzVCRCxRQUFRLENBQUNGLEtBQUssR0FBR0QsS0FBSyxDQUFDRSxHQUFHO0lBQzFCQyxRQUFRLENBQUNELEdBQUcsR0FBR0YsS0FBSyxDQUFDQyxLQUFLO0lBQzFCLE9BQU9FO0FBQ1Q7QUFFQSxTQUFTSyxlQUFlQyxLQUFLLEVBQUVDLEtBQUs7SUFDbEMsT0FBT0QsTUFBTUUsTUFBTSxDQUFDLENBQUNDLGFBQWFDLElBQUlDO1FBQ3BDLE1BQU1DLE9BQU9MLE1BQU1NLEdBQUcsQ0FBQ0g7UUFFdkIsSUFBSUUsTUFBTTtZQUNSSCxXQUFXLENBQUNFLE1BQU0sR0FBR0M7UUFDdkI7UUFFQSxPQUFPSDtJQUNULEdBQUdLLE1BQU1SLE1BQU1ILE1BQU07QUFDdkI7QUFFQSxTQUFTWSxhQUFhSixLQUFLO0lBQ3pCLE9BQU9BLFVBQVUsUUFBUUEsU0FBUztBQUNwQztBQUVBLFNBQVNLLFdBQVdDLENBQUMsRUFBRUMsQ0FBQztJQUN0QixJQUFJRCxNQUFNQyxHQUFHO1FBQ1gsT0FBTztJQUNUO0lBRUEsSUFBSUQsRUFBRWQsTUFBTSxLQUFLZSxFQUFF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QUM2QyxRQUFRLENBQUNsRSxXQUFXO0FBQ3BGO0FBRUEsU0FBUzRILFFBQVF0SyxDQUFDLEVBQUVDLENBQUM7SUFDbkIsSUFBSSxDQUFDb0ksZ0JBQWdCckksTUFBTSxDQUFDcUksZ0JBQWdCcEksSUFBSTtRQUM5QyxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNtSyxnQkFBZ0JwSyxHQUFHQyxJQUFJO1FBQzFCLE9BQU87SUFDVDtJQUVBLE9BQU9ELEVBQUVvRyxJQUFJLENBQUNyQyxPQUFPLENBQUM2QyxRQUFRLENBQUNsSCxLQUFLLEdBQUdPLEVBQUVtRyxJQUFJLENBQUNyQyxPQUFPLENBQUM2QyxRQUFRLENBQUNsSCxLQUFLO0FBQ3RFO0FBRXVRLENBQ3ZRLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWR5Zm9ybXMtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L3NvcnRhYmxlL2Rpc3Qvc29ydGFibGUuZXNtLmpzPzY2ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZURuZENvbnRleHQsIGdldENsaWVudFJlY3QsIHVzZURyb3BwYWJsZSwgdXNlRHJhZ2dhYmxlLCBjbG9zZXN0Q29ybmVycywgZ2V0Rmlyc3RDb2xsaXNpb24sIGdldFNjcm9sbGFibGVBbmNlc3RvcnMsIEtleWJvYXJkQ29kZSB9IGZyb20gJ0BkbmQta2l0L2NvcmUnO1xuaW1wb3J0IHsgdXNlVW5pcXVlSWQsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIENTUywgdXNlQ29tYmluZWRSZWZzLCBpc0tleWJvYXJkRXZlbnQsIHN1YnRyYWN0IH0gZnJvbSAnQGRuZC1raXQvdXRpbGl0aWVzJztcblxuLyoqXHJcbiAqIE1vdmUgYW4gYXJyYXkgaXRlbSB0byBhIGRpZmZlcmVudCBwb3NpdGlvbi4gUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBpdGVtIG1vdmVkIHRvIHRoZSBuZXcgcG9zaXRpb24uXHJcbiAqL1xuZnVuY3Rpb24gYXJyYXlNb3ZlKGFycmF5LCBmcm9tLCB0bykge1xuICBjb25zdCBuZXdBcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gIG5ld0FycmF5LnNwbGljZSh0byA8IDAgPyBuZXdBcnJheS5sZW5ndGggKyB0byA6IHRvLCAwLCBuZXdBcnJheS5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxyXG4gKiBTd2FwIGFuIGFycmF5IGl0ZW0gdG8gYSBkaWZmZXJlbnQgcG9zaXRpb24uIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgaXRlbSBzd2FwcGVkIHRvIHRoZSBuZXcgcG9zaXRpb24uXHJcbiAqL1xuZnVuY3Rpb24gYXJyYXlTd2FwKGFycmF5LCBmcm9tLCB0bykge1xuICBjb25zdCBuZXdBcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gIG5ld0FycmF5W2Zyb21dID0gYXJyYXlbdG9dO1xuICBuZXdBcnJheVt0b10gPSBhcnJheVtmcm9tXTtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWRSZWN0cyhpdGVtcywgcmVjdHMpIHtcbiAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoYWNjdW11bGF0b3IsIGlkLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSByZWN0cy5nZXQoaWQpO1xuXG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGFjY3VtdWxhdG9yW2luZGV4XSA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9LCBBcnJheShpdGVtcy5sZW5ndGgpKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gIHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA+PSAwO1xufVxuXG5mdW5jdGlvbiBpdGVtc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVEaXNhYmxlZChkaXNhYmxlZCkge1xuICBpZiAodHlwZW9mIGRpc2FibGVkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhZ2dhYmxlOiBkaXNhYmxlZCxcbiAgICAgIGRyb3BwYWJsZTogZGlzYWJsZWRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRpc2FibGVkO1xufVxuXG4vLyBUby1kbzogV2Ugc2hvdWxkIGJlIGNhbGN1bGF0aW5nIHNjYWxlIHRyYW5zZm9ybWF0aW9uXG5jb25zdCBkZWZhdWx0U2NhbGUgPSB7XG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuY29uc3QgaG9yaXpvbnRhbExpc3RTb3J0aW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgdmFyIF9yZWN0cyRhY3RpdmVJbmRleDtcblxuICBsZXQge1xuICAgIHJlY3RzLFxuICAgIGFjdGl2ZU5vZGVSZWN0OiBmYWxsYmFja0FjdGl2ZVJlY3QsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4LFxuICAgIGluZGV4XG4gIH0gPSBfcmVmO1xuICBjb25zdCBhY3RpdmVOb2RlUmVjdCA9IChfcmVjdHMkYWN0aXZlSW5kZXggPSByZWN0c1thY3RpdmVJbmRleF0pICE9IG51bGwgPyBfcmVjdHMkYWN0aXZlSW5kZXggOiBmYWxsYmFja0FjdGl2ZVJlY3Q7XG5cbiAgaWYgKCFhY3RpdmVOb2RlUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaXRlbUdhcCA9IGdldEl0ZW1HYXAocmVjdHMsIGluZGV4LCBhY3RpdmVJbmRleCk7XG5cbiAgaWYgKGluZGV4ID09PSBhY3RpdmVJbmRleCkge1xuICAgIGNvbnN0IG5ld0luZGV4UmVjdCA9IHJlY3RzW292ZXJJbmRleF07XG5cbiAgICBpZiAoIW5ld0luZGV4UmVjdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGFjdGl2ZUluZGV4IDwgb3ZlckluZGV4ID8gbmV3SW5kZXhSZWN0LmxlZnQgKyBuZXdJbmRleFJlY3Qud2lkdGggLSAoYWN0aXZlTm9kZVJlY3QubGVmdCArIGFjdGl2ZU5vZGVSZWN0LndpZHRoKSA6IG5ld0luZGV4UmVjdC5sZWZ0IC0gYWN0aXZlTm9kZVJlY3QubGVmdCxcbiAgICAgIHk6IDAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGluZGV4ID4gYWN0aXZlSW5kZXggJiYgaW5kZXggPD0gb3ZlckluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IC1hY3RpdmVOb2RlUmVjdC53aWR0aCAtIGl0ZW1HYXAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpbmRleCA8IGFjdGl2ZUluZGV4ICYmIGluZGV4ID49IG92ZXJJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBhY3RpdmVOb2RlUmVjdC53aWR0aCArIGl0ZW1HYXAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIC4uLmRlZmF1bHRTY2FsZVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0SXRlbUdhcChyZWN0cywgaW5kZXgsIGFjdGl2ZUluZGV4KSB7XG4gIGNvbnN0IGN1cnJlbnRSZWN0ID0gcmVjdHNbaW5kZXhdO1xuICBjb25zdCBwcmV2aW91c1JlY3QgPSByZWN0c1tpbmRleCAtIDFdO1xuICBjb25zdCBuZXh0UmVjdCA9IHJlY3RzW2luZGV4ICsgMV07XG5cbiAgaWYgKCFjdXJyZW50UmVjdCB8fCAhcHJldmlvdXNSZWN0ICYmICFuZXh0UmVjdCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFjdGl2ZUluZGV4IDwgaW5kZXgpIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWN0ID8gY3VycmVudFJlY3QubGVmdCAtIChwcmV2aW91c1JlY3QubGVmdCArIHByZXZpb3VzUmVjdC53aWR0aCkgOiBuZXh0UmVjdC5sZWZ0IC0gKGN1cnJlbnRSZWN0LmxlZnQgKyBjdXJyZW50UmVjdC53aWR0aCk7XG4gIH1cblxuICByZXR1cm4gbmV4dFJlY3QgPyBuZXh0UmVjdC5sZWZ0IC0gKGN1cnJlbnRSZWN0LmxlZnQgKyBjdXJyZW50UmVjdC53aWR0aCkgOiBjdXJyZW50UmVjdC5sZWZ0IC0gKHByZXZpb3VzUmVjdC5sZWZ0ICsgcHJldmlvdXNSZWN0LndpZHRoKTtcbn1cblxuY29uc3QgcmVjdFNvcnRpbmdTdHJhdGVneSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHJlY3RzLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG92ZXJJbmRleCxcbiAgICBpbmRleFxuICB9ID0gX3JlZjtcbiAgY29uc3QgbmV3UmVjdHMgPSBhcnJheU1vdmUocmVjdHMsIG92ZXJJbmRleCwgYWN0aXZlSW5kZXgpO1xuICBjb25zdCBvbGRSZWN0ID0gcmVjdHNbaW5kZXhdO1xuICBjb25zdCBuZXdSZWN0ID0gbmV3UmVjdHNbaW5kZXhdO1xuXG4gIGlmICghbmV3UmVjdCB8fCAhb2xkUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBuZXdSZWN0LmxlZnQgLSBvbGRSZWN0LmxlZnQsXG4gICAgeTogbmV3UmVjdC50b3AgLSBvbGRSZWN0LnRvcCxcbiAgICBzY2FsZVg6IG5ld1JlY3Qud2lkdGggLyBvbGRSZWN0LndpZHRoLFxuICAgIHNjYWxlWTogbmV3UmVjdC5oZWlnaHQgLyBvbGRSZWN0LmhlaWdodFxuICB9O1xufTtcblxuY29uc3QgcmVjdFN3YXBwaW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBpbmRleCxcbiAgICByZWN0cyxcbiAgICBvdmVySW5kZXhcbiAgfSA9IF9yZWY7XG4gIGxldCBvbGRSZWN0O1xuICBsZXQgbmV3UmVjdDtcblxuICBpZiAoaW5kZXggPT09IGFjdGl2ZUluZGV4KSB7XG4gICAgb2xkUmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgICBuZXdSZWN0ID0gcmVjdHNbb3ZlckluZGV4XTtcbiAgfVxuXG4gIGlmIChpbmRleCA9PT0gb3ZlckluZGV4KSB7XG4gICAgb2xkUmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgICBuZXdSZWN0ID0gcmVjdHNbYWN0aXZlSW5kZXhdO1xuICB9XG5cbiAgaWYgKCFuZXdSZWN0IHx8ICFvbGRSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IG5ld1JlY3QubGVmdCAtIG9sZFJlY3QubGVmdCxcbiAgICB5OiBuZXdSZWN0LnRvcCAtIG9sZFJlY3QudG9wLFxuICAgIHNjYWxlWDogbmV3UmVjdC53aWR0aCAvIG9sZFJlY3Qud2lkdGgsXG4gICAgc2NhbGVZOiBuZXdSZWN0LmhlaWdodCAvIG9sZFJlY3QuaGVpZ2h0XG4gIH07XG59O1xuXG4vLyBUby1kbzogV2Ugc2hvdWxkIGJlIGNhbGN1bGF0aW5nIHNjYWxlIHRyYW5zZm9ybWF0aW9uXG5jb25zdCBkZWZhdWx0U2NhbGUkMSA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5jb25zdCB2ZXJ0aWNhbExpc3RTb3J0aW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgdmFyIF9yZWN0cyRhY3RpdmVJbmRleDtcblxuICBsZXQge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIGFjdGl2ZU5vZGVSZWN0OiBmYWxsYmFja0FjdGl2ZVJlY3QsXG4gICAgaW5kZXgsXG4gICAgcmVjdHMsXG4gICAgb3ZlckluZGV4XG4gIH0gPSBfcmVmO1xuICBjb25zdCBhY3RpdmVOb2RlUmVjdCA9IChfcmVjdHMkYWN0aXZlSW5kZXggPSByZWN0c1thY3RpdmVJbmRleF0pICE9IG51bGwgPyBfcmVjdHMkYWN0aXZlSW5kZXggOiBmYWxsYmFja0FjdGl2ZVJlY3Q7XG5cbiAgaWYgKCFhY3RpdmVOb2RlUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGluZGV4ID09PSBhY3RpdmVJbmRleCkge1xuICAgIGNvbnN0IG92ZXJJbmRleFJlY3QgPSByZWN0c1tvdmVySW5kZXhdO1xuXG4gICAgaWYgKCFvdmVySW5kZXhSZWN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IGFjdGl2ZUluZGV4IDwgb3ZlckluZGV4ID8gb3ZlckluZGV4UmVjdC50b3AgKyBvdmVySW5kZXhSZWN0LmhlaWdodCAtIChhY3RpdmVOb2RlUmVjdC50b3AgKyBhY3RpdmVOb2RlUmVjdC5oZWlnaHQpIDogb3ZlckluZGV4UmVjdC50b3AgLSBhY3RpdmVOb2RlUmVjdC50b3AsXG4gICAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICAgIH07XG4gIH1cblxuICBjb25zdCBpdGVtR2FwID0gZ2V0SXRlbUdhcCQxKHJlY3RzLCBpbmRleCwgYWN0aXZlSW5kZXgpO1xuXG4gIGlmIChpbmRleCA+IGFjdGl2ZUluZGV4ICYmIGluZGV4IDw9IG92ZXJJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogLWFjdGl2ZU5vZGVSZWN0LmhlaWdodCAtIGl0ZW1HYXAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICAgIH07XG4gIH1cblxuICBpZiAoaW5kZXggPCBhY3RpdmVJbmRleCAmJiBpbmRleCA+PSBvdmVySW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IGFjdGl2ZU5vZGVSZWN0LmhlaWdodCArIGl0ZW1HYXAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICAuLi5kZWZhdWx0U2NhbGUkMVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0SXRlbUdhcCQxKGNsaWVudFJlY3RzLCBpbmRleCwgYWN0aXZlSW5kZXgpIHtcbiAgY29uc3QgY3VycmVudFJlY3QgPSBjbGllbnRSZWN0c1tpbmRleF07XG4gIGNvbnN0IHByZXZpb3VzUmVjdCA9IGNsaWVudFJlY3RzW2luZGV4IC0gMV07XG4gIGNvbnN0IG5leHRSZWN0ID0gY2xpZW50UmVjdHNbaW5kZXggKyAxXTtcblxuICBpZiAoIWN1cnJlbnRSZWN0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYWN0aXZlSW5kZXggPCBpbmRleCkge1xuICAgIHJldHVybiBwcmV2aW91c1JlY3QgPyBjdXJyZW50UmVjdC50b3AgLSAocHJldmlvdXNSZWN0LnRvcCArIHByZXZpb3VzUmVjdC5oZWlnaHQpIDogbmV4dFJlY3QgPyBuZXh0UmVjdC50b3AgLSAoY3VycmVudFJlY3QudG9wICsgY3VycmVudFJlY3QuaGVpZ2h0KSA6IDA7XG4gIH1cblxuICByZXR1cm4gbmV4dFJlY3QgPyBuZXh0UmVjdC50b3AgLSAoY3VycmVudFJlY3QudG9wICsgY3VycmVudFJlY3QuaGVpZ2h0KSA6IHByZXZpb3VzUmVjdCA/IGN1cnJlbnRSZWN0LnRvcCAtIChwcmV2aW91c1JlY3QudG9wICsgcHJldmlvdXNSZWN0LmhlaWdodCkgOiAwO1xufVxuXG5jb25zdCBJRF9QUkVGSVggPSAnU29ydGFibGUnO1xuY29uc3QgQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IC0xLFxuICBjb250YWluZXJJZDogSURfUFJFRklYLFxuICBkaXNhYmxlVHJhbnNmb3JtczogZmFsc2UsXG4gIGl0ZW1zOiBbXSxcbiAgb3ZlckluZGV4OiAtMSxcbiAgdXNlRHJhZ092ZXJsYXk6IGZhbHNlLFxuICBzb3J0ZWRSZWN0czogW10sXG4gIHN0cmF0ZWd5OiByZWN0U29ydGluZ1N0cmF0ZWd5LFxuICBkaXNhYmxlZDoge1xuICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgZHJvcHBhYmxlOiBmYWxzZVxuICB9XG59KTtcbmZ1bmN0aW9uIFNvcnRhYmxlQ29udGV4dChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgaXRlbXM6IHVzZXJEZWZpbmVkSXRlbXMsXG4gICAgc3RyYXRlZ3kgPSByZWN0U29ydGluZ1N0cmF0ZWd5LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZFByb3AgPSBmYWxzZVxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBkcmFnT3ZlcmxheSxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBvdmVyLFxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSB1c2VEbmRDb250ZXh0KCk7XG4gIGNvbnN0IGNvbnRhaW5lcklkID0gdXNlVW5pcXVlSWQoSURfUFJFRklYLCBpZCk7XG4gIGNvbnN0IHVzZURyYWdPdmVybGF5ID0gQm9vbGVhbihkcmFnT3ZlcmxheS5yZWN0ICE9PSBudWxsKTtcbiAgY29uc3QgaXRlbXMgPSB1c2VNZW1vKCgpID0+IHVzZXJEZWZpbmVkSXRlbXMubWFwKGl0ZW0gPT4gdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmICdpZCcgaW4gaXRlbSA/IGl0ZW0uaWQgOiBpdGVtKSwgW3VzZXJEZWZpbmVkSXRlbXNdKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IGFjdGl2ZSAhPSBudWxsO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IGFjdGl2ZSA/IGl0ZW1zLmluZGV4T2YoYWN0aXZlLmlkKSA6IC0xO1xuICBjb25zdCBvdmVySW5kZXggPSBvdmVyID8gaXRlbXMuaW5kZXhPZihvdmVyLmlkKSA6IC0xO1xuICBjb25zdCBwcmV2aW91c0l0ZW1zUmVmID0gdXNlUmVmKGl0ZW1zKTtcbiAgY29uc3QgaXRlbXNIYXZlQ2hhbmdlZCA9ICFpdGVtc0VxdWFsKGl0ZW1zLCBwcmV2aW91c0l0ZW1zUmVmLmN1cnJlbnQpO1xuICBjb25zdCBkaXNhYmxlVHJhbnNmb3JtcyA9IG92ZXJJbmRleCAhPT0gLTEgJiYgYWN0aXZlSW5kZXggPT09IC0xIHx8IGl0ZW1zSGF2ZUNoYW5nZWQ7XG4gIGNvbnN0IGRpc2FibGVkID0gbm9ybWFsaXplRGlzYWJsZWQoZGlzYWJsZWRQcm9wKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGl0ZW1zSGF2ZUNoYW5nZWQgJiYgaXNEcmFnZ2luZykge1xuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoaXRlbXMpO1xuICAgIH1cbiAgfSwgW2l0ZW1zSGF2ZUNoYW5nZWQsIGl0ZW1zLCBpc0RyYWdnaW5nLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZpb3VzSXRlbXNSZWYuY3VycmVudCA9IGl0ZW1zO1xuICB9LCBbaXRlbXNdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIGNvbnRhaW5lcklkLFxuICAgIGRpc2FibGVkLFxuICAgIGRpc2FibGVUcmFuc2Zvcm1zLFxuICAgIGl0ZW1zLFxuICAgIG92ZXJJbmRleCxcbiAgICB1c2VEcmFnT3ZlcmxheSxcbiAgICBzb3J0ZWRSZWN0czogZ2V0U29ydGVkUmVjdHMoaXRlbXMsIGRyb3BwYWJsZVJlY3RzKSxcbiAgICBzdHJhdGVneVxuICB9KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbYWN0aXZlSW5kZXgsIGNvbnRhaW5lcklkLCBkaXNhYmxlZC5kcmFnZ2FibGUsIGRpc2FibGVkLmRyb3BwYWJsZSwgZGlzYWJsZVRyYW5zZm9ybXMsIGl0ZW1zLCBvdmVySW5kZXgsIGRyb3BwYWJsZVJlY3RzLCB1c2VEcmFnT3ZlcmxheSwgc3RyYXRlZ3ldKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5jb25zdCBkZWZhdWx0TmV3SW5kZXhHZXR0ZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICBpdGVtcyxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXhcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBhcnJheU1vdmUoaXRlbXMsIGFjdGl2ZUluZGV4LCBvdmVySW5kZXgpLmluZGV4T2YoaWQpO1xufTtcbmNvbnN0IGRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcyA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBjb250YWluZXJJZCxcbiAgICBpc1NvcnRpbmcsXG4gICAgd2FzRHJhZ2dpbmcsXG4gICAgaW5kZXgsXG4gICAgaXRlbXMsXG4gICAgbmV3SW5kZXgsXG4gICAgcHJldmlvdXNJdGVtcyxcbiAgICBwcmV2aW91c0NvbnRhaW5lcklkLFxuICAgIHRyYW5zaXRpb25cbiAgfSA9IF9yZWYyO1xuXG4gIGlmICghdHJhbnNpdGlvbiB8fCAhd2FzRHJhZ2dpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJldmlvdXNJdGVtcyAhPT0gaXRlbXMgJiYgaW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzU29ydGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG5ld0luZGV4ICE9PSBpbmRleCAmJiBjb250YWluZXJJZCA9PT0gcHJldmlvdXNDb250YWluZXJJZDtcbn07XG5jb25zdCBkZWZhdWx0VHJhbnNpdGlvbiA9IHtcbiAgZHVyYXRpb246IDIwMCxcbiAgZWFzaW5nOiAnZWFzZSdcbn07XG5jb25zdCB0cmFuc2l0aW9uUHJvcGVydHkgPSAndHJhbnNmb3JtJztcbmNvbnN0IGRpc2FibGVkVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9DU1MuVHJhbnNpdGlvbi50b1N0cmluZyh7XG4gIHByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcGVydHksXG4gIGR1cmF0aW9uOiAwLFxuICBlYXNpbmc6ICdsaW5lYXInXG59KTtcbmNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICByb2xlRGVzY3JpcHRpb246ICdzb3J0YWJsZSdcbn07XG5cbi8qXHJcbiAqIFdoZW4gdGhlIGluZGV4IG9mIGFuIGl0ZW0gY2hhbmdlcyB3aGlsZSBzb3J0aW5nLFxyXG4gKiB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IGRpc2FibGUgdGhlIHRyYW5zZm9ybXNcclxuICovXG5cbmZ1bmN0aW9uIHVzZURlcml2ZWRUcmFuc2Zvcm0oX3JlZikge1xuICBsZXQge1xuICAgIGRpc2FibGVkLFxuICAgIGluZGV4LFxuICAgIG5vZGUsXG4gICAgcmVjdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgW2Rlcml2ZWRUcmFuc2Zvcm0sIHNldERlcml2ZWR0cmFuc2Zvcm1dID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzSW5kZXggPSB1c2VSZWYoaW5kZXgpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRpc2FibGVkICYmIGluZGV4ICE9PSBwcmV2aW91c0luZGV4LmN1cnJlbnQgJiYgbm9kZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCBpbml0aWFsID0gcmVjdC5jdXJyZW50O1xuXG4gICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gZ2V0Q2xpZW50UmVjdChub2RlLmN1cnJlbnQsIHtcbiAgICAgICAgICBpZ25vcmVUcmFuc2Zvcm06IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgICAgIHg6IGluaXRpYWwubGVmdCAtIGN1cnJlbnQubGVmdCxcbiAgICAgICAgICB5OiBpbml0aWFsLnRvcCAtIGN1cnJlbnQudG9wLFxuICAgICAgICAgIHNjYWxlWDogaW5pdGlhbC53aWR0aCAvIGN1cnJlbnQud2lkdGgsXG4gICAgICAgICAgc2NhbGVZOiBpbml0aWFsLmhlaWdodCAvIGN1cnJlbnQuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRlbHRhLnggfHwgZGVsdGEueSkge1xuICAgICAgICAgIHNldERlcml2ZWR0cmFuc2Zvcm0oZGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBwcmV2aW91c0luZGV4LmN1cnJlbnQpIHtcbiAgICAgIHByZXZpb3VzSW5kZXguY3VycmVudCA9IGluZGV4O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBpbmRleCwgbm9kZSwgcmVjdF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkZXJpdmVkVHJhbnNmb3JtKSB7XG4gICAgICBzZXREZXJpdmVkdHJhbnNmb3JtKG51bGwpO1xuICAgIH1cbiAgfSwgW2Rlcml2ZWRUcmFuc2Zvcm1dKTtcbiAgcmV0dXJuIGRlcml2ZWRUcmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHVzZVNvcnRhYmxlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhbmltYXRlTGF5b3V0Q2hhbmdlcyA9IGRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcyxcbiAgICBhdHRyaWJ1dGVzOiB1c2VyRGVmaW5lZEF0dHJpYnV0ZXMsXG4gICAgZGlzYWJsZWQ6IGxvY2FsRGlzYWJsZWQsXG4gICAgZGF0YTogY3VzdG9tRGF0YSxcbiAgICBnZXROZXdJbmRleCA9IGRlZmF1bHROZXdJbmRleEdldHRlcixcbiAgICBpZCxcbiAgICBzdHJhdGVneTogbG9jYWxTdHJhdGVneSxcbiAgICByZXNpemVPYnNlcnZlckNvbmZpZyxcbiAgICB0cmFuc2l0aW9uID0gZGVmYXVsdFRyYW5zaXRpb25cbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBpdGVtcyxcbiAgICBjb250YWluZXJJZCxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBkaXNhYmxlZDogZ2xvYmFsRGlzYWJsZWQsXG4gICAgZGlzYWJsZVRyYW5zZm9ybXMsXG4gICAgc29ydGVkUmVjdHMsXG4gICAgb3ZlckluZGV4LFxuICAgIHVzZURyYWdPdmVybGF5LFxuICAgIHN0cmF0ZWd5OiBnbG9iYWxTdHJhdGVneVxuICB9ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgY29uc3QgZGlzYWJsZWQgPSBub3JtYWxpemVMb2NhbERpc2FibGVkKGxvY2FsRGlzYWJsZWQsIGdsb2JhbERpc2FibGVkKTtcbiAgY29uc3QgaW5kZXggPSBpdGVtcy5pbmRleE9mKGlkKTtcbiAgY29uc3QgZGF0YSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBzb3J0YWJsZToge1xuICAgICAgY29udGFpbmVySWQsXG4gICAgICBpbmRleCxcbiAgICAgIGl0ZW1zXG4gICAgfSxcbiAgICAuLi5jdXN0b21EYXRhXG4gIH0pLCBbY29udGFpbmVySWQsIGN1c3RvbURhdGEsIGluZGV4LCBpdGVtc10pO1xuICBjb25zdCBpdGVtc0FmdGVyQ3VycmVudFNvcnRhYmxlID0gdXNlTWVtbygoKSA9PiBpdGVtcy5zbGljZShpdGVtcy5pbmRleE9mKGlkKSksIFtpdGVtcywgaWRdKTtcbiAgY29uc3Qge1xuICAgIHJlY3QsXG4gICAgbm9kZSxcbiAgICBpc092ZXIsXG4gICAgc2V0Tm9kZVJlZjogc2V0RHJvcHBhYmxlTm9kZVJlZlxuICB9ID0gdXNlRHJvcHBhYmxlKHtcbiAgICBpZCxcbiAgICBkYXRhLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZC5kcm9wcGFibGUsXG4gICAgcmVzaXplT2JzZXJ2ZXJDb25maWc6IHtcbiAgICAgIHVwZGF0ZU1lYXN1cmVtZW50c0ZvcjogaXRlbXNBZnRlckN1cnJlbnRTb3J0YWJsZSxcbiAgICAgIC4uLnJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gICAgfVxuICB9KTtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHNldE5vZGVSZWY6IHNldERyYWdnYWJsZU5vZGVSZWYsXG4gICAgbGlzdGVuZXJzLFxuICAgIGlzRHJhZ2dpbmcsXG4gICAgb3ZlcixcbiAgICBzZXRBY3RpdmF0b3JOb2RlUmVmLFxuICAgIHRyYW5zZm9ybVxuICB9ID0gdXNlRHJhZ2dhYmxlKHtcbiAgICBpZCxcbiAgICBkYXRhLFxuICAgIGF0dHJpYnV0ZXM6IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsXG4gICAgICAuLi51c2VyRGVmaW5lZEF0dHJpYnV0ZXNcbiAgICB9LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZC5kcmFnZ2FibGVcbiAgfSk7XG4gIGNvbnN0IHNldE5vZGVSZWYgPSB1c2VDb21iaW5lZFJlZnMoc2V0RHJvcHBhYmxlTm9kZVJlZiwgc2V0RHJhZ2dhYmxlTm9kZVJlZik7XG4gIGNvbnN0IGlzU29ydGluZyA9IEJvb2xlYW4oYWN0aXZlKTtcbiAgY29uc3QgZGlzcGxhY2VJdGVtID0gaXNTb3J0aW5nICYmICFkaXNhYmxlVHJhbnNmb3JtcyAmJiBpc1ZhbGlkSW5kZXgoYWN0aXZlSW5kZXgpICYmIGlzVmFsaWRJbmRleChvdmVySW5kZXgpO1xuICBjb25zdCBzaG91bGREaXNwbGFjZURyYWdTb3VyY2UgPSAhdXNlRHJhZ092ZXJsYXkgJiYgaXNEcmFnZ2luZztcbiAgY29uc3QgZHJhZ1NvdXJjZURpc3BsYWNlbWVudCA9IHNob3VsZERpc3BsYWNlRHJhZ1NvdXJjZSAmJiBkaXNwbGFjZUl0ZW0gPyB0cmFuc2Zvcm0gOiBudWxsO1xuICBjb25zdCBzdHJhdGVneSA9IGxvY2FsU3RyYXRlZ3kgIT0gbnVsbCA/IGxvY2FsU3RyYXRlZ3kgOiBnbG9iYWxTdHJhdGVneTtcbiAgY29uc3QgZmluYWxUcmFuc2Zvcm0gPSBkaXNwbGFjZUl0ZW0gPyBkcmFnU291cmNlRGlzcGxhY2VtZW50ICE9IG51bGwgPyBkcmFnU291cmNlRGlzcGxhY2VtZW50IDogc3RyYXRlZ3koe1xuICAgIHJlY3RzOiBzb3J0ZWRSZWN0cyxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXgsXG4gICAgaW5kZXhcbiAgfSkgOiBudWxsO1xuICBjb25zdCBuZXdJbmRleCA9IGlzVmFsaWRJbmRleChhY3RpdmVJbmRleCkgJiYgaXNWYWxpZEluZGV4KG92ZXJJbmRleCkgPyBnZXROZXdJbmRleCh7XG4gICAgaWQsXG4gICAgaXRlbXMsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4XG4gIH0pIDogaW5kZXg7XG4gIGNvbnN0IGFjdGl2ZUlkID0gYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQ7XG4gIGNvbnN0IHByZXZpb3VzID0gdXNlUmVmKHtcbiAgICBhY3RpdmVJZCxcbiAgICBpdGVtcyxcbiAgICBuZXdJbmRleCxcbiAgICBjb250YWluZXJJZFxuICB9KTtcbiAgY29uc3QgaXRlbXNIYXZlQ2hhbmdlZCA9IGl0ZW1zICE9PSBwcmV2aW91cy5jdXJyZW50Lml0ZW1zO1xuICBjb25zdCBzaG91bGRBbmltYXRlTGF5b3V0Q2hhbmdlcyA9IGFuaW1hdGVMYXlvdXRDaGFuZ2VzKHtcbiAgICBhY3RpdmUsXG4gICAgY29udGFpbmVySWQsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBpc1NvcnRpbmcsXG4gICAgaWQsXG4gICAgaW5kZXgsXG4gICAgaXRlbXMsXG4gICAgbmV3SW5kZXg6IHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXgsXG4gICAgcHJldmlvdXNJdGVtczogcHJldmlvdXMuY3VycmVudC5pdGVtcyxcbiAgICBwcmV2aW91c0NvbnRhaW5lcklkOiBwcmV2aW91cy5jdXJyZW50LmNvbnRhaW5lcklkLFxuICAgIHRyYW5zaXRpb24sXG4gICAgd2FzRHJhZ2dpbmc6IHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQgIT0gbnVsbFxuICB9KTtcbiAgY29uc3QgZGVyaXZlZFRyYW5zZm9ybSA9IHVzZURlcml2ZWRUcmFuc2Zvcm0oe1xuICAgIGRpc2FibGVkOiAhc2hvdWxkQW5pbWF0ZUxheW91dENoYW5nZXMsXG4gICAgaW5kZXgsXG4gICAgbm9kZSxcbiAgICByZWN0XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1NvcnRpbmcgJiYgcHJldmlvdXMuY3VycmVudC5uZXdJbmRleCAhPT0gbmV3SW5kZXgpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVySWQgIT09IHByZXZpb3VzLmN1cnJlbnQuY29udGFpbmVySWQpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuY29udGFpbmVySWQgPSBjb250YWluZXJJZDtcbiAgICB9XG5cbiAgICBpZiAoaXRlbXMgIT09IHByZXZpb3VzLmN1cnJlbnQuaXRlbXMpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuaXRlbXMgPSBpdGVtcztcbiAgICB9XG4gIH0sIFtpc1NvcnRpbmcsIG5ld0luZGV4LCBjb250YWluZXJJZCwgaXRlbXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlSWQgPT09IHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlSWQgJiYgIXByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQpIHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQgPSBhY3RpdmVJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuYWN0aXZlSWQgPSBhY3RpdmVJZDtcbiAgICB9LCA1MCk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9LCBbYWN0aXZlSWRdKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgYXR0cmlidXRlcyxcbiAgICBkYXRhLFxuICAgIHJlY3QsXG4gICAgaW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgaXRlbXMsXG4gICAgaXNPdmVyLFxuICAgIGlzU29ydGluZyxcbiAgICBpc0RyYWdnaW5nLFxuICAgIGxpc3RlbmVycyxcbiAgICBub2RlLFxuICAgIG92ZXJJbmRleCxcbiAgICBvdmVyLFxuICAgIHNldE5vZGVSZWYsXG4gICAgc2V0QWN0aXZhdG9yTm9kZVJlZixcbiAgICBzZXREcm9wcGFibGVOb2RlUmVmLFxuICAgIHNldERyYWdnYWJsZU5vZGVSZWYsXG4gICAgdHJhbnNmb3JtOiBkZXJpdmVkVHJhbnNmb3JtICE9IG51bGwgPyBkZXJpdmVkVHJhbnNmb3JtIDogZmluYWxUcmFuc2Zvcm0sXG4gICAgdHJhbnNpdGlvbjogZ2V0VHJhbnNpdGlvbigpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbigpIHtcbiAgICBpZiAoIC8vIFRlbXBvcmFyaWx5IGRpc2FibGUgdHJhbnNpdGlvbnMgZm9yIGEgc2luZ2xlIGZyYW1lIHRvIHNldCB1cCBkZXJpdmVkIHRyYW5zZm9ybXNcbiAgICBkZXJpdmVkVHJhbnNmb3JtIHx8IC8vIE9yIHRvIHByZXZlbnQgaXRlbXMganVtcGluZyB0byBiYWNrIHRvIHRoZWlyIFwibmV3XCIgcG9zaXRpb24gd2hlbiBpdGVtcyBjaGFuZ2VcbiAgICBpdGVtc0hhdmVDaGFuZ2VkICYmIHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXggPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWRUcmFuc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChzaG91bGREaXNwbGFjZURyYWdTb3VyY2UgJiYgIWlzS2V5Ym9hcmRFdmVudChhY3RpdmF0b3JFdmVudCkgfHwgIXRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzU29ydGluZyB8fCBzaG91bGRBbmltYXRlTGF5b3V0Q2hhbmdlcykge1xuICAgICAgcmV0dXJuIENTUy5UcmFuc2l0aW9uLnRvU3RyaW5nKHsgLi4udHJhbnNpdGlvbixcbiAgICAgICAgcHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wZXJ0eVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbERpc2FibGVkKGxvY2FsRGlzYWJsZWQsIGdsb2JhbERpc2FibGVkKSB7XG4gIHZhciBfbG9jYWxEaXNhYmxlZCRkcmFnZ2EsIF9sb2NhbERpc2FibGVkJGRyb3BwYTtcblxuICBpZiAodHlwZW9mIGxvY2FsRGlzYWJsZWQgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2FibGU6IGxvY2FsRGlzYWJsZWQsXG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgZHJvcHBhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZTogKF9sb2NhbERpc2FibGVkJGRyYWdnYSA9IGxvY2FsRGlzYWJsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsRGlzYWJsZWQuZHJhZ2dhYmxlKSAhPSBudWxsID8gX2xvY2FsRGlzYWJsZWQkZHJhZ2dhIDogZ2xvYmFsRGlzYWJsZWQuZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogKF9sb2NhbERpc2FibGVkJGRyb3BwYSA9IGxvY2FsRGlzYWJsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsRGlzYWJsZWQuZHJvcHBhYmxlKSAhPSBudWxsID8gX2xvY2FsRGlzYWJsZWQkZHJvcHBhIDogZ2xvYmFsRGlzYWJsZWQuZHJvcHBhYmxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhc1NvcnRhYmxlRGF0YShlbnRyeSkge1xuICBpZiAoIWVudHJ5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IGVudHJ5LmRhdGEuY3VycmVudDtcblxuICBpZiAoZGF0YSAmJiAnc29ydGFibGUnIGluIGRhdGEgJiYgdHlwZW9mIGRhdGEuc29ydGFibGUgPT09ICdvYmplY3QnICYmICdjb250YWluZXJJZCcgaW4gZGF0YS5zb3J0YWJsZSAmJiAnaXRlbXMnIGluIGRhdGEuc29ydGFibGUgJiYgJ2luZGV4JyBpbiBkYXRhLnNvcnRhYmxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBbS2V5Ym9hcmRDb2RlLkRvd24sIEtleWJvYXJkQ29kZS5SaWdodCwgS2V5Ym9hcmRDb2RlLlVwLCBLZXlib2FyZENvZGUuTGVmdF07XG5jb25zdCBzb3J0YWJsZUtleWJvYXJkQ29vcmRpbmF0ZXMgPSAoZXZlbnQsIF9yZWYpID0+IHtcbiAgbGV0IHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBhY3RpdmUsXG4gICAgICBjb2xsaXNpb25SZWN0LFxuICAgICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgb3ZlcixcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvcnNcbiAgICB9XG4gIH0gPSBfcmVmO1xuXG4gIGlmIChkaXJlY3Rpb25zLmluY2x1ZGVzKGV2ZW50LmNvZGUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICghYWN0aXZlIHx8ICFjb2xsaXNpb25SZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRDb250YWluZXJzID0gW107XG4gICAgZHJvcHBhYmxlQ29udGFpbmVycy5nZXRFbmFibGVkKCkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5ICE9IG51bGwgJiYgZW50cnkuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGVudHJ5LmlkKTtcblxuICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkRvd246XG4gICAgICAgICAgaWYgKGNvbGxpc2lvblJlY3QudG9wIDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGFpbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEtleWJvYXJkQ29kZS5VcDpcbiAgICAgICAgICBpZiAoY29sbGlzaW9uUmVjdC50b3AgPiByZWN0LnRvcCkge1xuICAgICAgICAgICAgZmlsdGVyZWRDb250YWluZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkxlZnQ6XG4gICAgICAgICAgaWYgKGNvbGxpc2lvblJlY3QubGVmdCA+IHJlY3QubGVmdCkge1xuICAgICAgICAgICAgZmlsdGVyZWRDb250YWluZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlJpZ2h0OlxuICAgICAgICAgIGlmIChjb2xsaXNpb25SZWN0LmxlZnQgPCByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGFpbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjb2xsaXNpb25zID0gY2xvc2VzdENvcm5lcnMoe1xuICAgICAgYWN0aXZlLFxuICAgICAgY29sbGlzaW9uUmVjdDogY29sbGlzaW9uUmVjdCxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVyczogZmlsdGVyZWRDb250YWluZXJzLFxuICAgICAgcG9pbnRlckNvb3JkaW5hdGVzOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IGNsb3Nlc3RJZCA9IGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpc2lvbnMsICdpZCcpO1xuXG4gICAgaWYgKGNsb3Nlc3RJZCA9PT0gKG92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXIuaWQpICYmIGNvbGxpc2lvbnMubGVuZ3RoID4gMSkge1xuICAgICAgY2xvc2VzdElkID0gY29sbGlzaW9uc1sxXS5pZDtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VzdElkICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZURyb3BwYWJsZSA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0KGFjdGl2ZS5pZCk7XG4gICAgICBjb25zdCBuZXdEcm9wcGFibGUgPSBkcm9wcGFibGVDb250YWluZXJzLmdldChjbG9zZXN0SWQpO1xuICAgICAgY29uc3QgbmV3UmVjdCA9IG5ld0Ryb3BwYWJsZSA/IGRyb3BwYWJsZVJlY3RzLmdldChuZXdEcm9wcGFibGUuaWQpIDogbnVsbDtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXdEcm9wcGFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5ld0Ryb3BwYWJsZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChuZXdOb2RlICYmIG5ld1JlY3QgJiYgYWN0aXZlRHJvcHBhYmxlICYmIG5ld0Ryb3BwYWJsZSkge1xuICAgICAgICBjb25zdCBuZXdTY3JvbGxBbmNlc3RvcnMgPSBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5ld05vZGUpO1xuICAgICAgICBjb25zdCBoYXNEaWZmZXJlbnRTY3JvbGxBbmNlc3RvcnMgPSBuZXdTY3JvbGxBbmNlc3RvcnMuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHNjcm9sbGFibGVBbmNlc3RvcnNbaW5kZXhdICE9PSBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaGFzU2FtZUNvbnRhaW5lciA9IGlzU2FtZUNvbnRhaW5lcihhY3RpdmVEcm9wcGFibGUsIG5ld0Ryb3BwYWJsZSk7XG4gICAgICAgIGNvbnN0IGlzQWZ0ZXJBY3RpdmUgPSBpc0FmdGVyKGFjdGl2ZURyb3BwYWJsZSwgbmV3RHJvcHBhYmxlKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGFzRGlmZmVyZW50U2Nyb2xsQW5jZXN0b3JzIHx8ICFoYXNTYW1lQ29udGFpbmVyID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIHg6IGlzQWZ0ZXJBY3RpdmUgPyBjb2xsaXNpb25SZWN0LndpZHRoIC0gbmV3UmVjdC53aWR0aCA6IDAsXG4gICAgICAgICAgeTogaXNBZnRlckFjdGl2ZSA/IGNvbGxpc2lvblJlY3QuaGVpZ2h0IC0gbmV3UmVjdC5oZWlnaHQgOiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY3RDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICB4OiBuZXdSZWN0LmxlZnQsXG4gICAgICAgICAgeTogbmV3UmVjdC50b3BcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV3Q29vcmRpbmF0ZXMgPSBvZmZzZXQueCAmJiBvZmZzZXQueSA/IHJlY3RDb29yZGluYXRlcyA6IHN1YnRyYWN0KHJlY3RDb29yZGluYXRlcywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ld0Nvb3JkaW5hdGVzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBpc1NhbWVDb250YWluZXIoYSwgYikge1xuICBpZiAoIWhhc1NvcnRhYmxlRGF0YShhKSB8fCAhaGFzU29ydGFibGVEYXRhKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGEuZGF0YS5jdXJyZW50LnNvcnRhYmxlLmNvbnRhaW5lcklkID09PSBiLmRhdGEuY3VycmVudC5zb3J0YWJsZS5jb250YWluZXJJZDtcbn1cblxuZnVuY3Rpb24gaXNBZnRlcihhLCBiKSB7XG4gIGlmICghaGFzU29ydGFibGVEYXRhKGEpIHx8ICFoYXNTb3J0YWJsZURhdGEoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzU2FtZUNvbnRhaW5lcihhLCBiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhLmRhdGEuY3VycmVudC5zb3J0YWJsZS5pbmRleCA8IGIuZGF0YS5jdXJyZW50LnNvcnRhYmxlLmluZGV4O1xufVxuXG5leHBvcnQgeyBTb3J0YWJsZUNvbnRleHQsIGFycmF5TW92ZSwgYXJyYXlTd2FwLCBkZWZhdWx0QW5pbWF0ZUxheW91dENoYW5nZXMsIGRlZmF1bHROZXdJbmRleEdldHRlciwgaGFzU29ydGFibGVEYXRhLCBob3Jpem9udGFsTGlzdFNvcnRpbmdTdHJhdGVneSwgcmVjdFNvcnRpbmdTdHJhdGVneSwgcmVjdFN3YXBwaW5nU3RyYXRlZ3ksIHNvcnRhYmxlS2V5Ym9hcmRDb29yZGluYXRlcywgdXNlU29ydGFibGUsIHZlcnRpY2FsTGlzdFNvcnRpbmdTdHJhdGVneSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydGFibGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlQ29udGV4dCIsInVzZURuZENvbnRleHQiLCJnZXRDbGllbnRSZWN0IiwidXNlRHJvcHBhYmxlIiwidXNlRHJhZ2dhYmxlIiwiY2xvc2VzdENvcm5lcnMiLCJnZXRGaXJzdENvbGxpc2lvbiIsImdldFNjcm9sbGFibGVBbmNlc3RvcnMiLCJLZXlib2FyZENvZGUiLCJ1c2VVbmlxdWVJZCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJDU1MiLCJ1c2VDb21iaW5lZFJlZnMiLCJpc0tleWJvYXJkRXZlbnQiLCJzdWJ0cmFjdCIsImFycmF5TW92ZSIsImFycmF5IiwiZnJvbSIsInRvIiwibmV3QXJyYXkiLCJzbGljZSIsInNwbGljZSIsImxlbmd0aCIsImFycmF5U3dhcCIsImdldFNvcnRlZFJlY3RzIiwiaXRlbXMiLCJyZWN0cyIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiaWQiLCJpbmRleCIsInJlY3QiLCJnZXQiLCJBcnJheSIsImlzVmFsaWRJbmRleCIsIml0ZW1zRXF1YWwiLCJhIiwiYiIsImkiLCJub3JtYWxpemVEaXNhYmxlZCIsImRpc2FibGVkIiwiZHJhZ2dhYmxlIiwiZHJvcHBhYmxlIiwiZGVmYXVsdFNjYWxlIiwic2NhbGVYIiwic2NhbGVZIiwiaG9yaXpvbnRhbExpc3RTb3J0aW5nU3RyYXRlZ3kiLCJfcmVmIiwiX3JlY3RzJGFjdGl2ZUluZGV4IiwiYWN0aXZlTm9kZVJlY3QiLCJmYWxsYmFja0FjdGl2ZVJlY3QiLCJhY3RpdmVJbmRleCIsIm92ZXJJbmRleCIsIml0ZW1HYXAiLCJnZXRJdGVtR2FwIiwibmV3SW5kZXhSZWN0IiwieCIsImxlZnQiLCJ3aWR0aCIsInkiLCJjdXJyZW50UmVjdCIsInByZXZpb3VzUmVjdCIsIm5leHRSZWN0IiwicmVjdFNvcnRpbmdTdHJhdGVneSIsIm5ld1JlY3RzIiwib2xkUmVjdCIsIm5ld1JlY3QiLCJ0b3AiLCJoZWlnaHQiLCJyZWN0U3dhcHBpbmdTdHJhdGVneSIsImRlZmF1bHRTY2FsZSQxIiwidmVydGljYWxMaXN0U29ydGluZ1N0cmF0ZWd5Iiwib3ZlckluZGV4UmVjdCIsImdldEl0ZW1HYXAkMSIsImNsaWVudFJlY3RzIiwiSURfUFJFRklYIiwiQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjb250YWluZXJJZCIsImRpc2FibGVUcmFuc2Zvcm1zIiwidXNlRHJhZ092ZXJsYXkiLCJzb3J0ZWRSZWN0cyIsInN0cmF0ZWd5IiwiU29ydGFibGVDb250ZXh0IiwiY2hpbGRyZW4iLCJ1c2VyRGVmaW5lZEl0ZW1zIiwiZGlzYWJsZWRQcm9wIiwiYWN0aXZlIiwiZHJhZ092ZXJsYXkiLCJkcm9wcGFibGVSZWN0cyIsIm92ZXIiLCJtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyIsIkJvb2xlYW4iLCJtYXAiLCJpdGVtIiwiaXNEcmFnZ2luZyIsImluZGV4T2YiLCJwcmV2aW91c0l0ZW1zUmVmIiwiaXRlbXNIYXZlQ2hhbmdlZCIsImN1cnJlbnQiLCJjb250ZXh0VmFsdWUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImRlZmF1bHROZXdJbmRleEdldHRlciIsImRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcyIsIl9yZWYyIiwiaXNTb3J0aW5nIiwid2FzRHJhZ2dpbmciLCJuZXdJbmRleCIsInByZXZpb3VzSXRlbXMiLCJwcmV2aW91c0NvbnRhaW5lcklkIiwidHJhbnNpdGlvbiIsImRlZmF1bHRUcmFuc2l0aW9uIiwiZHVyYXRpb24iLCJlYXNpbmciLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJkaXNhYmxlZFRyYW5zaXRpb24iLCJUcmFuc2l0aW9uIiwidG9TdHJpbmciLCJwcm9wZXJ0eSIsImRlZmF1bHRBdHRyaWJ1dGVzIiwicm9sZURlc2NyaXB0aW9uIiwidXNlRGVyaXZlZFRyYW5zZm9ybSIsIm5vZGUiLCJkZXJpdmVkVHJhbnNmb3JtIiwic2V0RGVyaXZlZHRyYW5zZm9ybSIsInByZXZpb3VzSW5kZXgiLCJpbml0aWFsIiwiaWdub3JlVHJhbnNmb3JtIiwiZGVsdGEiLCJ1c2VTb3J0YWJsZSIsImFuaW1hdGVMYXlvdXRDaGFuZ2VzIiwiYXR0cmlidXRlcyIsInVzZXJEZWZpbmVkQXR0cmlidXRlcyIsImxvY2FsRGlzYWJsZWQiLCJkYXRhIiwiY3VzdG9tRGF0YSIsImdldE5ld0luZGV4IiwibG9jYWxTdHJhdGVneSIsInJlc2l6ZU9ic2VydmVyQ29uZmlnIiwiZ2xvYmFsRGlzYWJsZWQiLCJnbG9iYWxTdHJhdGVneSIsIm5vcm1hbGl6ZUxvY2FsRGlzYWJsZWQiLCJzb3J0YWJsZSIsIml0ZW1zQWZ0ZXJDdXJyZW50U29ydGFibGUiLCJpc092ZXIiLCJzZXROb2RlUmVmIiwic2V0RHJvcHBhYmxlTm9kZVJlZiIsInVwZGF0ZU1lYXN1cmVtZW50c0ZvciIsImFjdGl2YXRvckV2ZW50Iiwic2V0RHJhZ2dhYmxlTm9kZVJlZiIsImxpc3RlbmVycyIsInNldEFjdGl2YXRvck5vZGVSZWYiLCJ0cmFuc2Zvcm0iLCJkaXNwbGFjZUl0ZW0iLCJzaG91bGREaXNwbGFjZURyYWdTb3VyY2UiLCJkcmFnU291cmNlRGlzcGxhY2VtZW50IiwiZmluYWxUcmFuc2Zvcm0iLCJhY3RpdmVJZCIsInByZXZpb3VzIiwic2hvdWxkQW5pbWF0ZUxheW91dENoYW5nZXMiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0VHJhbnNpdGlvbiIsInVuZGVmaW5lZCIsIl9sb2NhbERpc2FibGVkJGRyYWdnYSIsIl9sb2NhbERpc2FibGVkJGRyb3BwYSIsImhhc1NvcnRhYmxlRGF0YSIsImVudHJ5IiwiZGlyZWN0aW9ucyIsIkRvd24iLCJSaWdodCIsIlVwIiwiTGVmdCIsInNvcnRhYmxlS2V5Ym9hcmRDb29yZGluYXRlcyIsImV2ZW50IiwiY29udGV4dCIsImNvbGxpc2lvblJlY3QiLCJkcm9wcGFibGVDb250YWluZXJzIiwic2Nyb2xsYWJsZUFuY2VzdG9ycyIsImluY2x1ZGVzIiwiY29kZSIsInByZXZlbnREZWZhdWx0IiwiZmlsdGVyZWRDb250YWluZXJzIiwiZ2V0RW5hYmxlZCIsImZvckVhY2giLCJwdXNoIiwiY29sbGlzaW9ucyIsInBvaW50ZXJDb29yZGluYXRlcyIsImNsb3Nlc3RJZCIsImFjdGl2ZURyb3BwYWJsZSIsIm5ld0Ryb3BwYWJsZSIsIm5ld05vZGUiLCJuZXdTY3JvbGxBbmNlc3RvcnMiLCJoYXNEaWZmZXJlbnRTY3JvbGxBbmNlc3RvcnMiLCJzb21lIiwiZWxlbWVudCIsImhhc1NhbWVDb250YWluZXIiLCJpc1NhbWVDb250YWluZXIiLCJpc0FmdGVyQWN0aXZlIiwiaXNBZnRlciIsIm9mZnNldCIsInJlY3RDb29yZGluYXRlcyIsIm5ld0Nvb3JkaW5hdGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/sortable/dist/sortable.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dnd-kit/utilities/dist/utilities.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSS: () => (/* binding */ CSS),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   canUseDOM: () => (/* binding */ canUseDOM),\n/* harmony export */   findFirstFocusableNode: () => (/* binding */ findFirstFocusableNode),\n/* harmony export */   getEventCoordinates: () => (/* binding */ getEventCoordinates),\n/* harmony export */   getOwnerDocument: () => (/* binding */ getOwnerDocument),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   hasViewportRelativeCoordinates: () => (/* binding */ hasViewportRelativeCoordinates),\n/* harmony export */   isDocument: () => (/* binding */ isDocument),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isKeyboardEvent: () => (/* binding */ isKeyboardEvent),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isSVGElement: () => (/* binding */ isSVGElement),\n/* harmony export */   isTouchEvent: () => (/* binding */ isTouchEvent),\n/* harmony export */   isWindow: () => (/* binding */ isWindow),\n/* harmony export */   subtract: () => (/* binding */ subtract),\n/* harmony export */   useCombinedRefs: () => (/* binding */ useCombinedRefs),\n/* harmony export */   useEvent: () => (/* binding */ useEvent),\n/* harmony export */   useInterval: () => (/* binding */ useInterval),\n/* harmony export */   useIsomorphicLayoutEffect: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   useLatestValue: () => (/* binding */ useLatestValue),\n/* harmony export */   useLazyMemo: () => (/* binding */ useLazyMemo),\n/* harmony export */   useNodeRef: () => (/* binding */ useNodeRef),\n/* harmony export */   usePrevious: () => (/* binding */ usePrevious),\n/* harmony export */   useUniqueId: () => (/* binding */ useUniqueId)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCombinedRefs() {\n    for(var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++){\n        refs[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(node)=>{\n            refs.forEach((ref)=>ref(node));\n        }, refs);\n}\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nconst canUseDOM =  false && 0;\nfunction isWindow(element) {\n    const elementString = Object.prototype.toString.call(element);\n    return elementString === \"[object Window]\" || // In Electron context the Window object serializes to [object global]\n    elementString === \"[object global]\";\n}\nfunction isNode(node) {\n    return \"nodeType\" in node;\n}\nfunction getWindow(target) {\n    var _target$ownerDocument, _target$ownerDocument2;\n    if (!target) {\n        return window;\n    }\n    if (isWindow(target)) {\n        return target;\n    }\n    if (!isNode(target)) {\n        return window;\n    }\n    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;\n}\nfunction isDocument(node) {\n    const { Document } = getWindow(node);\n    return node instanceof Document;\n}\nfunction isHTMLElement(node) {\n    if (isWindow(node)) {\n        return false;\n    }\n    return node instanceof getWindow(node).HTMLElement;\n}\nfunction isSVGElement(node) {\n    return node instanceof getWindow(node).SVGElement;\n}\nfunction getOwnerDocument(target) {\n    if (!target) {\n        return document;\n    }\n    if (isWindow(target)) {\n        return target.document;\n    }\n    if (!isNode(target)) {\n        return document;\n    }\n    if (isDocument(target)) {\n        return target;\n    }\n    if (isHTMLElement(target) || isSVGElement(target)) {\n        return target.ownerDocument;\n    }\n    return document;\n}\n/**\r\n * A hook that resolves to useEffect on the server and useLayoutEffect on the client\r\n * @param callback {function} Callback function that is invoked when the dependencies of the hook change\r\n */ const useIsomorphicLayoutEffect = canUseDOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useEvent(handler) {\n    const handlerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(handler);\n    useIsomorphicLayoutEffect(()=>{\n        handlerRef.current = handler;\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return handlerRef.current == null ? void 0 : handlerRef.current(...args);\n    }, []);\n}\nfunction useInterval() {\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener, duration)=>{\n        intervalRef.current = setInterval(listener, duration);\n    }, []);\n    const clear = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (intervalRef.current !== null) {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n        }\n    }, []);\n    return [\n        set,\n        clear\n    ];\n}\nfunction useLatestValue(value, dependencies) {\n    if (dependencies === void 0) {\n        dependencies = [\n            value\n        ];\n    }\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    useIsomorphicLayoutEffect(()=>{\n        if (valueRef.current !== value) {\n            valueRef.current = value;\n        }\n    }, dependencies);\n    return valueRef;\n}\nfunction useLazyMemo(callback, dependencies) {\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const newValue = callback(valueRef.current);\n        valueRef.current = newValue;\n        return newValue;\n    }, [\n        ...dependencies\n    ]);\n}\nfunction useNodeRef(onChange) {\n    const onChangeHandler = useEvent(onChange);\n    const node = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setNodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        if (element !== node.current) {\n            onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);\n        }\n        node.current = element;\n    }, []);\n    return [\n        node,\n        setNodeRef\n    ];\n}\nfunction usePrevious(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n}\nlet ids = {};\nfunction useUniqueId(prefix, value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (value) {\n            return value;\n        }\n        const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n        ids[prefix] = id;\n        return prefix + \"-\" + id;\n    }, [\n        prefix,\n        value\n    ]);\n}\nfunction createAdjustmentFn(modifier) {\n    return function(object) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((accumulator, adjustment)=>{\n            const entries = Object.entries(adjustment);\n            for (const [key, valueAdjustment] of entries){\n                const value = accumulator[key];\n                if (value != null) {\n                    accumulator[key] = value + modifier * valueAdjustment;\n                }\n            }\n            return accumulator;\n        }, {\n            ...object\n        });\n    };\n}\nconst add = /*#__PURE__*/ createAdjustmentFn(1);\nconst subtract = /*#__PURE__*/ createAdjustmentFn(-1);\nfunction hasViewportRelativeCoordinates(event) {\n    return \"clientX\" in event && \"clientY\" in event;\n}\nfunction isKeyboardEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { KeyboardEvent } = getWindow(event.target);\n    return KeyboardEvent && event instanceof KeyboardEvent;\n}\nfunction isTouchEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { TouchEvent } = getWindow(event.target);\n    return TouchEvent && event instanceof TouchEvent;\n}\n/**\r\n * Returns the normalized x and y coordinates for mouse and touch events.\r\n */ function getEventCoordinates(event) {\n    if (isTouchEvent(event)) {\n        if (event.touches && event.touches.length) {\n            const { clientX: x, clientY: y } = event.touches[0];\n            return {\n                x,\n                y\n            };\n        } else if (event.changedTouches && event.changedTouches.length) {\n            const { clientX: x, clientY: y } = event.changedTouches[0];\n            return {\n                x,\n                y\n            };\n        }\n    }\n    if (hasViewportRelativeCoordinates(event)) {\n        return {\n            x: event.clientX,\n            y: event.clientY\n        };\n    }\n    return null;\n}\nconst CSS = /*#__PURE__*/ Object.freeze({\n    Translate: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { x, y } = transform;\n            return \"translate3d(\" + (x ? Math.round(x) : 0) + \"px, \" + (y ? Math.round(y) : 0) + \"px, 0)\";\n        }\n    },\n    Scale: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { scaleX, scaleY } = transform;\n            return \"scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\";\n        }\n    },\n    Transform: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            return [\n                CSS.Translate.toString(transform),\n                CSS.Scale.toString(transform)\n            ].join(\" \");\n        }\n    },\n    Transition: {\n        toString (_ref) {\n            let { property, duration, easing } = _ref;\n            return property + \" \" + duration + \"ms \" + easing;\n        }\n    }\n});\nconst SELECTOR = \"a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]\";\nfunction findFirstFocusableNode(element) {\n    if (element.matches(SELECTOR)) {\n        return element;\n    }\n    return element.querySelector(SELECTOR);\n}\n //# sourceMappingURL=utilities.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvdXRpbGl0aWVzL2Rpc3QvdXRpbGl0aWVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUY7QUFFakYsU0FBU0s7SUFDUCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7UUFDdkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7SUFDOUI7SUFFQSxPQUFPWCw4Q0FBT0EsQ0FBQyxJQUFNWSxDQUFBQTtZQUNuQkgsS0FBS0ksT0FBTyxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJRjtRQUMxQixHQUNBSDtBQUNGO0FBRUEsd0ZBQXdGO0FBQ3hGLE1BQU1NLFlBQVksTUFBNEQsSUFBZSxDQUF5QztBQUV0SSxTQUFTSSxTQUFTQyxPQUFPO0lBQ3ZCLE1BQU1DLGdCQUFnQkMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0w7SUFDckQsT0FBT0Msa0JBQWtCLHFCQUFxQixzRUFBc0U7SUFDcEhBLGtCQUFrQjtBQUNwQjtBQUVBLFNBQVNLLE9BQU9kLElBQUk7SUFDbEIsT0FBTyxjQUFjQTtBQUN2QjtBQUVBLFNBQVNlLFVBQVVDLE1BQU07SUFDdkIsSUFBSUMsdUJBQXVCQztJQUUzQixJQUFJLENBQUNGLFFBQVE7UUFDWCxPQUFPWjtJQUNUO0lBRUEsSUFBSUcsU0FBU1MsU0FBUztRQUNwQixPQUFPQTtJQUNUO0lBRUEsSUFBSSxDQUFDRixPQUFPRSxTQUFTO1FBQ25CLE9BQU9aO0lBQ1Q7SUFFQSxPQUFPLENBQUNhLHdCQUF3QixDQUFDQyx5QkFBeUJGLE9BQU9HLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSUQsdUJBQXVCRSxXQUFXLEtBQUssT0FBT0gsd0JBQXdCYjtBQUMzSztBQUVBLFNBQVNpQixXQUFXckIsSUFBSTtJQUN0QixNQUFNLEVBQ0pzQixRQUFRLEVBQ1QsR0FBR1AsVUFBVWY7SUFDZCxPQUFPQSxnQkFBZ0JzQjtBQUN6QjtBQUVBLFNBQVNDLGNBQWN2QixJQUFJO0lBQ3pCLElBQUlPLFNBQVNQLE9BQU87UUFDbEIsT0FBTztJQUNUO0lBRUEsT0FBT0EsZ0JBQWdCZSxVQUFVZixNQUFNd0IsV0FBVztBQUNwRDtBQUVBLFNBQVNDLGFBQWF6QixJQUFJO0lBQ3hCLE9BQU9BLGdCQUFnQmUsVUFBVWYsTUFBTTBCLFVBQVU7QUFDbkQ7QUFFQSxTQUFTQyxpQkFBaUJYLE1BQU07SUFDOUIsSUFBSSxDQUFDQSxRQUFRO1FBQ1gsT0FBT1g7SUFDVDtJQUVBLElBQUlFLFNBQVNTLFNBQVM7UUFDcEIsT0FBT0EsT0FBT1gsUUFBUTtJQUN4QjtJQUVBLElBQUksQ0FBQ1MsT0FBT0UsU0FBUztRQUNuQixPQUFPWDtJQUNUO0lBRUEsSUFBSWdCLFdBQVdMLFNBQVM7UUFDdEIsT0FBT0E7SUFDVDtJQUVBLElBQUlPLGNBQWNQLFdBQVdTLGFBQWFULFNBQVM7UUFDakQsT0FBT0EsT0FBT0csYUFBYTtJQUM3QjtJQUVBLE9BQU9kO0FBQ1Q7QUFFQTs7O0NBR0MsR0FFRCxNQUFNdUIsNEJBQTRCekIsWUFBWWQsa0RBQWVBLEdBQUdDLDRDQUFTQTtBQUV6RSxTQUFTdUMsU0FBU0MsT0FBTztJQUN2QixNQUFNQyxhQUFheEMsNkNBQU1BLENBQUN1QztJQUMxQkYsMEJBQTBCO1FBQ3hCRyxXQUFXQyxPQUFPLEdBQUdGO0lBQ3ZCO0lBQ0EsT0FBT3RDLGtEQUFXQSxDQUFDO1FBQ2pCLElBQUssSUFBSUUsT0FBT0MsVUFBVUMsTUFBTSxFQUFFcUMsT0FBTyxJQUFJbkMsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQ3ZGa0MsSUFBSSxDQUFDbEMsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDOUI7UUFFQSxPQUFPZ0MsV0FBV0MsT0FBTyxJQUFJLE9BQU8sS0FBSyxJQUFJRCxXQUFXQyxPQUFPLElBQUlDO0lBQ3JFLEdBQUcsRUFBRTtBQUNQO0FBRUEsU0FBU0M7SUFDUCxNQUFNQyxjQUFjNUMsNkNBQU1BLENBQUM7SUFDM0IsTUFBTTZDLE1BQU01QyxrREFBV0EsQ0FBQyxDQUFDNkMsVUFBVUM7UUFDakNILFlBQVlILE9BQU8sR0FBR08sWUFBWUYsVUFBVUM7SUFDOUMsR0FBRyxFQUFFO0lBQ0wsTUFBTUUsUUFBUWhELGtEQUFXQSxDQUFDO1FBQ3hCLElBQUkyQyxZQUFZSCxPQUFPLEtBQUssTUFBTTtZQUNoQ1MsY0FBY04sWUFBWUgsT0FBTztZQUNqQ0csWUFBWUgsT0FBTyxHQUFHO1FBQ3hCO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBTztRQUFDSTtRQUFLSTtLQUFNO0FBQ3JCO0FBRUEsU0FBU0UsZUFBZUMsS0FBSyxFQUFFQyxZQUFZO0lBQ3pDLElBQUlBLGlCQUFpQixLQUFLLEdBQUc7UUFDM0JBLGVBQWU7WUFBQ0Q7U0FBTTtJQUN4QjtJQUVBLE1BQU1FLFdBQVd0RCw2Q0FBTUEsQ0FBQ29EO0lBQ3hCZiwwQkFBMEI7UUFDeEIsSUFBSWlCLFNBQVNiLE9BQU8sS0FBS1csT0FBTztZQUM5QkUsU0FBU2IsT0FBTyxHQUFHVztRQUNyQjtJQUNGLEdBQUdDO0lBQ0gsT0FBT0M7QUFDVDtBQUVBLFNBQVNDLFlBQVlDLFFBQVEsRUFBRUgsWUFBWTtJQUN6QyxNQUFNQyxXQUFXdEQsNkNBQU1BO0lBQ3ZCLE9BQU9ILDhDQUFPQSxDQUFDO1FBQ2IsTUFBTTRELFdBQVdELFNBQVNGLFNBQVNiLE9BQU87UUFDMUNhLFNBQVNiLE9BQU8sR0FBR2dCO1FBQ25CLE9BQU9BO0lBQ1QsR0FDQTtXQUFJSjtLQUFhO0FBQ25CO0FBRUEsU0FBU0ssV0FBV0MsUUFBUTtJQUMxQixNQUFNQyxrQkFBa0J0QixTQUFTcUI7SUFDakMsTUFBTWxELE9BQU9ULDZDQUFNQSxDQUFDO0lBQ3BCLE1BQU02RCxhQUFhNUQsa0RBQVdBLENBQUNnQixDQUFBQTtRQUM3QixJQUFJQSxZQUFZUixLQUFLZ0MsT0FBTyxFQUFFO1lBQzVCbUIsbUJBQW1CLE9BQU8sS0FBSyxJQUFJQSxnQkFBZ0IzQyxTQUFTUixLQUFLZ0MsT0FBTztRQUMxRTtRQUVBaEMsS0FBS2dDLE9BQU8sR0FBR3hCO0lBQ2pCLEdBQ0EsRUFBRTtJQUNGLE9BQU87UUFBQ1I7UUFBTW9EO0tBQVc7QUFDM0I7QUFFQSxTQUFTQyxZQUFZVixLQUFLO0lBQ3hCLE1BQU16QyxNQUFNWCw2Q0FBTUE7SUFDbEJELGdEQUFTQSxDQUFDO1FBQ1JZLElBQUk4QixPQUFPLEdBQUdXO0lBQ2hCLEdBQUc7UUFBQ0E7S0FBTTtJQUNWLE9BQU96QyxJQUFJOEIsT0FBTztBQUNwQjtBQUVBLElBQUlzQixNQUFNLENBQUM7QUFDWCxTQUFTQyxZQUFZQyxNQUFNLEVBQUViLEtBQUs7SUFDaEMsT0FBT3ZELDhDQUFPQSxDQUFDO1FBQ2IsSUFBSXVELE9BQU87WUFDVCxPQUFPQTtRQUNUO1FBRUEsTUFBTWMsS0FBS0gsR0FBRyxDQUFDRSxPQUFPLElBQUksT0FBTyxJQUFJRixHQUFHLENBQUNFLE9BQU8sR0FBRztRQUNuREYsR0FBRyxDQUFDRSxPQUFPLEdBQUdDO1FBQ2QsT0FBT0QsU0FBUyxNQUFNQztJQUN4QixHQUFHO1FBQUNEO1FBQVFiO0tBQU07QUFDcEI7QUFFQSxTQUFTZSxtQkFBbUJDLFFBQVE7SUFDbEMsT0FBTyxTQUFVQyxNQUFNO1FBQ3JCLElBQUssSUFBSWxFLE9BQU9DLFVBQVVDLE1BQU0sRUFBRWlFLGNBQWMsSUFBSS9ELE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTtZQUNqSDhELFdBQVcsQ0FBQzlELE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDekM7UUFFQSxPQUFPOEQsWUFBWUMsTUFBTSxDQUFDLENBQUNDLGFBQWFDO1lBQ3RDLE1BQU1DLFVBQVV2RCxPQUFPdUQsT0FBTyxDQUFDRDtZQUUvQixLQUFLLE1BQU0sQ0FBQ0UsS0FBS0MsZ0JBQWdCLElBQUlGLFFBQVM7Z0JBQzVDLE1BQU10QixRQUFRb0IsV0FBVyxDQUFDRyxJQUFJO2dCQUU5QixJQUFJdkIsU0FBUyxNQUFNO29CQUNqQm9CLFdBQVcsQ0FBQ0csSUFBSSxHQUFHdkIsUUFBUWdCLFdBQVdRO2dCQUN4QztZQUNGO1lBRUEsT0FBT0o7UUFDVCxHQUFHO1lBQUUsR0FBR0gsTUFBTTtRQUNkO0lBQ0Y7QUFDRjtBQUVBLE1BQU1RLE1BQU0sV0FBVyxHQUFFVixtQkFBbUI7QUFDNUMsTUFBTVcsV0FBVyxXQUFXLEdBQUVYLG1CQUFtQixDQUFDO0FBRWxELFNBQVNZLCtCQUErQkMsS0FBSztJQUMzQyxPQUFPLGFBQWFBLFNBQVMsYUFBYUE7QUFDNUM7QUFFQSxTQUFTQyxnQkFBZ0JELEtBQUs7SUFDNUIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsTUFBTSxFQUNKRSxhQUFhLEVBQ2QsR0FBRzFELFVBQVV3RCxNQUFNdkQsTUFBTTtJQUMxQixPQUFPeUQsaUJBQWlCRixpQkFBaUJFO0FBQzNDO0FBRUEsU0FBU0MsYUFBYUgsS0FBSztJQUN6QixJQUFJLENBQUNBLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFFQSxNQUFNLEVBQ0pJLFVBQVUsRUFDWCxHQUFHNUQsVUFBVXdELE1BQU12RCxNQUFNO0lBQzFCLE9BQU8yRCxjQUFjSixpQkFBaUJJO0FBQ3hDO0FBRUE7O0NBRUMsR0FFRCxTQUFTQyxvQkFBb0JMLEtBQUs7SUFDaEMsSUFBSUcsYUFBYUgsUUFBUTtRQUN2QixJQUFJQSxNQUFNTSxPQUFPLElBQUlOLE1BQU1NLE9BQU8sQ0FBQ2pGLE1BQU0sRUFBRTtZQUN6QyxNQUFNLEVBQ0prRixTQUFTQyxDQUFDLEVBQ1ZDLFNBQVNDLENBQUMsRUFDWCxHQUFHVixNQUFNTSxPQUFPLENBQUMsRUFBRTtZQUNwQixPQUFPO2dCQUNMRTtnQkFDQUU7WUFDRjtRQUNGLE9BQU8sSUFBSVYsTUFBTVcsY0FBYyxJQUFJWCxNQUFNVyxjQUFjLENBQUN0RixNQUFNLEVBQUU7WUFDOUQsTUFBTSxFQUNKa0YsU0FBU0MsQ0FBQyxFQUNWQyxTQUFTQyxDQUFDLEVBQ1gsR0FBR1YsTUFBTVcsY0FBYyxDQUFDLEVBQUU7WUFDM0IsT0FBTztnQkFDTEg7Z0JBQ0FFO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSVgsK0JBQStCQyxRQUFRO1FBQ3pDLE9BQU87WUFDTFEsR0FBR1IsTUFBTU8sT0FBTztZQUNoQkcsR0FBR1YsTUFBTVMsT0FBTztRQUNsQjtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUEsTUFBTUcsTUFBTSxXQUFXLEdBQUV6RSxPQUFPMEUsTUFBTSxDQUFDO0lBQ3JDQyxXQUFXO1FBQ1R6RSxVQUFTMEUsU0FBUztZQUNoQixJQUFJLENBQUNBLFdBQVc7Z0JBQ2Q7WUFDRjtZQUVBLE1BQU0sRUFDSlAsQ0FBQyxFQUNERSxDQUFDLEVBQ0YsR0FBR0s7WUFDSixPQUFPLGlCQUFrQlAsQ0FBQUEsSUFBSVEsS0FBS0MsS0FBSyxDQUFDVCxLQUFLLEtBQUssU0FBVUUsQ0FBQUEsSUFBSU0sS0FBS0MsS0FBSyxDQUFDUCxLQUFLLEtBQUs7UUFDdkY7SUFFRjtJQUNBUSxPQUFPO1FBQ0w3RSxVQUFTMEUsU0FBUztZQUNoQixJQUFJLENBQUNBLFdBQVc7Z0JBQ2Q7WUFDRjtZQUVBLE1BQU0sRUFDSkksTUFBTSxFQUNOQyxNQUFNLEVBQ1AsR0FBR0w7WUFDSixPQUFPLFlBQVlJLFNBQVMsY0FBY0MsU0FBUztRQUNyRDtJQUVGO0lBQ0FDLFdBQVc7UUFDVGhGLFVBQVMwRSxTQUFTO1lBQ2hCLElBQUksQ0FBQ0EsV0FBVztnQkFDZDtZQUNGO1lBRUEsT0FBTztnQkFBQ0gsSUFBSUUsU0FBUyxDQUFDekUsUUFBUSxDQUFDMEU7Z0JBQVlILElBQUlNLEtBQUssQ0FBQzdFLFFBQVEsQ0FBQzBFO2FBQVcsQ0FBQ08sSUFBSSxDQUFDO1FBQ2pGO0lBRUY7SUFDQUMsWUFBWTtRQUNWbEYsVUFBU21GLElBQUk7WUFDWCxJQUFJLEVBQ0ZDLFFBQVEsRUFDUjFELFFBQVEsRUFDUjJELE1BQU0sRUFDUCxHQUFHRjtZQUNKLE9BQU9DLFdBQVcsTUFBTTFELFdBQVcsUUFBUTJEO1FBQzdDO0lBRUY7QUFDRjtBQUVBLE1BQU1DLFdBQVc7QUFDakIsU0FBU0MsdUJBQXVCM0YsT0FBTztJQUNyQyxJQUFJQSxRQUFRNEYsT0FBTyxDQUFDRixXQUFXO1FBQzdCLE9BQU8xRjtJQUNUO0lBRUEsT0FBT0EsUUFBUTZGLGFBQWEsQ0FBQ0g7QUFDL0I7QUFFbVgsQ0FDblgseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhZHlmb3Jtcy1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvdXRpbGl0aWVzL2Rpc3QvdXRpbGl0aWVzLmVzbS5qcz8yNThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VDb21iaW5lZFJlZnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWZzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlZnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiBub2RlID0+IHtcbiAgICByZWZzLmZvckVhY2gocmVmID0+IHJlZihub2RlKSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgcmVmcyk7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbmNvbnN0IGNhblVzZURPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzV2luZG93KGVsZW1lbnQpIHtcbiAgY29uc3QgZWxlbWVudFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRTdHJpbmcgPT09ICdbb2JqZWN0IFdpbmRvd10nIHx8IC8vIEluIEVsZWN0cm9uIGNvbnRleHQgdGhlIFdpbmRvdyBvYmplY3Qgc2VyaWFsaXplcyB0byBbb2JqZWN0IGdsb2JhbF1cbiAgZWxlbWVudFN0cmluZyA9PT0gJ1tvYmplY3QgZ2xvYmFsXSc7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiAnbm9kZVR5cGUnIGluIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyh0YXJnZXQpIHtcbiAgdmFyIF90YXJnZXQkb3duZXJEb2N1bWVudCwgX3RhcmdldCRvd25lckRvY3VtZW50MjtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAoaXNXaW5kb3codGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoIWlzTm9kZSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiAoX3RhcmdldCRvd25lckRvY3VtZW50ID0gKF90YXJnZXQkb3duZXJEb2N1bWVudDIgPSB0YXJnZXQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkb3duZXJEb2N1bWVudDIuZGVmYXVsdFZpZXcpICE9IG51bGwgPyBfdGFyZ2V0JG93bmVyRG9jdW1lbnQgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGlzRG9jdW1lbnQobm9kZSkge1xuICBjb25zdCB7XG4gICAgRG9jdW1lbnRcbiAgfSA9IGdldFdpbmRvdyhub2RlKTtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIGlmIChpc1dpbmRvdyhub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGdldFdpbmRvdyhub2RlKS5TVkdFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KHRhcmdldCkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGlmIChpc1dpbmRvdyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5kb2N1bWVudDtcbiAgfVxuXG4gIGlmICghaXNOb2RlKHRhcmdldCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoaXNEb2N1bWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkgfHwgaXNTVkdFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnQ7XG59XG5cbi8qKlxyXG4gKiBBIGhvb2sgdGhhdCByZXNvbHZlcyB0byB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciBhbmQgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBjbGllbnRcclxuICogQHBhcmFtIGNhbGxiYWNrIHtmdW5jdGlvbn0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHdoZW4gdGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgaG9vayBjaGFuZ2VcclxuICovXG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHVzZUV2ZW50KGhhbmRsZXIpIHtcbiAgY29uc3QgaGFuZGxlclJlZiA9IHVzZVJlZihoYW5kbGVyKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlcjtcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyUmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJSZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRlcnZhbCgpIHtcbiAgY29uc3QgaW50ZXJ2YWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldCA9IHVzZUNhbGxiYWNrKChsaXN0ZW5lciwgZHVyYXRpb24pID0+IHtcbiAgICBpbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIGR1cmF0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBjbGVhciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaW50ZXJ2YWxSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgIGludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gW3NldCwgY2xlYXJdO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RWYWx1ZSh2YWx1ZSwgZGVwZW5kZW5jaWVzKSB7XG4gIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkge1xuICAgIGRlcGVuZGVuY2llcyA9IFt2YWx1ZV07XG4gIH1cblxuICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgdmFsdWVSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSwgZGVwZW5kZW5jaWVzKTtcbiAgcmV0dXJuIHZhbHVlUmVmO1xufVxuXG5mdW5jdGlvbiB1c2VMYXp5TWVtbyhjYWxsYmFjaywgZGVwZW5kZW5jaWVzKSB7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGNhbGxiYWNrKHZhbHVlUmVmLmN1cnJlbnQpO1xuICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgWy4uLmRlcGVuZGVuY2llc10pO1xufVxuXG5mdW5jdGlvbiB1c2VOb2RlUmVmKG9uQ2hhbmdlKSB7XG4gIGNvbnN0IG9uQ2hhbmdlSGFuZGxlciA9IHVzZUV2ZW50KG9uQ2hhbmdlKTtcbiAgY29uc3Qgbm9kZSA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0Tm9kZVJlZiA9IHVzZUNhbGxiYWNrKGVsZW1lbnQgPT4ge1xuICAgIGlmIChlbGVtZW50ICE9PSBub2RlLmN1cnJlbnQpIHtcbiAgICAgIG9uQ2hhbmdlSGFuZGxlciA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2VIYW5kbGVyKGVsZW1lbnQsIG5vZGUuY3VycmVudCk7XG4gICAgfVxuXG4gICAgbm9kZS5jdXJyZW50ID0gZWxlbWVudDtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgW10pO1xuICByZXR1cm4gW25vZGUsIHNldE5vZGVSZWZdO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG5sZXQgaWRzID0ge307XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIHZhbHVlKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGlkc1twcmVmaXhdID09IG51bGwgPyAwIDogaWRzW3ByZWZpeF0gKyAxO1xuICAgIGlkc1twcmVmaXhdID0gaWQ7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiLVwiICsgaWQ7XG4gIH0sIFtwcmVmaXgsIHZhbHVlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFkanVzdG1lbnRGbihtb2RpZmllcikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhZGp1c3RtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhZGp1c3RtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkanVzdG1lbnRzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGFkanVzdG1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhZGp1c3RtZW50KTtcblxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZUFkanVzdG1lbnRdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhY2N1bXVsYXRvcltrZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlICsgbW9kaWZpZXIgKiB2YWx1ZUFkanVzdG1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH0sIHsgLi4ub2JqZWN0XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGFkZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBZGp1c3RtZW50Rm4oMSk7XG5jb25zdCBzdWJ0cmFjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBZGp1c3RtZW50Rm4oLTEpO1xuXG5mdW5jdGlvbiBoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMoZXZlbnQpIHtcbiAgcmV0dXJuICdjbGllbnRYJyBpbiBldmVudCAmJiAnY2xpZW50WScgaW4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzS2V5Ym9hcmRFdmVudChldmVudCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIEtleWJvYXJkRXZlbnRcbiAgfSA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpO1xuICByZXR1cm4gS2V5Ym9hcmRFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIFRvdWNoRXZlbnRcbiAgfSA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpO1xuICByZXR1cm4gVG91Y2hFdmVudCAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQ7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WDogeCxcbiAgICAgICAgY2xpZW50WTogeVxuICAgICAgfSA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgIGNsaWVudFk6IHlcbiAgICAgIH0gPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1ZpZXdwb3J0UmVsYXRpdmVDb29yZGluYXRlcyhldmVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IENTUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgVHJhbnNsYXRlOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgKHggPyBNYXRoLnJvdW5kKHgpIDogMCkgKyBcInB4LCBcIiArICh5ID8gTWF0aC5yb3VuZCh5KSA6IDApICsgXCJweCwgMClcIjtcbiAgICB9XG5cbiAgfSxcbiAgU2NhbGU6IHtcbiAgICB0b1N0cmluZyh0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWVxuICAgICAgfSA9IHRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBcInNjYWxlWChcIiArIHNjYWxlWCArIFwiKSBzY2FsZVkoXCIgKyBzY2FsZVkgKyBcIilcIjtcbiAgICB9XG5cbiAgfSxcbiAgVHJhbnNmb3JtOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbQ1NTLlRyYW5zbGF0ZS50b1N0cmluZyh0cmFuc2Zvcm0pLCBDU1MuU2NhbGUudG9TdHJpbmcodHJhbnNmb3JtKV0uam9pbignICcpO1xuICAgIH1cblxuICB9LFxuICBUcmFuc2l0aW9uOiB7XG4gICAgdG9TdHJpbmcoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmdcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHByb3BlcnR5ICsgXCIgXCIgKyBkdXJhdGlvbiArIFwibXMgXCIgKyBlYXNpbmc7XG4gICAgfVxuXG4gIH1cbn0pO1xuXG5jb25zdCBTRUxFQ1RPUiA9ICdhLGZyYW1lLGlmcmFtZSxpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KDpkaXNhYmxlZCksc2VsZWN0Om5vdCg6ZGlzYWJsZWQpLHRleHRhcmVhOm5vdCg6ZGlzYWJsZWQpLGJ1dHRvbjpub3QoOmRpc2FibGVkKSwqW3RhYmluZGV4XSc7XG5mdW5jdGlvbiBmaW5kRmlyc3RGb2N1c2FibGVOb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubWF0Y2hlcyhTRUxFQ1RPUikpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1IpO1xufVxuXG5leHBvcnQgeyBDU1MsIGFkZCwgY2FuVXNlRE9NLCBmaW5kRmlyc3RGb2N1c2FibGVOb2RlLCBnZXRFdmVudENvb3JkaW5hdGVzLCBnZXRPd25lckRvY3VtZW50LCBnZXRXaW5kb3csIGhhc1ZpZXdwb3J0UmVsYXRpdmVDb29yZGluYXRlcywgaXNEb2N1bWVudCwgaXNIVE1MRWxlbWVudCwgaXNLZXlib2FyZEV2ZW50LCBpc05vZGUsIGlzU1ZHRWxlbWVudCwgaXNUb3VjaEV2ZW50LCBpc1dpbmRvdywgc3VidHJhY3QsIHVzZUNvbWJpbmVkUmVmcywgdXNlRXZlbnQsIHVzZUludGVydmFsLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCB1c2VMYXRlc3RWYWx1ZSwgdXNlTGF6eU1lbW8sIHVzZU5vZGVSZWYsIHVzZVByZXZpb3VzLCB1c2VVbmlxdWVJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VDb21iaW5lZFJlZnMiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicmVmcyIsIkFycmF5IiwiX2tleSIsIm5vZGUiLCJmb3JFYWNoIiwicmVmIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNXaW5kb3ciLCJlbGVtZW50IiwiZWxlbWVudFN0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzTm9kZSIsImdldFdpbmRvdyIsInRhcmdldCIsIl90YXJnZXQkb3duZXJEb2N1bWVudCIsIl90YXJnZXQkb3duZXJEb2N1bWVudDIiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0RvY3VtZW50IiwiRG9jdW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NWR0VsZW1lbnQiLCJTVkdFbGVtZW50IiwiZ2V0T3duZXJEb2N1bWVudCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VFdmVudCIsImhhbmRsZXIiLCJoYW5kbGVyUmVmIiwiY3VycmVudCIsImFyZ3MiLCJ1c2VJbnRlcnZhbCIsImludGVydmFsUmVmIiwic2V0IiwibGlzdGVuZXIiLCJkdXJhdGlvbiIsInNldEludGVydmFsIiwiY2xlYXIiLCJjbGVhckludGVydmFsIiwidXNlTGF0ZXN0VmFsdWUiLCJ2YWx1ZSIsImRlcGVuZGVuY2llcyIsInZhbHVlUmVmIiwidXNlTGF6eU1lbW8iLCJjYWxsYmFjayIsIm5ld1ZhbHVlIiwidXNlTm9kZVJlZiIsIm9uQ2hhbmdlIiwib25DaGFuZ2VIYW5kbGVyIiwic2V0Tm9kZVJlZiIsInVzZVByZXZpb3VzIiwiaWRzIiwidXNlVW5pcXVlSWQiLCJwcmVmaXgiLCJpZCIsImNyZWF0ZUFkanVzdG1lbnRGbiIsIm1vZGlmaWVyIiwib2JqZWN0IiwiYWRqdXN0bWVudHMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImFkanVzdG1lbnQiLCJlbnRyaWVzIiwia2V5IiwidmFsdWVBZGp1c3RtZW50IiwiYWRkIiwic3VidHJhY3QiLCJoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMiLCJldmVudCIsImlzS2V5Ym9hcmRFdmVudCIsIktleWJvYXJkRXZlbnQiLCJpc1RvdWNoRXZlbnQiLCJUb3VjaEV2ZW50IiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsInRvdWNoZXMiLCJjbGllbnRYIiwieCIsImNsaWVudFkiLCJ5IiwiY2hhbmdlZFRvdWNoZXMiLCJDU1MiLCJmcmVlemUiLCJUcmFuc2xhdGUiLCJ0cmFuc2Zvcm0iLCJNYXRoIiwicm91bmQiLCJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIlRyYW5zZm9ybSIsImpvaW4iLCJUcmFuc2l0aW9uIiwiX3JlZiIsInByb3BlcnR5IiwiZWFzaW5nIiwiU0VMRUNUT1IiLCJmaW5kRmlyc3RGb2N1c2FibGVOb2RlIiwibWF0Y2hlcyIsInF1ZXJ5U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\n");

/***/ })

};
;